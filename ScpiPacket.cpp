/////////////////////////////////////////////////////////////////////
//
// Copyright 2000-2020, Digital Lightwave, Inc.
// All Rights Reserved.
//
// $Workfile: ScpiPacket.cpp  $
// $Revision: 33510 $
//   $Author: patrickellis $
//     $Date: 2026-01-07 13:31:25 -0500 (Wed, 07 Jan 2026) $
//
// DESCRIPTION:
//   Class definitions for the packet SCPI commands.
//
/////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "ScpiPacket.h"
#include "CorbaClient.h"
#include "global.h"
#include "ParserTemplate.h"
#include "SmallStringArray.h"
#include "Event.h"
#include "errAlarmNameLists.h"
#include "SaveRestorePacket.h"

using namespace std;

// Constants defined here.
// The conventions used is:
// -the function name followed by an underscore and then the description.
// -the description of the value.
const float             TXSETAPSBAD_LOWERLIMIT          = static_cast<float>(0.1);
const float             TXSETAPSBAD_UPPERLIMIT          = static_cast<float>(1638.3);
const float             TXSETAPSGOOD_LOWERLIMIT         = static_cast<float>(0.1);
const float             TXSETAPSGOOD_UPPERLIMIT         = static_cast<float>(1638.3);
const unsigned short    TXSETBERTPAYLOADLEN_LOWERLIMIT  = 64;
const unsigned short    TXSETBERTPAYLOADLEN_UPPERLIMIT  = 9216;
const unsigned short    TXSETBERT_RATE_LEN_LOWERLIMIT   = 0;
const unsigned short    TXSETBERT_RATE_LEN_UPPERLIMIT   = 100;

const unsigned short    STRMSETBW_LOWERLIMIT                = 1;
const unsigned short    STRMSETBW_UPPERLIMIT                = 100;
const unsigned short    STRMSETPAYLOAD_LOWERLIMIT       = 0;
const unsigned long     STRMSETPAYLOAD_UPPERLIMIT       = 0xffffffff;
const unsigned short    STRMSETFRAMELENGTH_LOWERLIMIT = 60;
const unsigned short    STRMSETFRAMELENGTH_UPPERLIMIT = 9220;
const unsigned short    STRMSETSRCMAC_LOWERLIMIT        = 0;
const unsigned short    STRMSETSRCMAC_UPPERLIMIT        = 0xff;
const unsigned short    STRMSETSRCIP_LOWERLIMIT         = 0;
const unsigned short    STRMSETSRCIP_UPPERLIMIT         = 0xff;
const unsigned short    STRMSETSRCPORT_LOWERLIMIT       = 0;
const unsigned short    STRMSETSRCPORT_UPPERLIMIT       = 65535;
const unsigned short    STRMSETDESTMAC_LOWERLIMIT       = 0;
const unsigned short    STRMSETDESTMAC_UPPERLIMIT       = 0xff;
const unsigned short    STRMSETDESTIP_LOWERLIMIT        = 0;
const unsigned short    STRMSETDESTIP_UPPERLIMIT        = 0xff;
const unsigned short    STRMSETDESTPORT_LOWERLIMIT      = 0;
const unsigned short    STRMSETDESTPORT_UPPERLIMIT      = 65535;
const unsigned short    STRMSETVLANID_LOWERLIMIT        = 0;
const unsigned short    STRMSETVLANID_UPPERLIMIT        = 4095;
const unsigned short    STRMSETVLANQOS_LOWERLIMIT       = 0;
const unsigned short    STRMSETVLANQOS_UPPERLIMIT       = 7;
const unsigned short    STRMSETIPTOS_LOWERLIMIT         = 0;
const unsigned short    STRMSETIPTOS_UPPERLIMIT         = 255;
const unsigned short    STRMSETIPTTL_LOWERLIMIT         = 0;
const unsigned short    STRMSETIPTTL_UPPERLIMIT         = 255;
const unsigned short    RFCSETTESTDURATION_LOWERLIMIT = 1;
const unsigned short    RFCSETTESTDURATION_UPPERLIMIT = 600;
const float             RFCSETTHRULOSS_LOWERLIMIT       = 0.0;
const float             RFCSETTHRULOSS_UPPERLIMIT       = 100.0;
const float             RFCSETTHRURES_LOWERLIMIT        = 1.0;
const float             RFCSETTHRURES_UPPERLIMIT        = 100.0;
const unsigned short    RFC_RATE_CEILING_UPPERLIMIT     = 100;
const unsigned short    RFC_RATE_FLOOR_LOWERLIMIT       = 1;
const unsigned short    RFC_TESTINDEX_LOWERLIMIT        = 0;
const unsigned short    RFC_TESTINDEX_UPPERLIMIT        = 9;
const unsigned short    RFC_TESTSIZE_LOWERLIMIT         = 64;
const unsigned short    RFC_TESTSIZE_UPPERLIMIT         = 9000;

const unsigned short    STREAMFRAMELENGTH = 64;
const unsigned short    STREAMPERCENTBW = 25;


/////////////////////////////////////////////////
// The following are the Command Line Interface
// user provided string paramters. Localized here
// for easy modification.
/////////////////////////////////////////////////

// ON & OFF STRING PARAMS
static CString csOnOFF[] =
{
   "OFF",
   "ON" ,
   "IDLE"
};

static CString csEnableDisabled[] = {"ENABLED", "DISABLED"};


///////////////////////////////////////////////////////////////////////////////
// Allows m_pScpiProxyServer->ReportCmdGetStatus() to be used without
// additional code executing after a failure.
///////////////////////////////////////////////////////////////////////////////
#define TestCmdGetStatus(statusFunction)\
    {\
        DLI_INT32 status = m_pScpiProxyServer->ReportCmdGetStatus(statusFunction);\
        if (status != IDL_SUCCESS)\
            return;\
    }

///////////////////////////////////////////////////////////////////////////////
// Get command string to see if a parameter is there. If not then it handles
// the error, otherwise it extracts the parameter.
///////////////////////////////////////////////////////////////////////////////
#define TestAndGetParam(csScpiCmd, csParam)\
    {\
        if (csScpiCmd.IsEmpty())\
        {\
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);\
            return;\
        }\
        csParam = CUtils::getAndStripFirstParam(&csScpiCmd);\
    }

ScpiPacket::~ScpiPacket(void)
{
   // NO DYNAMIC ALLOCATION HERE!
}

//*****************************************
// Initialize command parsing tables.
//*****************************************
ScpiPacket::ScpiPacket(AllGblStruct* p_globs, ScpiProxyServer* pScpiProxyServer)
{

     // Get reference to the ScpiProxyServer singleton
    m_pScpiProxyServer = pScpiProxyServer;

    // Needed until SCPI is fully integrated with ModelInterface.
    m_globs    = p_globs;
    g_DataMgr3 = CorbaClient::m_DataMgr3;

    m_boardRevision = CorbaClient::m_SystemCon2->boardRevision();


    ///////////////////////////////////////////////////////////
    // NOTES:
    //  1. Table fields are lined-up to make it easier to
    //     spot errors in indexing and function assignments.
    //     Belive me, this will be of help as more tables
    //     are added.
    //
    //  2. The csKeyword is not needed for the last entry
    //     in the table. Only requirement is to assign a NULL
    //     function to the last member of the table sequence.
    ///////////////////////////////////////////////////////////

    // ROOT PARSE TABLE
    rootPacket                [0].csKeyWord = "RES";          rootPacket        [0].pFunct = &ScpiPacket::doResLevel;
    rootPacket                [1].csKeyWord = "FETC";         rootPacket        [1].pFunct = &ScpiPacket::doResLevel;
    rootPacket                [2].csKeyWord = "TX";           rootPacket        [2].pFunct = &ScpiPacket::doTxLevel;
    rootPacket                [3].csKeyWord = "RX";           rootPacket        [3].pFunct = &ScpiPacket::doRxLevel;
    rootPacket                [4].csKeyWord = "SOUR";         rootPacket        [4].pFunct = &ScpiPacket::doTxLevel;
    rootPacket                [5].csKeyWord = "STRM";         rootPacket        [5].pFunct = &ScpiPacket::doStrmLevel;
    rootPacket                [6].csKeyWord = "RFC";          rootPacket        [6].pFunct = &ScpiPacket::doRfcLevel;
    rootPacket                [7].csKeyWord = "SD";           rootPacket        [7].pFunct = &ScpiPacket::dosdLevel;
    rootPacket                [8].csKeyWord = "SEEDAB";       rootPacket        [8].pFunct = &ScpiPacket::doSeedABLevel;
    rootPacket                [9].csKeyWord = "PING";         rootPacket        [9].pFunct = &ScpiPacket::doPingLevel;
    rootPacket                [10].csKeyWord = "ARP";         rootPacket       [10].pFunct = &ScpiPacket::doArpLevel;
    rootPacket                [11].csKeyWord = "Y1564";       rootPacket       [11].pFunct = &ScpiPacket::doY1564Level;
                                                              rootPacket       [12].pFunct = NULL;

////////////// Start Update Parse Tables by Mike ///////////////////////

    // RES PARSE TABLE

    resLevel     [0].csKeyWord = "LINECODE";     resLevel         [0].pFunct = &ScpiPacket::doResLinecodeLevel;
    resLevel     [1].csKeyWord = "COLLISION";    resLevel         [1].pFunct = &ScpiPacket::doResCollisionLevel;
    resLevel     [2].csKeyWord = "PFCS";         resLevel         [2].pFunct = &ScpiPacket::doResPfcsLevel;
    resLevel     [3].csKeyWord = "IPCHECKSUM";   resLevel         [3].pFunct = &ScpiPacket::doResIpChecksumLevel;
    resLevel     [4].csKeyWord = "SCANERRORS?";  resLevel         [4].pFunct = &ScpiPacket::getCurrentErrors;
    resLevel     [5].csKeyWord = "FCALIGN";      resLevel         [5].pFunct = &ScpiPacket::doResFcAlignLevel;
    resLevel     [6].csKeyWord = "OVERSIZED";    resLevel         [6].pFunct = &ScpiPacket::doResOversizedLevel;
    resLevel     [7].csKeyWord = "UNDERSIZED";   resLevel         [7].pFunct = &ScpiPacket::doResUndersizedLevel;

    resLevel     [8].csKeyWord = "LOSS";         resLevel         [8].pFunct = &ScpiPacket::doResCppLevel;
    resLevel     [9].csKeyWord = "LOS";          resLevel         [9].pFunct = &ScpiPacket::doResLosLevel;
    resLevel    [10].csKeyWord = "LINK";         resLevel        [10].pFunct = &ScpiPacket::doResLinkLevel;

    resLevel    [11].csKeyWord = "TXPACK?";      resLevel        [11].pFunct = &ScpiPacket::getResTxPackets;
    resLevel    [12].csKeyWord = "RXPACK?";      resLevel        [12].pFunct = &ScpiPacket::getResRxPackets;
    resLevel    [13].csKeyWord = "TXBYT?";       resLevel        [13].pFunct = &ScpiPacket::getResTxBytes;
    resLevel    [14].csKeyWord = "RXBYT?";       resLevel        [14].pFunct = &ScpiPacket::getResRxBytes;
    resLevel    [15].csKeyWord = "JUMBO?";       resLevel        [15].pFunct = &ScpiPacket::getResRxJumboPackets;

    resLevel    [16].csKeyWord = "PAUSE";        resLevel        [16].pFunct = &ScpiPacket::doResPauseLevel;
    resLevel    [17].csKeyWord = "TXPACK";       resLevel        [17].pFunct = &ScpiPacket::doResTxPacketLevel;
    resLevel    [18].csKeyWord = "VLAN";         resLevel        [18].pFunct = &ScpiPacket::doResVlanLevel;

    resLevel    [19].csKeyWord = "TXPCTBW?";     resLevel        [19].pFunct = &ScpiPacket::getResTxLinkPctBandwidthNone;
    resLevel    [20].csKeyWord = "RXPCTBW?";     resLevel        [20].pFunct = &ScpiPacket::getResRxLinkPctBandwidthNone;
    resLevel    [21].csKeyWord = "TXPPS?";       resLevel        [21].pFunct = &ScpiPacket::getResTxLinkPacketPerSecNone;
    resLevel    [22].csKeyWord = "RXPPS?";       resLevel        [22].pFunct = &ScpiPacket::getResRxLinkPacketPerSecNone;
    resLevel    [23].csKeyWord = "TXMBPS?";      resLevel        [23].pFunct = &ScpiPacket::getResTxLinkKBPerSecNone;
    resLevel    [24].csKeyWord = "RXMBPS?";      resLevel        [24].pFunct = &ScpiPacket::getResRxLinkKBPerSecNone;
    resLevel    [25].csKeyWord = "SPM?";         resLevel        [25].pFunct = &ScpiPacket::getResSPM;
    resLevel    [26].csKeyWord = "STSD?";        resLevel        [26].pFunct = &ScpiPacket::getResSTSD;
    resLevel    [27].csKeyWord = "EVENTLOG";     resLevel        [27].pFunct = &ScpiPacket::getEventLog;
    resLevel    [28].csKeyWord = "RF";           resLevel        [28].pFunct = &ScpiPacket::doResRfLevel;
    resLevel    [29].csKeyWord = "LFD";          resLevel        [29].pFunct = &ScpiPacket::doResLfdLevel;
    resLevel    [30].csKeyWord = "RXBCAST?";     resLevel        [30].pFunct = &ScpiPacket::getRxbCast;
    resLevel    [31].csKeyWord = "RXMCAST?";     resLevel        [31].pFunct = &ScpiPacket::getRxmCast;
    resLevel    [32].csKeyWord = "RXUCAST?";     resLevel        [32].pFunct = &ScpiPacket::getRxuCast;
    resLevel    [33].csKeyWord = "RX64?";        resLevel        [33].pFunct = &ScpiPacket::getRx64bp;
    resLevel    [34].csKeyWord = "RX65?";        resLevel        [34].pFunct = &ScpiPacket::getRx65bp;
    resLevel    [35].csKeyWord = "RX128?";       resLevel        [35].pFunct = &ScpiPacket::getRx128bp;
    resLevel    [36].csKeyWord = "RX256?";       resLevel        [36].pFunct = &ScpiPacket::getRx256bp;
    resLevel    [37].csKeyWord = "RX512?";       resLevel        [37].pFunct = &ScpiPacket::getRx512bp;
    resLevel    [38].csKeyWord = "RX1024?";      resLevel        [38].pFunct = &ScpiPacket::getRx1024bp;
    resLevel    [39].csKeyWord = "RX1519?";      resLevel        [39].pFunct = &ScpiPacket::getRx1519bp;

    resLevel    [40].csKeyWord = "UCHEC";        resLevel        [40].pFunct = &ScpiPacket::doResUnCorrCHecLevel;
    resLevel    [41].csKeyWord = "CHEC";         resLevel        [41].pFunct = &ScpiPacket::doResCorrCHecLevel;
    resLevel    [42].csKeyWord = "UTHEC";        resLevel        [42].pFunct = &ScpiPacket::doResUnCorrTHecLevel;
    resLevel    [43].csKeyWord = "THEC";         resLevel        [43].pFunct = &ScpiPacket::doResCorrTHecLevel;
    resLevel    [44].csKeyWord = "UEHEC";        resLevel        [44].pFunct = &ScpiPacket::doResUnCorrEHecLevel;
    resLevel    [45].csKeyWord = "EHEC";         resLevel        [45].pFunct = &ScpiPacket::doResCorrEHecLevel;
    resLevel    [46].csKeyWord = "SFCS";         resLevel        [46].pFunct = &ScpiPacket::doResSfcsLevel;

    resLevel    [47].csKeyWord = "TXIDLE?";       resLevel       [47].pFunct = &ScpiPacket::getTxIdle;
    resLevel    [48].csKeyWord = "RXIDLE?";       resLevel       [48].pFunct = &ScpiPacket::getRxIdle;
    resLevel    [49].csKeyWord = "TXSUPERBLOCK?"; resLevel       [49].pFunct = &ScpiPacket::getTxSuperBlock;
    resLevel    [50].csKeyWord = "RXSUPERBLOCK?"; resLevel       [50].pFunct = &ScpiPacket::getRxSuperBlock;

    resLevel    [51].csKeyWord = "LF";            resLevel       [51].pFunct = &ScpiPacket::doResLfLevel;
    resLevel    [52].csKeyWord = "LOCCS";         resLevel       [52].pFunct = &ScpiPacket::doResLoccsLevel;
    resLevel    [53].csKeyWord = "LOCS";          resLevel       [53].pFunct = &ScpiPacket::doResLocLevel;
    resLevel    [54].csKeyWord = "CRC";           resLevel       [54].pFunct = &ScpiPacket::doResFcsLevel;
    resLevel    [55].csKeyWord = "FABRICLOGIN?";  resLevel       [55].pFunct = &ScpiPacket::getFabricLoginStatus;
    resLevel    [56].csKeyWord = "PORTLOGIN?";    resLevel       [56].pFunct = &ScpiPacket::getPortLoginStatus;
    resLevel    [57].csKeyWord = "MOSSERRS?";      resLevel       [57].pFunct = &ScpiPacket::getTxIdle;
    resLevel    [58].csKeyWord = "FCDISP";        resLevel       [58].pFunct = &ScpiPacket::doResFcDispLevel;
    resLevel    [59].csKeyWord = "FCEOFA";        resLevel       [59].pFunct = &ScpiPacket::doResFcEofALevel;
    resLevel    [60].csKeyWord = "MOSSALRMS?";     resLevel      [60].pFunct = &ScpiPacket::getTxIdle;
    resLevel    [61].csKeyWord = "FCTXRRDY?";     resLevel       [61].pFunct = &ScpiPacket::getFcTxRrdy;
    resLevel    [62].csKeyWord = "FCRXRRDY?";     resLevel       [62].pFunct = &ScpiPacket::getFcRxRrdy;
    resLevel    [63].csKeyWord = "FCBBCREDIT?";   resLevel       [63].pFunct = &ScpiPacket::getFcBbCredit;
    resLevel    [64].csKeyWord = "FCRRDYPEND?";   resLevel       [64].pFunct = &ScpiPacket::getFcRrdyPend;
    resLevel    [65].csKeyWord = "RUNT";          resLevel       [65].pFunct = &ScpiPacket::doResRuntLevel;
    resLevel    [66].csKeyWord = "FCS";           resLevel       [66].pFunct = &ScpiPacket::doResFcsLevel;
    resLevel    [67].csKeyWord = "INVSUPER";      resLevel       [67].pFunct = &ScpiPacket::doResInvSuperLevel;
    resLevel    [68].csKeyWord = "JABBER";        resLevel       [68].pFunct = &ScpiPacket::doResJabberLevel;

    resLevel    [69].csKeyWord = "TCPERR";       resLevel        [69].pFunct = &ScpiPacket::doResTcpChecksumLevel;
    resLevel    [70].csKeyWord = "UDPERR";       resLevel        [70].pFunct = &ScpiPacket::doResUdpChecksumLevel;
    resLevel    [71].csKeyWord = "SCANALARMS?";  resLevel        [71].pFunct = &ScpiPacket::getCurrentAlarms;
    resLevel    [72].csKeyWord = "FCEOFERR";     resLevel        [72].pFunct = &ScpiPacket::doResFcEofErrLevel;
    resLevel    [73].csKeyWord = "AL";           resLevel        [73].pFunct = &ScpiPacket::doResAlarmLevel;
    resLevel    [74].csKeyWord = "DISPARITY";    resLevel        [74].pFunct = &ScpiPacket::doResDisparityLevel;
    resLevel    [75].csKeyWord = "CAPTURE";      resLevel        [75].pFunct = &ScpiPacket::doResCaptureLevel;
    resLevel    [76].csKeyWord = "HDRMM";        resLevel        [76].pFunct = &ScpiPacket::doResHdrMMLevel;
    resLevel    [77].csKeyWord = "RXPACK";       resLevel        [77].pFunct = &ScpiPacket::doResRxPacketLevel;

    resLevel    [78].csKeyWord = "UTIL";         resLevel        [78].pFunct = &ScpiPacket::doResUtilLevel;
    resLevel    [79].csKeyWord = "MPLS";         resLevel        [79].pFunct = &ScpiPacket::doResMplsLevel;
    resLevel    [80].csKeyWord = "PACK";         resLevel        [80].pFunct = &ScpiPacket::doResPacketLevel;
    resLevel    [81].csKeyWord = "SUPJUMBO?";    resLevel        [81].pFunct = &ScpiPacket::getResOversizedCount;
    resLevel    [82].csKeyWord = "SYNCHDR";      resLevel        [82].pFunct = &ScpiPacket::doResSyncHdrLevel;
    resLevel    [83].csKeyWord = "BLKLOC";       resLevel        [83].pFunct = &ScpiPacket::doResBlockLockLossLevel;
    resLevel    [84].csKeyWord = "HIBER";        resLevel        [84].pFunct = &ScpiPacket::doResHiBerLevel;
    resLevel    [85].csKeyWord = "PAUSED";       resLevel        [85].pFunct = &ScpiPacket::doResPauseLevel;
    resLevel    [86].csKeyWord = "CAPSTATUS?";   resLevel        [86].pFunct = &ScpiPacket::getCaptureStatus;
    resLevel    [87].csKeyWord = "CAPCOUNT?";    resLevel        [87].pFunct = &ScpiPacket::getCaptureCount;
                                                 resLevel        [88].pFunct = NULL;


    // RES:UTILization PARSE TABLE
    resUtilLevel    [0].csKeyWord = "CUR";     resUtilLevel        [0].pFunct = &ScpiPacket::doResUtilCurLevel;
    resUtilLevel    [1].csKeyWord = "AVG";     resUtilLevel        [1].pFunct = &ScpiPacket::doResUtilAvgLevel;
    resUtilLevel    [2].csKeyWord = "MAX";     resUtilLevel        [2].pFunct = &ScpiPacket::doResUtilMaxLevel;
    resUtilLevel    [3].csKeyWord = "MIN";     resUtilLevel        [3].pFunct = &ScpiPacket::doResUtilMinLevel;
    resUtilLevel    [4].csKeyWord = "MPLS";    resUtilLevel        [4].pFunct = &ScpiPacket::doResUtilMplsLevel;
    resUtilLevel    [5].csKeyWord = "VLAN";    resUtilLevel        [5].pFunct = &ScpiPacket::doResUtilVlanLevel;
    resUtilLevel    [6].csKeyWord = "IPV4";    resUtilLevel        [6].pFunct = &ScpiPacket::doResUtilIpv4Level;
    resUtilLevel    [7].csKeyWord = "IPV6";    resUtilLevel        [7].pFunct = &ScpiPacket::doResUtilIpv6Level;
    resUtilLevel    [8].csKeyWord = "L1";      resUtilLevel        [8].pFunct = &ScpiPacket::doResUtilL1Level;
    resUtilLevel    [9].csKeyWord = "L2";      resUtilLevel        [9].pFunct = &ScpiPacket::doResUtilL2Level;
                                               resUtilLevel       [10].pFunct = NULL;
    // RES:UTIL:L1 PARSE TABLE
    resUtilL1Level    [0].csKeyWord = "CUR";     resUtilL1Level        [0].pFunct = &ScpiPacket::doResUtilCurLevel;
    resUtilL1Level    [1].csKeyWord = "AVG";     resUtilL1Level        [1].pFunct = &ScpiPacket::doResUtilAvgLevel;
    resUtilL1Level    [2].csKeyWord = "MAX";     resUtilL1Level        [2].pFunct = &ScpiPacket::doResUtilMaxLevel;
    resUtilL1Level    [3].csKeyWord = "MIN";     resUtilL1Level        [3].pFunct = &ScpiPacket::doResUtilMinLevel;
    resUtilL1Level    [4].csKeyWord = "MPLS";    resUtilL1Level        [4].pFunct = &ScpiPacket::doResUtilMplsLevel;
    resUtilL1Level    [5].csKeyWord = "VLAN";    resUtilL1Level        [5].pFunct = &ScpiPacket::doResUtilVlanLevel;
    resUtilL1Level    [6].csKeyWord = "IPV4";    resUtilL1Level        [6].pFunct = &ScpiPacket::doResUtilIpv4Level;
    resUtilL1Level    [7].csKeyWord = "IPV6";    resUtilL1Level        [7].pFunct = &ScpiPacket::doResUtilIpv6Level;
                                                 resUtilL1Level        [8].pFunct = NULL;

    // RES:UTIL:CUR PARSE TABLE    (deprecated)
    // RES:UTIL:L1:CUR PARSE TABLE (newer command)
    resUtilCurLevel    [0].csKeyWord = "TXPCTBW?";     resUtilCurLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthNone;
    resUtilCurLevel    [1].csKeyWord = "RXPCTBW?";     resUtilCurLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthNone;
    resUtilCurLevel    [2].csKeyWord = "TXPPS?";       resUtilCurLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecNone;
    resUtilCurLevel    [3].csKeyWord = "RXPPS?";       resUtilCurLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecNone;
    resUtilCurLevel    [4].csKeyWord = "TXMBPS?";      resUtilCurLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecNone;
    resUtilCurLevel    [5].csKeyWord = "RXMBPS?";      resUtilCurLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecNone;
                                                       resUtilCurLevel        [6].pFunct = NULL;

    // RES:UTIL:AVG PARSE TABLE    (deprecated)
    // RES:UTIL:L1:AVG PARSE TABLE (newer command)
    resUtilAvgLevel    [0].csKeyWord = "TXPCTBW?";     resUtilAvgLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthAvgNone;
    resUtilAvgLevel    [1].csKeyWord = "RXPCTBW?";     resUtilAvgLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthAvgNone;
    resUtilAvgLevel    [2].csKeyWord = "TXPPS?";       resUtilAvgLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecAvgNone;
    resUtilAvgLevel    [3].csKeyWord = "RXPPS?";       resUtilAvgLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecAvgNone;
    resUtilAvgLevel    [4].csKeyWord = "TXMBPS?";      resUtilAvgLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecAvgNone;
    resUtilAvgLevel    [5].csKeyWord = "RXMBPS?";      resUtilAvgLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecAvgNone;
                                                       resUtilAvgLevel        [6].pFunct = NULL;

    // RES:UTIL:MAX PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MAX PARSE TABLE (newer command)
    resUtilMaxLevel    [0].csKeyWord = "TXPCTBW?";     resUtilMaxLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMaxNone;
    resUtilMaxLevel    [1].csKeyWord = "RXPCTBW?";     resUtilMaxLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMaxNone;
    resUtilMaxLevel    [2].csKeyWord = "TXPPS?";       resUtilMaxLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMaxNone;
    resUtilMaxLevel    [3].csKeyWord = "RXPPS?";       resUtilMaxLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMaxNone;
    resUtilMaxLevel    [4].csKeyWord = "TXMBPS?";      resUtilMaxLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMaxNone;
    resUtilMaxLevel    [5].csKeyWord = "RXMBPS?";      resUtilMaxLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMaxNone;
                                                       resUtilMaxLevel        [6].pFunct = NULL;

    // RES:UTIL:MIN PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MIN PARSE TABLE (newer command)
    resUtilMinLevel    [0].csKeyWord = "TXPCTBW?";     resUtilMinLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMinNone;
    resUtilMinLevel    [1].csKeyWord = "RXPCTBW?";     resUtilMinLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMinNone;
    resUtilMinLevel    [2].csKeyWord = "TXPPS?";       resUtilMinLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMinNone;
    resUtilMinLevel    [3].csKeyWord = "RXPPS?";       resUtilMinLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMinNone;
    resUtilMinLevel    [4].csKeyWord = "TXMBPS?";      resUtilMinLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMinNone;
    resUtilMinLevel    [5].csKeyWord = "RXMBPS?";      resUtilMinLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMinNone;
                                                       resUtilMinLevel        [6].pFunct = NULL;

    // RES:UTIL:MPLS PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MPLS PARSE TABLE (newer command)
    resUtilMplsLevel    [0].csKeyWord = "CUR";         resUtilMplsLevel        [0].pFunct = &ScpiPacket::doResUtilMplsCurLevel;
    resUtilMplsLevel    [1].csKeyWord = "AVG";         resUtilMplsLevel        [1].pFunct = &ScpiPacket::doResUtilMplsAvgLevel;
    resUtilMplsLevel    [2].csKeyWord = "MAX";         resUtilMplsLevel        [2].pFunct = &ScpiPacket::doResUtilMplsMaxLevel;
    resUtilMplsLevel    [3].csKeyWord = "MIN";         resUtilMplsLevel        [3].pFunct = &ScpiPacket::doResUtilMplsMinLevel;
                                                       resUtilMplsLevel        [4].pFunct = NULL;

    // RES:UTIL:MPLS:CUR PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MPLS:CUR PARSE TABLE (newer command)
    resUtilMplsCurLevel    [0].csKeyWord = "TXPCTBW?";     resUtilMplsCurLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMpls;
    resUtilMplsCurLevel    [1].csKeyWord = "RXPCTBW?";     resUtilMplsCurLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMpls;
    resUtilMplsCurLevel    [2].csKeyWord = "TXPPS?";       resUtilMplsCurLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMpls;
    resUtilMplsCurLevel    [3].csKeyWord = "RXPPS?";       resUtilMplsCurLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMpls;
    resUtilMplsCurLevel    [4].csKeyWord = "TXMBPS?";      resUtilMplsCurLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMpls;
    resUtilMplsCurLevel    [5].csKeyWord = "RXMBPS?";      resUtilMplsCurLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMpls;
                                                           resUtilMplsCurLevel        [6].pFunct = NULL;


    // RES:UTIL:MPLS:AVG PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MPLS:AVG PARSE TABLE (newer command)
    resUtilMplsAvgLevel    [0].csKeyWord = "TXPCTBW?";     resUtilMplsAvgLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthAvgMpls;
    resUtilMplsAvgLevel    [1].csKeyWord = "RXPCTBW?";     resUtilMplsAvgLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthAvgMpls;
    resUtilMplsAvgLevel    [2].csKeyWord = "TXPPS?";       resUtilMplsAvgLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecAvgMpls;
    resUtilMplsAvgLevel    [3].csKeyWord = "RXPPS?";       resUtilMplsAvgLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecAvgMpls;
    resUtilMplsAvgLevel    [4].csKeyWord = "TXMBPS?";      resUtilMplsAvgLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecAvgMpls;
    resUtilMplsAvgLevel    [5].csKeyWord = "RXMBPS?";      resUtilMplsAvgLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecAvgMpls;
                                                           resUtilMplsAvgLevel        [6].pFunct = NULL;

    // RES:UTIL:MPLS:MAX PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MPLS:MAX PARSE TABLE (newer command)
    resUtilMplsMaxLevel    [0].csKeyWord = "TXPCTBW?";     resUtilMplsMaxLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMaxMpls;
    resUtilMplsMaxLevel    [1].csKeyWord = "RXPCTBW?";     resUtilMplsMaxLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMaxMpls;
    resUtilMplsMaxLevel    [2].csKeyWord = "TXPPS?";       resUtilMplsMaxLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMaxMpls;
    resUtilMplsMaxLevel    [3].csKeyWord = "RXPPS?";       resUtilMplsMaxLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMaxMpls;
    resUtilMplsMaxLevel    [4].csKeyWord = "TXMBPS?";      resUtilMplsMaxLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMaxMpls;
    resUtilMplsMaxLevel    [5].csKeyWord = "RXMBPS?";      resUtilMplsMaxLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMaxMpls;
                                                           resUtilMplsMaxLevel        [6].pFunct = NULL;

    // RES:UTIL:MPLS:MIN PARSE TABLE    (deprecated)
    // RES:UTIL:L1:MPLS:MIN PARSE TABLE (newer command)
    resUtilMplsMinLevel    [0].csKeyWord = "TXPCTBW?";     resUtilMplsMinLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMinMpls;
    resUtilMplsMinLevel    [1].csKeyWord = "RXPCTBW?";     resUtilMplsMinLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMinMpls;
    resUtilMplsMinLevel    [2].csKeyWord = "TXPPS?";       resUtilMplsMinLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMinMpls;
    resUtilMplsMinLevel    [3].csKeyWord = "RXPPS?";       resUtilMplsMinLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMinMpls;
    resUtilMplsMinLevel    [4].csKeyWord = "TXMBPS?";      resUtilMplsMinLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMinMpls;
    resUtilMplsMinLevel    [5].csKeyWord = "RXMBPS?";      resUtilMplsMinLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMinMpls;
                                                           resUtilMplsMinLevel        [6].pFunct = NULL;


    // RES:UTIL:VLAN PARSE TABLE    (deprecated)
    // RES:UTIL:L1:VLAN PARSE TABLE (newer command)
    resUtilVlanLevel    [0].csKeyWord = "CUR";             resUtilVlanLevel        [0].pFunct = &ScpiPacket::doResUtilVlanCurLevel;
    resUtilVlanLevel    [1].csKeyWord = "AVG";             resUtilVlanLevel        [1].pFunct = &ScpiPacket::doResUtilVlanAvgLevel;
    resUtilVlanLevel    [2].csKeyWord = "MAX";             resUtilVlanLevel        [2].pFunct = &ScpiPacket::doResUtilVlanMaxLevel;
    resUtilVlanLevel    [3].csKeyWord = "MIN";             resUtilVlanLevel        [3].pFunct = &ScpiPacket::doResUtilVlanMinLevel;
                                                           resUtilVlanLevel        [4].pFunct = NULL;

    // RES:UTIL:VLAN:CUR PARSE TABLE    (deprecated)
    // RES:UTIL:L1:VLAN:CUR PARSE TABLE (newer command)
    resUtilVlanCurLevel    [0].csKeyWord = "TXPCTBW?";     resUtilVlanCurLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthVlan;
    resUtilVlanCurLevel    [1].csKeyWord = "RXPCTBW?";     resUtilVlanCurLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthVlan;
    resUtilVlanCurLevel    [2].csKeyWord = "TXPPS?";       resUtilVlanCurLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecVlan;
    resUtilVlanCurLevel    [3].csKeyWord = "RXPPS?";       resUtilVlanCurLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecVlan;
    resUtilVlanCurLevel    [4].csKeyWord = "TXMBPS?";      resUtilVlanCurLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecVlan;
    resUtilVlanCurLevel    [5].csKeyWord = "RXMBPS?";      resUtilVlanCurLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecVlan;
                                                           resUtilVlanCurLevel        [6].pFunct = NULL;
    // RES:UTIL:VLAN:AVG PARSE TABLE    (deprecated)
    // RES:UTIL:L1:VLAN:AVG PARSE TABLE (newer command)
    resUtilVlanAvgLevel    [0].csKeyWord = "TXPCTBW?";     resUtilVlanAvgLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthAvgVlan;
    resUtilVlanAvgLevel    [1].csKeyWord = "RXPCTBW?";     resUtilVlanAvgLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthAvgVlan;
    resUtilVlanAvgLevel    [2].csKeyWord = "TXPPS?";       resUtilVlanAvgLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecAvgVlan;
    resUtilVlanAvgLevel    [3].csKeyWord = "RXPPS?";       resUtilVlanAvgLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecAvgVlan;
    resUtilVlanAvgLevel    [4].csKeyWord = "TXMBPS?";      resUtilVlanAvgLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecAvgVlan;
    resUtilVlanAvgLevel    [5].csKeyWord = "RXMBPS?";      resUtilVlanAvgLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecAvgVlan;
                                                           resUtilVlanAvgLevel        [6].pFunct = NULL;

    // RES:UTIL:VLAN:MAX PARSE TABLE    (deprecated)
    // RES:UTIL:L1:VLAN:MAX PARSE TABLE (newer command)
    resUtilVlanMaxLevel    [0].csKeyWord = "TXPCTBW?";     resUtilVlanMaxLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMaxVlan;
    resUtilVlanMaxLevel    [1].csKeyWord = "RXPCTBW?";     resUtilVlanMaxLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMaxVlan;
    resUtilVlanMaxLevel    [2].csKeyWord = "TXPPS?";       resUtilVlanMaxLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMaxVlan;
    resUtilVlanMaxLevel    [3].csKeyWord = "RXPPS?";       resUtilVlanMaxLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMaxVlan;
    resUtilVlanMaxLevel    [4].csKeyWord = "TXMBPS?";      resUtilVlanMaxLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMaxVlan;
    resUtilVlanMaxLevel    [5].csKeyWord = "RXMBPS?";      resUtilVlanMaxLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMaxVlan;
                                                           resUtilVlanMaxLevel        [6].pFunct = NULL;

    // RES:UTIL:VLAN:MIN PARSE TABLE    (deprecated)
    // RES:UTIL:L1:VLAN:MIN PARSE TABLE (newer command)
    resUtilVlanMinLevel    [0].csKeyWord = "TXPCTBW?";     resUtilVlanMinLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMinVlan;
    resUtilVlanMinLevel    [1].csKeyWord = "RXPCTBW?";     resUtilVlanMinLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMinVlan;
    resUtilVlanMinLevel    [2].csKeyWord = "TXPPS?";       resUtilVlanMinLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMinVlan;
    resUtilVlanMinLevel    [3].csKeyWord = "RXPPS?";       resUtilVlanMinLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMinVlan;
    resUtilVlanMinLevel    [4].csKeyWord = "TXMBPS?";      resUtilVlanMinLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMinVlan;
    resUtilVlanMinLevel    [5].csKeyWord = "RXMBPS?";      resUtilVlanMinLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMinVlan;
                                                           resUtilVlanMinLevel        [6].pFunct = NULL;

    // RES:UTIL:L2 PARSE TABLE
    resUtilL2Level    [0].csKeyWord = "CUR";     resUtilL2Level                   [0].pFunct = &ScpiPacket::doResUtilL2CurLevel;
    resUtilL2Level    [1].csKeyWord = "AVG";     resUtilL2Level                   [1].pFunct = &ScpiPacket::doResUtilL2AvgLevel;
    resUtilL2Level    [2].csKeyWord = "MAX";     resUtilL2Level                   [2].pFunct = &ScpiPacket::doResUtilL2MaxLevel;
    resUtilL2Level    [3].csKeyWord = "MIN";     resUtilL2Level                   [3].pFunct = &ScpiPacket::doResUtilL2MinLevel;
                                                 resUtilL2Level                   [4].pFunct = NULL;

    // RES:UTIL:L2:CUR PARSE TABLE
    resUtilL2CurLevel    [0].csKeyWord = "TXPCTBW?";     resUtilL2CurLevel        [0].pFunct = &ScpiPacket::getResL2TxLinkPctBandwidthNone;
    resUtilL2CurLevel    [1].csKeyWord = "RXPCTBW?";     resUtilL2CurLevel        [1].pFunct = &ScpiPacket::getResL2RxLinkPctBandwidthNone;
    resUtilL2CurLevel    [2].csKeyWord = "TXMBPS?";      resUtilL2CurLevel        [2].pFunct = &ScpiPacket::getResL2TxLinkKBPerSecNone;
    resUtilL2CurLevel    [3].csKeyWord = "RXMBPS?";      resUtilL2CurLevel        [3].pFunct = &ScpiPacket::getResL2RxLinkKBPerSecNone;
                                                         resUtilL2CurLevel        [4].pFunct = NULL;

    // RES:UTIL:L2:AVG PARSE TABLE
    resUtilL2AvgLevel    [0].csKeyWord = "TXPCTBW?";     resUtilL2AvgLevel        [0].pFunct = &ScpiPacket::getResL2TxLinkPctBandwidthAvgNone;
    resUtilL2AvgLevel    [1].csKeyWord = "RXPCTBW?";     resUtilL2AvgLevel        [1].pFunct = &ScpiPacket::getResL2RxLinkPctBandwidthAvgNone;
    resUtilL2AvgLevel    [2].csKeyWord = "TXMBPS?";      resUtilL2AvgLevel        [2].pFunct = &ScpiPacket::getResL2TxLinkKBPerSecAvgNone;
    resUtilL2AvgLevel    [3].csKeyWord = "RXMBPS?";      resUtilL2AvgLevel        [3].pFunct = &ScpiPacket::getResL2RxLinkKBPerSecAvgNone;
                                                         resUtilL2AvgLevel        [4].pFunct = NULL;

    // RES:UTIL:L2:MAX PARSE TABLE
    resUtilL2MaxLevel    [0].csKeyWord = "TXPCTBW?";     resUtilL2MaxLevel        [0].pFunct = &ScpiPacket::getResL2TxLinkPctBandwidthMaxNone;
    resUtilL2MaxLevel    [1].csKeyWord = "RXPCTBW?";     resUtilL2MaxLevel        [1].pFunct = &ScpiPacket::getResL2RxLinkPctBandwidthMaxNone;
    resUtilL2MaxLevel    [2].csKeyWord = "TXMBPS?";      resUtilL2MaxLevel        [2].pFunct = &ScpiPacket::getResL2TxLinkKBPerSecMaxNone;
    resUtilL2MaxLevel    [3].csKeyWord = "RXMBPS?";      resUtilL2MaxLevel        [3].pFunct = &ScpiPacket::getResL2RxLinkKBPerSecMaxNone;
                                                         resUtilL2MaxLevel        [4].pFunct = NULL;

    // RES:UTIL:L2:MIN PARSE TABLE
    resUtilL2MinLevel    [0].csKeyWord = "TXPCTBW?";     resUtilL2MinLevel        [0].pFunct = &ScpiPacket::getResL2TxLinkPctBandwidthMinNone;
    resUtilL2MinLevel    [1].csKeyWord = "RXPCTBW?";     resUtilL2MinLevel        [1].pFunct = &ScpiPacket::getResL2RxLinkPctBandwidthMinNone;
    resUtilL2MinLevel    [2].csKeyWord = "TXMBPS?";      resUtilL2MinLevel        [2].pFunct = &ScpiPacket::getResL2TxLinkKBPerSecMinNone;
    resUtilL2MinLevel    [3].csKeyWord = "RXMBPS?";      resUtilL2MinLevel        [3].pFunct = &ScpiPacket::getResL2RxLinkKBPerSecMinNone;
                                                         resUtilL2MinLevel        [4].pFunct = NULL;

/////////////////////////////////////////////////////////IPV4////////////////////////////////////////////////////////////////

    // RES:UTIL:IPV4 PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV4 PARSE TABLE (newer command)
    resUtilIpv4Level    [0].csKeyWord = "CUR";             resUtilIpv4Level        [0].pFunct = &ScpiPacket::doResUtilIpv4CurLevel;
    resUtilIpv4Level    [1].csKeyWord = "AVG";             resUtilIpv4Level        [1].pFunct = &ScpiPacket::doResUtilIpv4AvgLevel;
    resUtilIpv4Level    [2].csKeyWord = "MAX";             resUtilIpv4Level        [2].pFunct = &ScpiPacket::doResUtilIpv4MaxLevel;
    resUtilIpv4Level    [3].csKeyWord = "MIN";             resUtilIpv4Level        [3].pFunct = &ScpiPacket::doResUtilIpv4MinLevel;
                                                           resUtilIpv4Level        [4].pFunct = NULL;

    // RES:UTIL:IPV4:CUR PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV4:CUR PARSE TABLE (newer command)
    resUtilIpv4CurLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv4CurLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthIpv4;
    resUtilIpv4CurLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv4CurLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthIpv4;
    resUtilIpv4CurLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv4CurLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecIpv4;
    resUtilIpv4CurLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv4CurLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecIpv4;
    resUtilIpv4CurLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv4CurLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecIpv4;
    resUtilIpv4CurLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv4CurLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecIpv4;
                                                           resUtilIpv4CurLevel        [6].pFunct = NULL;
    // RES:UTIL:IPV4:AVG PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV4:AVG PARSE TABLE (newer command)
    resUtilIpv4AvgLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv4AvgLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthAvgIpv4;
    resUtilIpv4AvgLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv4AvgLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthAvgIpv4;
    resUtilIpv4AvgLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv4AvgLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecAvgIpv4;
    resUtilIpv4AvgLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv4AvgLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecAvgIpv4;
    resUtilIpv4AvgLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv4AvgLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecAvgIpv4;
    resUtilIpv4AvgLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv4AvgLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecAvgIpv4;
                                                           resUtilIpv4AvgLevel        [6].pFunct = NULL;

    // RES:UTIL:IPV4:MAX PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV4:MAX PARSE TABLE (newer command)
    resUtilIpv4MaxLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv4MaxLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMaxIpv4;
    resUtilIpv4MaxLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv4MaxLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMaxIpv4;
    resUtilIpv4MaxLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv4MaxLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMaxIpv4;
    resUtilIpv4MaxLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv4MaxLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMaxIpv4;
    resUtilIpv4MaxLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv4MaxLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMaxIpv4;
    resUtilIpv4MaxLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv4MaxLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMaxIpv4;
                                                           resUtilIpv4MaxLevel        [6].pFunct = NULL;

    // RES:UTIL:IPV4:MIN PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV4:MIN PARSE TABLE (newer command)
    resUtilIpv4MinLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv4MinLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMinIpv4;
    resUtilIpv4MinLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv4MinLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMinIpv4;
    resUtilIpv4MinLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv4MinLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMinIpv4;
    resUtilIpv4MinLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv4MinLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMinIpv4;
    resUtilIpv4MinLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv4MinLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMinIpv4;
    resUtilIpv4MinLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv4MinLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMinIpv4;
                                                           resUtilIpv4MinLevel        [6].pFunct = NULL;

/////////////////////////////////////////////////////////IPV6////////////////////////////////////////////////////////////////

    // RES:UTIL:IPV6 PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV6 PARSE TABLE (newer command)
    resUtilIpv6Level    [0].csKeyWord = "CUR";             resUtilIpv6Level        [0].pFunct = &ScpiPacket::doResUtilIpv6CurLevel;
    resUtilIpv6Level    [1].csKeyWord = "AVG";             resUtilIpv6Level        [1].pFunct = &ScpiPacket::doResUtilIpv6AvgLevel;
    resUtilIpv6Level    [2].csKeyWord = "MAX";             resUtilIpv6Level        [2].pFunct = &ScpiPacket::doResUtilIpv6MaxLevel;
    resUtilIpv6Level    [3].csKeyWord = "MIN";             resUtilIpv6Level        [3].pFunct = &ScpiPacket::doResUtilIpv6MinLevel;
                                                           resUtilIpv6Level        [4].pFunct = NULL;

    // RES:UTIL:IPV6:CUR PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV6:CUR PARSE TABLE (newer command)
    resUtilIpv6CurLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv6CurLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthIpv6;
    resUtilIpv6CurLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv6CurLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthIpv6;
    resUtilIpv6CurLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv6CurLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecIpv6;
    resUtilIpv6CurLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv6CurLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecIpv6;
    resUtilIpv6CurLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv6CurLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecIpv6;
    resUtilIpv6CurLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv6CurLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecIpv6;
                                                           resUtilIpv6CurLevel        [6].pFunct = NULL;
    // RES:UTIL:IPV6:AVG PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV6:AVG PARSE TABLE (newer command)
    resUtilIpv6AvgLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv6AvgLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthAvgIpv6;
    resUtilIpv6AvgLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv6AvgLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthAvgIpv6;
    resUtilIpv6AvgLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv6AvgLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecAvgIpv6;
    resUtilIpv6AvgLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv6AvgLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecAvgIpv6;
    resUtilIpv6AvgLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv6AvgLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecAvgIpv6;
    resUtilIpv6AvgLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv6AvgLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecAvgIpv6;
                                                           resUtilIpv6AvgLevel        [6].pFunct = NULL;

    // RES:UTIL:IPV6:MAX PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV6:MAX PARSE TABLE (newer command)
    resUtilIpv6MaxLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv6MaxLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMaxIpv6;
    resUtilIpv6MaxLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv6MaxLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMaxIpv6;
    resUtilIpv6MaxLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv6MaxLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMaxIpv6;
    resUtilIpv6MaxLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv6MaxLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMaxIpv6;
    resUtilIpv6MaxLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv6MaxLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMaxIpv6;
    resUtilIpv6MaxLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv6MaxLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMaxIpv6;
                                                           resUtilIpv6MaxLevel        [6].pFunct = NULL;

    // RES:UTIL:IPV6:MIN PARSE TABLE    (deprecated)
    // RES:UTIL:L1:IPV6:MIN PARSE TABLE (newer command)
    resUtilIpv6MinLevel    [0].csKeyWord = "TXPCTBW?";     resUtilIpv6MinLevel        [0].pFunct = &ScpiPacket::getResTxLinkPctBandwidthMinIpv6;
    resUtilIpv6MinLevel    [1].csKeyWord = "RXPCTBW?";     resUtilIpv6MinLevel        [1].pFunct = &ScpiPacket::getResRxLinkPctBandwidthMinIpv6;
    resUtilIpv6MinLevel    [2].csKeyWord = "TXPPS?";       resUtilIpv6MinLevel        [2].pFunct = &ScpiPacket::getResTxLinkPacketPerSecMinIpv6;
    resUtilIpv6MinLevel    [3].csKeyWord = "RXPPS?";       resUtilIpv6MinLevel        [3].pFunct = &ScpiPacket::getResRxLinkPacketPerSecMinIpv6;
    resUtilIpv6MinLevel    [4].csKeyWord = "TXMBPS?";      resUtilIpv6MinLevel        [4].pFunct = &ScpiPacket::getResTxLinkKBPerSecMinIpv6;
    resUtilIpv6MinLevel    [5].csKeyWord = "RXMBPS?";      resUtilIpv6MinLevel        [5].pFunct = &ScpiPacket::getResRxLinkKBPerSecMinIpv6;
                                                           resUtilIpv6MinLevel        [6].pFunct = NULL;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // RES:FCALIGN PARSE TABLE
    resFcAlignLevel        [0].csKeyWord = "COUNT?";       resFcAlignLevel    [0].pFunct = &ScpiPacket::getResFcAlignCount;
    resFcAlignLevel        [1].csKeyWord = "ES?";          resFcAlignLevel    [1].pFunct = &ScpiPacket::getResFcAlignES;
    resFcAlignLevel        [2].csKeyWord = "AVGRATE?";     resFcAlignLevel    [2].pFunct = &ScpiPacket::getResFcAlignAvgRate;
    resFcAlignLevel        [3].csKeyWord = "CURRATE?";     resFcAlignLevel    [3].pFunct = &ScpiPacket::getResFcAlignCurRate;
                                                           resFcAlignLevel    [4].pFunct = NULL;

    // RES:FCDISP PARSE TABLE
    resFcDispLevel         [0].csKeyWord = "COUNT?";       resFcDispLevel    [0].pFunct = &ScpiPacket::getResFcDispCount;
    resFcDispLevel         [1].csKeyWord = "ES?";          resFcDispLevel    [1].pFunct = &ScpiPacket::getResFcDispES;
    resFcDispLevel         [2].csKeyWord = "AVGRATE?";     resFcDispLevel    [2].pFunct = &ScpiPacket::getResFcDispAvgRate;
    resFcDispLevel         [3].csKeyWord = "CURRATE?";     resFcDispLevel    [3].pFunct = &ScpiPacket::getResFcDispCurRate;
                                                           resFcDispLevel    [4].pFunct = NULL;

    // RES:FCEOFA PARSE TABLE
    resFcEofALevel         [0].csKeyWord = "COUNT?";       resFcEofALevel    [0].pFunct = &ScpiPacket::getResFcEofACount;
    resFcEofALevel         [1].csKeyWord = "ES?";          resFcEofALevel    [1].pFunct = &ScpiPacket::getResFcEofAES;
    resFcEofALevel         [2].csKeyWord = "AVGRATE?";     resFcEofALevel    [2].pFunct = &ScpiPacket::getResFcEofAAvgRate;
    resFcEofALevel         [3].csKeyWord = "CURRATE?";     resFcEofALevel    [3].pFunct = &ScpiPacket::getResFcEofACurRate;
                                                           resFcEofALevel    [4].pFunct = NULL;

    // RES:FCEOFERR PARSE TABLE
    resFcEofErrLevel      [0].csKeyWord = "COUNT?";       resFcEofErrLevel    [0].pFunct = &ScpiPacket::getResFcEofErrCount;
    resFcEofErrLevel      [1].csKeyWord = "ES?";          resFcEofErrLevel    [1].pFunct = &ScpiPacket::getResFcEofErrES;
    resFcEofErrLevel      [2].csKeyWord = "AVGRATE?";     resFcEofErrLevel    [2].pFunct = &ScpiPacket::getResFcEofErrAvgRate;
    resFcEofErrLevel      [3].csKeyWord = "CURRATE?";     resFcEofErrLevel    [3].pFunct = &ScpiPacket::getResFcEofErrCurRate;
                                                          resFcEofErrLevel    [4].pFunct = NULL;


    // RES:LFD PARSE TABLE
    resLfdLevel                 [0].csKeyWord = "STATE?";       resLfdLevel        [0].pFunct = &ScpiPacket::getResLfdState;
    resLfdLevel                 [1].csKeyWord = "SECS?";        resLfdLevel        [1].pFunct = &ScpiPacket::getResLfdSecs;
                                                                resLfdLevel        [2].pFunct = NULL;

    // RES:LOC PARSE TABLE
    resLocLevel                 [0].csKeyWord = "STATE?";       resLocLevel        [0].pFunct = &ScpiPacket::getResLocState;
    resLocLevel                 [1].csKeyWord = "SECS?";        resLocLevel        [1].pFunct = &ScpiPacket::getResLocSecs;
                                                                resLocLevel        [2].pFunct = NULL;

    // RES:LFD PARSE TABLE
    resLoccsLevel               [0].csKeyWord = "STATE?";       resLoccsLevel      [0].pFunct = &ScpiPacket::getResLoccsState;
    resLoccsLevel               [1].csKeyWord = "SECS?";        resLoccsLevel      [1].pFunct = &ScpiPacket::getResLoccsSecs;
                                                                resLoccsLevel      [2].pFunct = NULL;

    // RES:RF PARSE TABLE
    resRfLevel                 [0].csKeyWord = "SECS?";         resRfLevel        [0].pFunct = &ScpiPacket::getRfSecs;
                                                                resRfLevel        [1].pFunct = NULL;

    // RES:LF PARSE TABLE
    resLfLevel                 [0].csKeyWord = "SECS?";         resLfLevel        [0].pFunct = &ScpiPacket::getLfSecs;
                                                                resLfLevel        [1].pFunct = NULL;

    // RES:JABBER PARSE TABLE
    resJabberLevel             [0].csKeyWord = "SECS?";         resJabberLevel    [0].pFunct = &ScpiPacket::getJabberSecs;
                                                                resJabberLevel    [1].pFunct = NULL;

    // RES:BLKLOC PARSE TABLE
    resBlockLockLossLevel      [0].csKeyWord = "SECS?";         resBlockLockLossLevel[0].pFunct = &ScpiPacket::getBlockLockLossSecs;
                                                                resBlockLockLossLevel[1].pFunct = NULL;

    // RES:HIBER PARSE TABLE
    resHiBerLevel              [0].csKeyWord = "SECS?";         resHiBerLevel     [0].pFunct = &ScpiPacket::getHiBerSecs;
                                                                resHiBerLevel     [1].pFunct = NULL;

    // RES:CPP PARSE TABLE
    resCppLevel                 [0].csKeyWord = "STATE?";       resCppLevel        [0].pFunct = &ScpiPacket::getResCpPowerLossState;
    resCppLevel                 [1].csKeyWord = "SECS?";        resCppLevel        [1].pFunct = &ScpiPacket::getResCpPowerLossSecs;
                                                                resCppLevel        [2].pFunct = NULL;

    // RES:LOS PARSE TABLE
    resLosLevel                 [0].csKeyWord = "STATE?";       resLosLevel        [0].pFunct = &ScpiPacket::getResLosState;
    resLosLevel                 [1].csKeyWord = "SECS?";        resLosLevel        [1].pFunct = &ScpiPacket::getResLosSecs;
                                                                resLosLevel        [2].pFunct = NULL;

    // RES:HDRMM PARSE TABLE
    resHdrMMLevel                 [0].csKeyWord = "STATE?";     resHdrMMLevel        [0].pFunct = &ScpiPacket::getResHdrMMState;
    resHdrMMLevel                 [1].csKeyWord = "SECS?";      resHdrMMLevel        [1].pFunct = &ScpiPacket::getResHdrMMSecs;
                                                                resHdrMMLevel        [2].pFunct = NULL;

    // RES:LINK PARSE TABLE
    resLinkLevel               [0].csKeyWord = "STATE?";        resLinkLevel        [0].pFunct = &ScpiPacket::getResLinkState;
    resLinkLevel               [1].csKeyWord = "SECS?";         resLinkLevel        [1].pFunct = &ScpiPacket::getResLinkSecs;
    resLinkLevel               [2].csKeyWord = "STATUS?";       resLinkLevel        [2].pFunct = &ScpiPacket::getResLinkStatus;
                                                                resLinkLevel        [3].pFunct = NULL;

    // RES:CORRCHEC PARSE TABLE
    resCorrCHecLevel        [0].csKeyWord = "COUNT?";   resCorrCHecLevel    [0].pFunct = &ScpiPacket::getResCorrCHecCount;
    resCorrCHecLevel        [1].csKeyWord = "ES?";      resCorrCHecLevel    [1].pFunct = &ScpiPacket::getResCorrCHecES;
    resCorrCHecLevel        [2].csKeyWord = "AVGRATE?"; resCorrCHecLevel    [2].pFunct = &ScpiPacket::getResCorrCHecAvgRate;
    resCorrCHecLevel        [3].csKeyWord = "CURRATE?"; resCorrCHecLevel    [3].pFunct = &ScpiPacket::getResCorrCHecCurRate;
                                                        resCorrCHecLevel    [4].pFunct = NULL;
    // RES:UNCORRCHEC PARSE TABLE
    resUnCorrCHecLevel      [0].csKeyWord = "COUNT?";   resUnCorrCHecLevel  [0].pFunct = &ScpiPacket::getResUnCorrCHecCount;
    resUnCorrCHecLevel      [1].csKeyWord = "ES?";      resUnCorrCHecLevel  [1].pFunct = &ScpiPacket::getResUnCorrCHecES;
    resUnCorrCHecLevel      [2].csKeyWord = "AVGRATE?"; resUnCorrCHecLevel  [2].pFunct = &ScpiPacket::getResUnCorrCHecAvgRate;
    resUnCorrCHecLevel      [3].csKeyWord = "CURRATE?"; resUnCorrCHecLevel  [3].pFunct = &ScpiPacket::getResUnCorrCHecCurRate;
                                                        resUnCorrCHecLevel  [4].pFunct = NULL;
    // RES:CORRTHEC PARSE TABLE
    resCorrTHecLevel        [0].csKeyWord = "COUNT?";   resCorrTHecLevel    [0].pFunct = &ScpiPacket::getResCorrTHecCount;
    resCorrTHecLevel        [1].csKeyWord = "ES?";      resCorrTHecLevel    [1].pFunct = &ScpiPacket::getResCorrTHecES;
    resCorrTHecLevel        [2].csKeyWord = "AVGRATE?"; resCorrTHecLevel    [2].pFunct = &ScpiPacket::getResCorrTHecAvgRate;
    resCorrTHecLevel        [3].csKeyWord = "CURRATE?"; resCorrTHecLevel    [3].pFunct = &ScpiPacket::getResCorrTHecCurRate;
                                                        resCorrTHecLevel    [4].pFunct = NULL;

    // RES:CORREHEC PARSE TABLE
    resCorrEHecLevel        [0].csKeyWord = "COUNT?";   resCorrEHecLevel    [0].pFunct = &ScpiPacket::getResCorrEHecCount;
    resCorrEHecLevel        [1].csKeyWord = "ES?";      resCorrEHecLevel    [1].pFunct = &ScpiPacket::getResCorrEHecES;
    resCorrEHecLevel        [2].csKeyWord = "AVGRATE?"; resCorrEHecLevel    [2].pFunct = &ScpiPacket::getResCorrEHecAvgRate;
    resCorrEHecLevel        [3].csKeyWord = "CURRATE?"; resCorrEHecLevel    [3].pFunct = &ScpiPacket::getResCorrEHecCurRate;
                                                        resCorrEHecLevel    [4].pFunct = NULL;

    // RES:UNCORRTHEC PARSE TABLE
    resUnCorrTHecLevel      [0].csKeyWord = "COUNT?";   resUnCorrTHecLevel  [0].pFunct = &ScpiPacket::getResUnCorrTHecCount;
    resUnCorrTHecLevel      [1].csKeyWord = "ES?";      resUnCorrTHecLevel  [1].pFunct = &ScpiPacket::getResUnCorrTHecES;
    resUnCorrTHecLevel      [2].csKeyWord = "AVGRATE?"; resUnCorrTHecLevel  [2].pFunct = &ScpiPacket::getResUnCorrTHecAvgRate;
    resUnCorrTHecLevel      [3].csKeyWord = "CURRATE?"; resUnCorrTHecLevel  [3].pFunct = &ScpiPacket::getResUnCorrTHecCurRate;
                                                        resUnCorrTHecLevel  [4].pFunct = NULL;

    // RES:UNCORREHEC PARSE TABLE
    resUnCorrEHecLevel      [0].csKeyWord = "COUNT?";   resUnCorrEHecLevel  [0].pFunct = &ScpiPacket::getResUnCorrEHecCount;
    resUnCorrEHecLevel      [1].csKeyWord = "ES?";      resUnCorrEHecLevel  [1].pFunct = &ScpiPacket::getResUnCorrEHecES;
    resUnCorrEHecLevel      [2].csKeyWord = "AVGRATE?"; resUnCorrEHecLevel  [2].pFunct = &ScpiPacket::getResUnCorrEHecAvgRate;
    resUnCorrEHecLevel      [3].csKeyWord = "CURRATE?"; resUnCorrEHecLevel  [3].pFunct = &ScpiPacket::getResUnCorrEHecCurRate;
                                                        resUnCorrEHecLevel  [4].pFunct = NULL;
    // RES:PFCS PARSE TABLE
    resPfcsLevel      [0].csKeyWord = "COUNT?";   resPfcsLevel  [0].pFunct = &ScpiPacket::getResPfcsCount;
    resPfcsLevel      [1].csKeyWord = "ES?";      resPfcsLevel  [1].pFunct = &ScpiPacket::getResPfcsES;
    resPfcsLevel      [2].csKeyWord = "AVGRATE?"; resPfcsLevel  [2].pFunct = &ScpiPacket::getResPfcsAvgRate;
    resPfcsLevel      [3].csKeyWord = "CURRATE?"; resPfcsLevel  [3].pFunct = &ScpiPacket::getResPfcsCurRate;
                                                  resPfcsLevel  [4].pFunct = NULL;

    // RES:SFCS PARSE TABLE
    resSfcsLevel      [0].csKeyWord = "COUNT?";   resSfcsLevel  [0].pFunct = &ScpiPacket::getResSfcsCount;
    resSfcsLevel      [1].csKeyWord = "ES?";      resSfcsLevel  [1].pFunct = &ScpiPacket::getResSfcsES;
    resSfcsLevel      [2].csKeyWord = "AVGRATE?"; resSfcsLevel  [2].pFunct = &ScpiPacket::getResSfcsAvgRate;
    resSfcsLevel      [3].csKeyWord = "CURRATE?"; resSfcsLevel  [3].pFunct = &ScpiPacket::getResSfcsCurRate;
                                                  resSfcsLevel  [4].pFunct = NULL;
    // RES:INVSUPER PARSE TABLE
    resInvSuperLevel      [0].csKeyWord = "COUNT?";   resInvSuperLevel  [0].pFunct = &ScpiPacket::getResInvSuperCount;
    resInvSuperLevel      [1].csKeyWord = "ES?";      resInvSuperLevel  [1].pFunct = &ScpiPacket::getResInvSuperES;
    resInvSuperLevel      [2].csKeyWord = "AVGRATE?"; resInvSuperLevel  [2].pFunct = &ScpiPacket::getResInvSuperAvgRate;
    resInvSuperLevel      [3].csKeyWord = "CURRATE?"; resInvSuperLevel  [3].pFunct = &ScpiPacket::getResInvSuperCurRate;
                                                      resInvSuperLevel  [4].pFunct = NULL;

    // RES:LINECODE PARSE TABLE
    resLinecodeLevel        [0].csKeyWord = "COUNT?";   resLinecodeLevel    [0].pFunct = &ScpiPacket::getResLinecodeCount;
    resLinecodeLevel        [1].csKeyWord = "ES?";      resLinecodeLevel    [1].pFunct = &ScpiPacket::getResLinecodeES;
    resLinecodeLevel        [2].csKeyWord = "AVGRATE?"; resLinecodeLevel    [2].pFunct = &ScpiPacket::getResLinecodeAvgRate;
    resLinecodeLevel        [3].csKeyWord = "CURRATE?"; resLinecodeLevel    [3].pFunct = &ScpiPacket::getResLinecodeCurRate;
                                                        resLinecodeLevel    [4].pFunct = NULL;

    // RES:SYNCHDR PARSE TABLE
    resSyncHdrLevel         [0].csKeyWord = "COUNT?";   resSyncHdrLevel    [0].pFunct = &ScpiPacket::getResSyncHdrCount;
    resSyncHdrLevel         [1].csKeyWord = "ES?";      resSyncHdrLevel    [1].pFunct = &ScpiPacket::getResSyncHdrES;
    resSyncHdrLevel         [2].csKeyWord = "AVGRATE?"; resSyncHdrLevel    [2].pFunct = &ScpiPacket::getResSyncHdrAvgRate;
    resSyncHdrLevel         [3].csKeyWord = "CURRATE?"; resSyncHdrLevel    [3].pFunct = &ScpiPacket::getResSyncHdrCurRate;
                                                        resSyncHdrLevel    [4].pFunct = NULL;

    // RES:DISPARITY PARSE TABLE
    resDisparityLevel        [0].csKeyWord = "COUNT?";   resDisparityLevel    [0].pFunct = &ScpiPacket::getResDisparityCount;
    resDisparityLevel        [1].csKeyWord = "ES?";      resDisparityLevel    [1].pFunct = &ScpiPacket::getResDisparityES;
    resDisparityLevel        [2].csKeyWord = "AVGRATE?"; resDisparityLevel    [2].pFunct = &ScpiPacket::getResDisparityAvgRate;
    resDisparityLevel        [3].csKeyWord = "CURRATE?"; resDisparityLevel    [3].pFunct = &ScpiPacket::getResDisparityCurRate;
                                                         resDisparityLevel    [4].pFunct = NULL;

    // RES:COLLISIONS PARSE TABLE
    resCollisionLevel        [0].csKeyWord = "COUNT?";   resCollisionLevel    [0].pFunct = &ScpiPacket::getResCollisionCount;
    resCollisionLevel        [1].csKeyWord = "ES?";      resCollisionLevel    [1].pFunct = &ScpiPacket::getResCollisionES;
    resCollisionLevel        [2].csKeyWord = "AVGRATE?"; resCollisionLevel    [2].pFunct = &ScpiPacket::getResCollisionAvgRate;
    resCollisionLevel        [3].csKeyWord = "CURRATE?"; resCollisionLevel    [3].pFunct = &ScpiPacket::getResCollisionCurRate;
                                                         resCollisionLevel    [4].pFunct = NULL;

    // RES:FCS PARSE TABLE
    resFcsLevel             [0].csKeyWord = "COUNT?";       resFcsLevel    [0].pFunct = &ScpiPacket::getResFcsCount;
    resFcsLevel             [1].csKeyWord = "ES?";          resFcsLevel    [1].pFunct = &ScpiPacket::getResFcsES;
    resFcsLevel             [2].csKeyWord = "AVGRATE?";     resFcsLevel    [2].pFunct = &ScpiPacket::getResFcsAvgRate;
    resFcsLevel             [3].csKeyWord = "CURRATE?";     resFcsLevel    [3].pFunct = &ScpiPacket::getResFcsCurRate;
                                                            resFcsLevel    [4].pFunct = NULL;

    // RES:IPCHECKSUM PARSE TABLE
    resIpChecksumLevel        [0].csKeyWord = "COUNT?";   resIpChecksumLevel    [0].pFunct = &ScpiPacket::getResIpChecksumCount;
    resIpChecksumLevel        [1].csKeyWord = "ES?";      resIpChecksumLevel    [1].pFunct = &ScpiPacket::getResIpChecksumES;
    resIpChecksumLevel        [2].csKeyWord = "AVGRATE?"; resIpChecksumLevel    [2].pFunct = &ScpiPacket::getResIpChecksumAvgRate;
    resIpChecksumLevel        [3].csKeyWord = "CURRATE?"; resIpChecksumLevel    [3].pFunct = &ScpiPacket::getResIpChecksumCurRate;
                                                          resIpChecksumLevel    [4].pFunct = NULL;

    // RES:TCPCHECKSUM PARSE TABLE
    resTcpChecksumLevel        [0].csKeyWord = "COUNT?";   resTcpChecksumLevel    [0].pFunct = &ScpiPacket::getResTcpChecksumCount;
    resTcpChecksumLevel        [1].csKeyWord = "ES?";      resTcpChecksumLevel    [1].pFunct = &ScpiPacket::getResTcpChecksumES;
    resTcpChecksumLevel        [2].csKeyWord = "AVGRATE?"; resTcpChecksumLevel    [2].pFunct = &ScpiPacket::getResTcpChecksumAvgRate;
    resTcpChecksumLevel        [3].csKeyWord = "CURRATE?"; resTcpChecksumLevel    [3].pFunct = &ScpiPacket::getResTcpChecksumCurRate;
                                                           resTcpChecksumLevel    [4].pFunct = NULL;

    // RES:UDPCHECKSUM PARSE TABLE
    resUdpChecksumLevel        [0].csKeyWord = "COUNT?";   resUdpChecksumLevel    [0].pFunct = &ScpiPacket::getResUdpChecksumCount;
    resUdpChecksumLevel        [1].csKeyWord = "ES?";      resUdpChecksumLevel    [1].pFunct = &ScpiPacket::getResUdpChecksumES;
    resUdpChecksumLevel        [2].csKeyWord = "AVGRATE?"; resUdpChecksumLevel    [2].pFunct = &ScpiPacket::getResUdpChecksumAvgRate;
    resUdpChecksumLevel        [3].csKeyWord = "CURRATE?"; resUdpChecksumLevel    [3].pFunct = &ScpiPacket::getResUdpChecksumCurRate;
                                                           resUdpChecksumLevel    [4].pFunct = NULL;

    // RES:OVERSIZED PARSE TABLE
    resOversizedLevel        [0].csKeyWord = "COUNT?";   resOversizedLevel    [0].pFunct = &ScpiPacket::getResOversizedCount;
    resOversizedLevel        [1].csKeyWord = "ES?";      resOversizedLevel    [1].pFunct = &ScpiPacket::getResOversizedES;
    resOversizedLevel        [2].csKeyWord = "AVGRATE?"; resOversizedLevel    [2].pFunct = &ScpiPacket::getResOversizedAvgRate;
    resOversizedLevel        [3].csKeyWord = "CURRATE?"; resOversizedLevel    [3].pFunct = &ScpiPacket::getResOversizedCurRate;
                                                         resOversizedLevel    [4].pFunct = NULL;

    // RES:RUNT PARSE TABLE
    resRuntLevel        [0].csKeyWord = "COUNT?";   resRuntLevel    [0].pFunct = &ScpiPacket::getResRuntCount;
    resRuntLevel        [1].csKeyWord = "ES?";      resRuntLevel    [1].pFunct = &ScpiPacket::getResRuntES;
    resRuntLevel        [2].csKeyWord = "AVGRATE?"; resRuntLevel    [2].pFunct = &ScpiPacket::getResRuntAvgRate;
    resRuntLevel        [3].csKeyWord = "CURRATE?"; resRuntLevel    [3].pFunct = &ScpiPacket::getResRuntCurRate;
                                                    resRuntLevel    [4].pFunct = NULL;

    // RES:UNDERSIZED PARSE TABLE
    resUndersizedLevel        [0].csKeyWord = "COUNT?";   resUndersizedLevel    [0].pFunct = &ScpiPacket::getResUndersizedCount;
    resUndersizedLevel        [1].csKeyWord = "ES?";      resUndersizedLevel    [1].pFunct = &ScpiPacket::getResUndersizedES;
    resUndersizedLevel        [2].csKeyWord = "AVGRATE?"; resUndersizedLevel    [2].pFunct = &ScpiPacket::getResUndersizedAvgRate;
    resUndersizedLevel        [3].csKeyWord = "CURRATE?"; resUndersizedLevel    [3].pFunct = &ScpiPacket::getResUndersizedCurRate;
                                                          resUndersizedLevel    [4].pFunct = NULL;

    // RES:PAUSE PARSE TABLE  OR  RES:PAUSED
    resPauseLevel        [0].csKeyWord = "STATE?";        resPauseLevel    [0].pFunct = &ScpiPacket::getResPauseState;
    resPauseLevel        [1].csKeyWord = "SECS?";         resPauseLevel    [1].pFunct = &ScpiPacket::getResPauseSecs;
    resPauseLevel        [2].csKeyWord = "TXPACKETS?";    resPauseLevel    [2].pFunct = &ScpiPacket::getResTxPausePackets;
    resPauseLevel        [3].csKeyWord = "TXQUANTAS?";    resPauseLevel    [3].pFunct = &ScpiPacket::getResTxPauseQuantas;
    resPauseLevel        [4].csKeyWord = "TXENDPACKETS?"; resPauseLevel    [4].pFunct = &ScpiPacket::getResTxPauseEndPackets;
    resPauseLevel        [5].csKeyWord = "PACKETS?";      resPauseLevel    [5].pFunct = &ScpiPacket::getResPausePackets;
    resPauseLevel        [6].csKeyWord = "QUANTAS?";      resPauseLevel    [6].pFunct = &ScpiPacket::getResPauseQuantas;
    resPauseLevel        [7].csKeyWord = "ENDPACKETS?";   resPauseLevel    [7].pFunct = &ScpiPacket::getResPauseEndPackets;
                                                          resPauseLevel    [8].pFunct = NULL;

    // RES:PACKETS PARSE TABLE
    resPacketLevel        [0].csKeyWord = "IPV6?";        resPacketLevel    [0].pFunct = &ScpiPacket::getResIpv6Packets;
    resPacketLevel        [1].csKeyWord = "ICMP?";        resPacketLevel    [1].pFunct = &ScpiPacket::getResIcmpPackets;
    resPacketLevel        [2].csKeyWord = "TCP?";         resPacketLevel    [2].pFunct = &ScpiPacket::getResTcpPackets;
    resPacketLevel        [3].csKeyWord = "UDP?";         resPacketLevel    [3].pFunct = &ScpiPacket::getResUdpPackets;
    resPacketLevel        [4].csKeyWord = "IGMP?";        resPacketLevel    [4].pFunct = &ScpiPacket::getResIgmpPackets;
    resPacketLevel        [5].csKeyWord = "BGP?";         resPacketLevel    [5].pFunct = &ScpiPacket::getResBgpPackets;
    resPacketLevel        [6].csKeyWord = "OSPF?";        resPacketLevel    [6].pFunct = &ScpiPacket::getResOspfPackets;
    resPacketLevel        [7].csKeyWord = "MPLS?";        resPacketLevel    [7].pFunct = &ScpiPacket::getResMplsPackets;
    resPacketLevel        [8].csKeyWord = "IPV4?";        resPacketLevel    [8].pFunct = &ScpiPacket::getResIpPackets;
    resPacketLevel        [8].csKeyWord = "IP?";          resPacketLevel    [8].pFunct = &ScpiPacket::getResIpPackets;
                                                          resPacketLevel    [9].pFunct = NULL;
    // RES:RXPACKETS PARSE TABLE
    resRxPacketLevel        [0].csKeyWord = "JUMBO?";      resRxPacketLevel  [0].pFunct = &ScpiPacket::getResRxJumboPackets;
    resRxPacketLevel        [1].csKeyWord = "SUPERJUMBO?"; resRxPacketLevel  [1].pFunct = &ScpiPacket::getResOversizedCount;
    resRxPacketLevel        [2].csKeyWord = "BGP?";        resRxPacketLevel  [2].pFunct = &ScpiPacket::getResBgpPackets;
    resRxPacketLevel        [3].csKeyWord = "ICMP?";       resRxPacketLevel  [3].pFunct = &ScpiPacket::getResIcmpPackets;
    resRxPacketLevel        [4].csKeyWord = "IGMP?";       resRxPacketLevel  [4].pFunct = &ScpiPacket::getResIgmpPackets;
    resRxPacketLevel        [5].csKeyWord = "IPV4?";       resRxPacketLevel  [5].pFunct = &ScpiPacket::getResIpPackets;
    resRxPacketLevel        [6].csKeyWord = "IPV6?";       resRxPacketLevel  [6].pFunct = &ScpiPacket::getResIpv6Packets;
    resRxPacketLevel        [7].csKeyWord = "MPLS?";       resRxPacketLevel  [7].pFunct = &ScpiPacket::getResMplsPackets;
    resRxPacketLevel        [8].csKeyWord = "OSPF?";       resRxPacketLevel  [8].pFunct = &ScpiPacket::getResOspfPackets;
    resRxPacketLevel        [9].csKeyWord = "TCP?";        resRxPacketLevel  [9].pFunct = &ScpiPacket::getResTcpPackets;
    resRxPacketLevel       [10].csKeyWord = "UDP?";        resRxPacketLevel [10].pFunct = &ScpiPacket::getResUdpPackets;
    resRxPacketLevel       [11].csKeyWord = "BROAD?";      resRxPacketLevel [11].pFunct = &ScpiPacket::getRxbCast;
    resRxPacketLevel       [12].csKeyWord = "MULTI?";      resRxPacketLevel [12].pFunct = &ScpiPacket::getRxmCast;
    resRxPacketLevel       [13].csKeyWord = "UNI?";        resRxPacketLevel [13].pFunct = &ScpiPacket::getRxuCast;
    resRxPacketLevel       [14].csKeyWord = "BYT?";        resRxPacketLevel [14].pFunct = &ScpiPacket::getResRxBytes;
    resRxPacketLevel       [15].csKeyWord = "VLAN?";       resRxPacketLevel [15].pFunct = &ScpiPacket::getResVlanPackets1;
    resRxPacketLevel       [16].csKeyWord = "MPLS";        resRxPacketLevel [16].pFunct = &ScpiPacket::doResRxPacketMplsLevel;
    resRxPacketLevel       [17].csKeyWord = "PAUSE";       resRxPacketLevel [17].pFunct = &ScpiPacket::doResRxPacketPauseLevel;
    resRxPacketLevel       [18].csKeyWord = "SIZE";        resRxPacketLevel [18].pFunct = &ScpiPacket::doResRxPacketSizeLevel;
    resRxPacketLevel       [19].csKeyWord = "VLAN";        resRxPacketLevel [19].pFunct = &ScpiPacket::doResRxPacketVlanLevel;
    resRxPacketLevel       [20].csKeyWord = "SUPERBLOCK?"; resRxPacketLevel [20].pFunct = &ScpiPacket::getRxSuperBlock;
    resRxPacketLevel       [21].csKeyWord = "IDLE?";       resRxPacketLevel [21].pFunct = &ScpiPacket::getRxIdle;
    resRxPacketLevel       [22].csKeyWord = "L2BYT?";      resRxPacketLevel [22].pFunct = &ScpiPacket::getResRxBytes;
                                                           resRxPacketLevel [23].pFunct = NULL;

    // RES:RXPACKETS:MPLS PARSE TABLE
    resRxPacketMplsLevel    [0].csKeyWord = "TAG?";        resRxPacketMplsLevel [0].pFunct = &ScpiPacket::getResMplsPacketsByLevel;
    resRxPacketMplsLevel    [1].csKeyWord = "TC?";         resRxPacketMplsLevel [1].pFunct = &ScpiPacket::getResMplsTC;
                                                           resRxPacketMplsLevel [2].pFunct = NULL;

    // RES:RXPACKETS:PAUSE PARSE TABLE
    resRxPacketPauseLevel   [0].csKeyWord = "ENDPACKETS?"; resRxPacketPauseLevel [0].pFunct = &ScpiPacket::getResPauseEndPackets;
    resRxPacketPauseLevel   [1].csKeyWord = "PACKETS?";    resRxPacketPauseLevel [1].pFunct = &ScpiPacket::getResPausePackets;
    resRxPacketPauseLevel   [2].csKeyWord = "QUANT?";      resRxPacketPauseLevel [2].pFunct = &ScpiPacket::getResPauseQuantas;
                                                           resRxPacketPauseLevel [3].pFunct = NULL;

    // RES:RXPACKETS:SIZE PARSE TABLE
    resRxPacketSizeLevel    [0].csKeyWord = "1519?";       resRxPacketSizeLevel [0].pFunct = &ScpiPacket::getRx1519bp;
    resRxPacketSizeLevel    [1].csKeyWord = "1024?";       resRxPacketSizeLevel [1].pFunct = &ScpiPacket::getRx1024bp;
    resRxPacketSizeLevel    [2].csKeyWord = "512?";        resRxPacketSizeLevel [2].pFunct = &ScpiPacket::getRx512bp;
    resRxPacketSizeLevel    [3].csKeyWord = "256?";        resRxPacketSizeLevel [3].pFunct = &ScpiPacket::getRx256bp;
    resRxPacketSizeLevel    [4].csKeyWord = "128?";        resRxPacketSizeLevel [4].pFunct = &ScpiPacket::getRx128bp;
    resRxPacketSizeLevel    [5].csKeyWord = "65?";         resRxPacketSizeLevel [5].pFunct = &ScpiPacket::getRx65bp;
    resRxPacketSizeLevel    [6].csKeyWord = "64?";         resRxPacketSizeLevel [6].pFunct = &ScpiPacket::getRx64bp;
                                                           resRxPacketSizeLevel [7].pFunct = NULL;

    // RES:RXPACKETS:VLAN PARSE TABLE
    resRxPacketVlanLevel    [0].csKeyWord = "TAG?";        resRxPacketVlanLevel [0].pFunct = &ScpiPacket::getResVlanPackets;
    resRxPacketVlanLevel    [1].csKeyWord = "QOS?";        resRxPacketVlanLevel [1].pFunct = &ScpiPacket::getResVlanPacketsQos;
                                                           resRxPacketVlanLevel [2].pFunct = NULL;

    // RES:TXPACKETS PARSE TABLE
    resTxPacketLevel        [0].csKeyWord = "IPV6?";       resTxPacketLevel [0].pFunct = &ScpiPacket::getResTxIpv6Packets;
    resTxPacketLevel        [1].csKeyWord = "IPV4?";       resTxPacketLevel [1].pFunct = &ScpiPacket::getResTxIpPackets;
    resTxPacketLevel        [2].csKeyWord = "IP?";         resTxPacketLevel [2].pFunct = &ScpiPacket::getResTxIpPackets;
    resTxPacketLevel        [3].csKeyWord = "BYT?";        resTxPacketLevel [3].pFunct = &ScpiPacket::getResTxBytes;
    resTxPacketLevel        [4].csKeyWord = "PAUSE";       resTxPacketLevel [4].pFunct = &ScpiPacket::doResTxPacketPauseLevel;
    resTxPacketLevel        [5].csKeyWord = "SUPERBLOCK?"; resTxPacketLevel [5].pFunct = &ScpiPacket::getTxSuperBlock;
    resTxPacketLevel        [6].csKeyWord = "MPLS?";       resTxPacketLevel [6].pFunct = &ScpiPacket::getResTxMplsPackets;
    resTxPacketLevel        [7].csKeyWord = "VLAN?";       resTxPacketLevel [7].pFunct = &ScpiPacket::getResTxVlanPackets;
    resTxPacketLevel        [8].csKeyWord = "IDLE?";       resTxPacketLevel [8].pFunct = &ScpiPacket::getTxIdle;
    resTxPacketLevel        [9].csKeyWord = "L2BYT?";      resTxPacketLevel [9].pFunct = &ScpiPacket::getResTxBytes;
                                                           resTxPacketLevel[10].pFunct = NULL;

    // RES:TXPACKETS:PAUSE PARSE TABLE
    resTxPacketPauseLevel   [0].csKeyWord = "ENDPACKETS?"; resTxPacketPauseLevel [0].pFunct = &ScpiPacket::getResTxPauseEndPackets;
    resTxPacketPauseLevel   [1].csKeyWord = "PACKETS?";    resTxPacketPauseLevel [1].pFunct = &ScpiPacket::getResTxPausePackets;
    resTxPacketPauseLevel   [2].csKeyWord = "QUANT?";      resTxPacketPauseLevel [2].pFunct = &ScpiPacket::getResTxPauseQuantas;
                                                           resTxPacketPauseLevel [3].pFunct = NULL;

    // RES:VLAN PARSE TABLE - Legacy command support
    // Was Packets?
    resVlanLevel        [0].csKeyWord = "PACKETS1?";     resVlanLevel    [0].pFunct = &ScpiPacket::getResVlanPackets1;
    // Was QOS?
    resVlanLevel        [1].csKeyWord = "QOS1?";         resVlanLevel    [1].pFunct = &ScpiPacket::getResVlanPacketsQos1;
    resVlanLevel        [2].csKeyWord = "PACKETS2?";     resVlanLevel    [2].pFunct = &ScpiPacket::getResVlanPackets2;
    resVlanLevel        [3].csKeyWord = "QOS2?";         resVlanLevel    [3].pFunct = &ScpiPacket::getResVlanPacketsQos2;
    resVlanLevel        [4].csKeyWord = "PACKETS3?";     resVlanLevel    [4].pFunct = &ScpiPacket::getResVlanPackets3;
    resVlanLevel        [5].csKeyWord = "QOS3?";         resVlanLevel    [5].pFunct = &ScpiPacket::getResVlanPacketsQos3;
    resVlanLevel        [6].csKeyWord = "PACKETS4?";     resVlanLevel    [6].pFunct = &ScpiPacket::getResVlanPackets4;
    resVlanLevel        [7].csKeyWord = "QOS4?";         resVlanLevel    [7].pFunct = &ScpiPacket::getResVlanPacketsQos4;

    // RES:VLAN PARSE TABLE
    resVlanLevel        [8].csKeyWord = "PACKETS?";      resVlanLevel    [8].pFunct = &ScpiPacket::getResVlanPackets;
    resVlanLevel        [9].csKeyWord = "QOS?";          resVlanLevel    [9].pFunct = &ScpiPacket::getResVlanPacketsQos;
                                                         resVlanLevel    [10].pFunct = NULL;

    // RES:ALARM LED PARSE TABLE
    resAlarmLevel       [0].csKeyWord = "LOS?";             resAlarmLevel       [0].pFunct = &ScpiPacket::getResLosState;
    resAlarmLevel       [1].csKeyWord = "LFD?";             resAlarmLevel       [1].pFunct = &ScpiPacket::getResLfdState;
    resAlarmLevel       [2].csKeyWord = "LOC?";             resAlarmLevel       [2].pFunct = &ScpiPacket::getResLocState;
    resAlarmLevel       [3].csKeyWord = "LOCCS?";           resAlarmLevel       [3].pFunct = &ScpiPacket::getResLoccsState;
    resAlarmLevel       [4].csKeyWord = "CPP?";             resAlarmLevel       [4].pFunct = &ScpiPacket::getResCpPowerLossState;
    resAlarmLevel       [5].csKeyWord = "LINK?";            resAlarmLevel       [5].pFunct = &ScpiPacket::getResLinkState;
    resAlarmLevel       [6].csKeyWord = "HDRMM?";           resAlarmLevel       [6].pFunct = &ScpiPacket::getResHdrMMState;
    resAlarmLevel       [7].csKeyWord = "MODULESTATUS?";    resAlarmLevel       [7].pFunct = &ScpiPacket::getResSummaryModuleState;
    resAlarmLevel       [8].csKeyWord = "PAUSED?";          resAlarmLevel       [8].pFunct = &ScpiPacket::getResAlarmPausedState;
                                                            resAlarmLevel       [9].pFunct = NULL;

    // RES:CAPTURE PARSE TABLE
    resCaptureLevel     [0].csKeyWord = "PLI?";             resCaptureLevel       [0].pFunct = &ScpiPacket::getCapturePli;
    resCaptureLevel     [1].csKeyWord = "PTI?";             resCaptureLevel       [1].pFunct = &ScpiPacket::getCapturePti;
    resCaptureLevel     [2].csKeyWord = "PFI?";             resCaptureLevel       [2].pFunct = &ScpiPacket::getCapturePfi;
    resCaptureLevel     [3].csKeyWord = "EXI?";             resCaptureLevel       [3].pFunct = &ScpiPacket::getCaptureExi;
    resCaptureLevel     [4].csKeyWord = "UPI?";             resCaptureLevel       [4].pFunct = &ScpiPacket::getCaptureUpi;
    resCaptureLevel     [5].csKeyWord = "SPARE?";           resCaptureLevel       [5].pFunct = &ScpiPacket::getCaptureSpare;
    resCaptureLevel     [6].csKeyWord = "CID?";             resCaptureLevel       [6].pFunct = &ScpiPacket::getCaptureCid;
    resCaptureLevel     [7].csKeyWord = "SELECT";           resCaptureLevel       [7].pFunct = &ScpiPacket::setRxCidFilter;
    resCaptureLevel     [8].csKeyWord = "SELECT?";          resCaptureLevel       [8].pFunct = &ScpiPacket::getRxCidFilter;
                                                            resCaptureLevel       [9].pFunct = NULL;

    // RES:MPLS PARSE TABLE
    resMplsLevel         [0].csKeyWord = "TC?";             resMplsLevel         [0].pFunct = &ScpiPacket::getResMplsTC;
    resMplsLevel         [1].csKeyWord = "PACKETS?";        resMplsLevel         [1].pFunct = &ScpiPacket::getResMplsPacketsByLevel;
                                                            resMplsLevel         [2].pFunct = NULL;

    // STREAM PARSE TABLE
    strmLevel         [0].csKeyWord = "SYNC";           strmLevel     [0].pFunct = &ScpiPacket::doStreamSyncLevel;
    strmLevel         [1].csKeyWord = "TXPACKETS?";     strmLevel     [1].pFunct = &ScpiPacket::getTxStreamPackets;
    strmLevel         [2].csKeyWord = "RXPACKETS?";     strmLevel     [2].pFunct = &ScpiPacket::getRxStreamPackets;
    strmLevel         [3].csKeyWord = "TXBYTES?";       strmLevel     [3].pFunct = &ScpiPacket::getTxStreamBytes;
    strmLevel         [4].csKeyWord = "RXBYTES?";       strmLevel     [4].pFunct = &ScpiPacket::getRxStreamBytes;
    strmLevel         [5].csKeyWord = "SEQ";            strmLevel     [5].pFunct = &ScpiPacket::doStreamSeqLevel;
    strmLevel         [6].csKeyWord = "BIT";            strmLevel     [6].pFunct = &ScpiPacket::doStreamBitLevel;
    strmLevel         [7].csKeyWord = "PATTERN";        strmLevel     [7].pFunct = &ScpiPacket::setPattern;
    strmLevel         [8].csKeyWord = "PATTERN?";       strmLevel     [8].pFunct = &ScpiPacket::getPattern;
    strmLevel         [9].csKeyWord = "MACSOURCE";      strmLevel     [9].pFunct = &ScpiPacket::setMacsource;
    strmLevel        [10].csKeyWord = "MACSOURCE?";     strmLevel    [10].pFunct = &ScpiPacket::getMacsource;
    strmLevel        [11].csKeyWord = "MACDEST";        strmLevel    [11].pFunct = &ScpiPacket::setMacdest;
    strmLevel        [12].csKeyWord = "MACDEST?";       strmLevel    [12].pFunct = &ScpiPacket::getMacdest;
    strmLevel        [13].csKeyWord = "IPSOURCE";       strmLevel    [13].pFunct = &ScpiPacket::setIpsource;
    strmLevel        [14].csKeyWord = "IPSOURCE?";      strmLevel    [14].pFunct = &ScpiPacket::getIpsource;
    strmLevel        [15].csKeyWord = "IPDEST";         strmLevel    [15].pFunct = &ScpiPacket::setIpdest;
    strmLevel        [16].csKeyWord = "IPDEST?";        strmLevel    [16].pFunct = &ScpiPacket::getIpdest;
    strmLevel        [17].csKeyWord = "PORTSOURCE";     strmLevel    [17].pFunct = &ScpiPacket::setPortsource;
    strmLevel        [18].csKeyWord = "PORTSOURCE?";    strmLevel    [18].pFunct = &ScpiPacket::getPortsource;
    strmLevel        [19].csKeyWord = "PORTDEST";       strmLevel    [19].pFunct = &ScpiPacket::setPortdest;
    strmLevel        [20].csKeyWord = "PORTDEST?";      strmLevel    [20].pFunct = &ScpiPacket::getPortdest;
    strmLevel        [21].csKeyWord = "FRAMESIZE";      strmLevel    [21].pFunct = &ScpiPacket::setFramesize;
    strmLevel        [22].csKeyWord = "FRAMESIZE?";     strmLevel    [22].pFunct = &ScpiPacket::getFramesize;
    strmLevel        [23].csKeyWord = "BW";             strmLevel    [23].pFunct = &ScpiPacket::setBandwidth;
    strmLevel        [24].csKeyWord = "BW?";            strmLevel    [24].pFunct = &ScpiPacket::getBandwidth;
    strmLevel        [25].csKeyWord = "BURSTSIZE";      strmLevel    [25].pFunct = &ScpiPacket::setBurst;
    strmLevel        [26].csKeyWord = "BURSTSIZE?";     strmLevel    [26].pFunct = &ScpiPacket::getBurst;
    strmLevel        [27].csKeyWord = "VLANTAG";        strmLevel    [27].pFunct = &ScpiPacket::setVlanTag;
    strmLevel        [28].csKeyWord = "VLANTAG?";       strmLevel    [28].pFunct = &ScpiPacket::getVlanTag;
    strmLevel        [29].csKeyWord = "TAG";            strmLevel    [29].pFunct = &ScpiPacket::doTagLevel;
    strmLevel        [30].csKeyWord = "TXENABLE";       strmLevel    [30].pFunct = &ScpiPacket::setTxEnable;
    strmLevel        [31].csKeyWord = "TXENABLE?";      strmLevel    [31].pFunct = &ScpiPacket::getTxEnable;
    strmLevel        [32].csKeyWord = "SET?";           strmLevel    [32].pFunct = &ScpiPacket::getStrmSet;
    strmLevel        [33].csKeyWord = "LAT";            strmLevel    [33].pFunct = &ScpiPacket::doStreamLatLevel;
    strmLevel        [34].csKeyWord = "IPTOS";          strmLevel    [34].pFunct = &ScpiPacket::setIpTos;
    strmLevel        [35].csKeyWord = "IPTOS?";         strmLevel    [35].pFunct = &ScpiPacket::getIpTos;
    strmLevel        [36].csKeyWord = "IPTTL";          strmLevel    [36].pFunct = &ScpiPacket::setIpTtl;
    strmLevel        [37].csKeyWord = "IPTTL?";         strmLevel    [37].pFunct = &ScpiPacket::getIpTtl;
    strmLevel        [38].csKeyWord = "IPFRAG";         strmLevel    [38].pFunct = &ScpiPacket::setIpFrag;
    strmLevel        [39].csKeyWord = "IPFRAG?";        strmLevel    [39].pFunct = &ScpiPacket::getIpFrag;
    strmLevel        [40].csKeyWord = "FC";             strmLevel    [40].pFunct = &ScpiPacket::doStreamFcLevel;
    strmLevel        [41].csKeyWord = "ARP";            strmLevel    [41].pFunct = &ScpiPacket::setArpEnable;
    strmLevel        [42].csKeyWord = "ARP?";           strmLevel    [42].pFunct = &ScpiPacket::getArpEnable;
    strmLevel        [43].csKeyWord = "IPGB";           strmLevel    [43].pFunct = &ScpiPacket::setIpcgC;
    strmLevel        [44].csKeyWord = "IPGB?";          strmLevel    [44].pFunct = &ScpiPacket::getIpcgC;
    strmLevel        [45].csKeyWord = "IPGM";           strmLevel    [45].pFunct = &ScpiPacket::setIpcgM;
    strmLevel        [46].csKeyWord = "IPGM?";          strmLevel    [46].pFunct = &ScpiPacket::getIpcgM;
    strmLevel        [47].csKeyWord = "RAMP";           strmLevel    [47].pFunct = &ScpiPacket::doStreamRampLevel;
    strmLevel        [48].csKeyWord = "MBPS";           strmLevel    [48].pFunct = &ScpiPacket::setMbps;
    strmLevel        [49].csKeyWord = "MBPS?";          strmLevel    [49].pFunct = &ScpiPacket::getMbps;
    strmLevel        [50].csKeyWord = "BURST";          strmLevel    [50].pFunct = &ScpiPacket::sendBurst;
    strmLevel        [51].csKeyWord = "RXBW?";          strmLevel    [51].pFunct = &ScpiPacket::getRxStreamBw;
    strmLevel        [52].csKeyWord = "TXBW?";          strmLevel    [52].pFunct = &ScpiPacket::getTxStreamBw;
    strmLevel        [53].csKeyWord = "ETYPE";          strmLevel    [53].pFunct = &ScpiPacket::setEtherType;
    strmLevel        [54].csKeyWord = "ETYPE?";         strmLevel    [54].pFunct = &ScpiPacket::getEtherType;


    // STREAM PARSE TABLE - VLAN Legacy command support
    strmLevel        [55].csKeyWord = "VLANTPID1";      strmLevel    [55].pFunct = &ScpiPacket::setVlanTpid1;
    strmLevel        [56].csKeyWord = "VLANTPID2";      strmLevel    [56].pFunct = &ScpiPacket::setVlanTpid2;
    strmLevel        [57].csKeyWord = "VLANTPID3";      strmLevel    [57].pFunct = &ScpiPacket::setVlanTpid3;
    strmLevel        [58].csKeyWord = "VLANTPID4";      strmLevel    [58].pFunct = &ScpiPacket::setVlanTpid4;
    strmLevel        [59].csKeyWord = "VLANTPID1?";     strmLevel    [59].pFunct = &ScpiPacket::getVlanTpid1;
    strmLevel        [60].csKeyWord = "VLANTPID2?";     strmLevel    [60].pFunct = &ScpiPacket::getVlanTpid2;
    strmLevel        [61].csKeyWord = "VLANTPID3?";     strmLevel    [61].pFunct = &ScpiPacket::getVlanTpid3;
    strmLevel        [62].csKeyWord = "VLANTPID4?";     strmLevel    [62].pFunct = &ScpiPacket::getVlanTpid4;
    strmLevel        [63].csKeyWord = "VLANCFI1";       strmLevel    [63].pFunct = &ScpiPacket::setVlanCfi1;
    strmLevel        [64].csKeyWord = "VLANCFI2";       strmLevel    [64].pFunct = &ScpiPacket::setVlanCfi2;
    strmLevel        [65].csKeyWord = "VLANCFI3";       strmLevel    [65].pFunct = &ScpiPacket::setVlanCfi3;
    strmLevel        [66].csKeyWord = "VLANCFI4";       strmLevel    [66].pFunct = &ScpiPacket::setVlanCfi4;
    strmLevel        [67].csKeyWord = "VLANCFI1?";      strmLevel    [67].pFunct = &ScpiPacket::getVlanCfi1;
    strmLevel        [68].csKeyWord = "VLANCFI2?";      strmLevel    [68].pFunct = &ScpiPacket::getVlanCfi2;
    strmLevel        [69].csKeyWord = "VLANCFI3?";      strmLevel    [69].pFunct = &ScpiPacket::getVlanCfi3;
    strmLevel        [70].csKeyWord = "VLANCFI4?";      strmLevel    [70].pFunct = &ScpiPacket::getVlanCfi4;

    strmLevel        [71].csKeyWord = "VLANID4";        strmLevel    [71].pFunct = &ScpiPacket::setVlanId4;
    strmLevel        [72].csKeyWord = "VLANID4?";       strmLevel    [72].pFunct = &ScpiPacket::getVlanId4;
    strmLevel        [73].csKeyWord = "VLANQOS4";       strmLevel    [73].pFunct = &ScpiPacket::setVlanQos4;
    strmLevel        [74].csKeyWord = "VLANQOS4?";      strmLevel    [74].pFunct = &ScpiPacket::getVlanQos4;
    strmLevel        [75].csKeyWord = "VLANID3";        strmLevel    [75].pFunct = &ScpiPacket::setVlanId3;
    strmLevel        [76].csKeyWord = "VLANID3?";       strmLevel    [76].pFunct = &ScpiPacket::getVlanId3;
    strmLevel        [77].csKeyWord = "VLANQOS3";       strmLevel    [77].pFunct = &ScpiPacket::setVlanQos3;
    strmLevel        [78].csKeyWord = "VLANQOS3?";      strmLevel    [78].pFunct = &ScpiPacket::getVlanQos3;
    strmLevel        [79].csKeyWord = "VLANID2";        strmLevel    [79].pFunct = &ScpiPacket::setVlanId2;
    strmLevel        [80].csKeyWord = "VLANID2?";       strmLevel    [80].pFunct = &ScpiPacket::getVlanId2;
    strmLevel        [81].csKeyWord = "VLANQOS2";       strmLevel    [81].pFunct = &ScpiPacket::setVlanQos2;
    strmLevel        [82].csKeyWord = "VLANQOS2?";      strmLevel    [82].pFunct = &ScpiPacket::getVlanQos2;
    strmLevel        [83].csKeyWord = "VLANID1";        strmLevel    [83].pFunct = &ScpiPacket::setVlanId1;
    strmLevel        [84].csKeyWord = "VLANID1?";       strmLevel    [84].pFunct = &ScpiPacket::getVlanId1;
    strmLevel        [85].csKeyWord = "VLANQOS1";       strmLevel    [85].pFunct = &ScpiPacket::setVlanQos1;
    strmLevel        [86].csKeyWord = "VLANQOS1?";      strmLevel    [86].pFunct = &ScpiPacket::getVlanQos1;
    strmLevel        [87].csKeyWord = "IPV6";           strmLevel    [87].pFunct = &ScpiPacket::doStreamIpv6Level;
    strmLevel        [88].csKeyWord = "IPMODE";         strmLevel    [88].pFunct = &ScpiPacket::setIpMode;
    strmLevel        [89].csKeyWord = "IPMODE?";        strmLevel    [89].pFunct = &ScpiPacket::getIpMode;
    strmLevel        [90].csKeyWord = "RXLOSS?";        strmLevel    [90].pFunct = &ScpiPacket::getRxStreamLoss;
    strmLevel        [91].csKeyWord = "LOSS";           strmLevel    [91].pFunct = &ScpiPacket::doStreamLossLevel;
    strmLevel        [92].csKeyWord = "JIT";            strmLevel    [92].pFunct = &ScpiPacket::doStreamJitLevel;
    strmLevel        [93].csKeyWord = "VLANDEI1";       strmLevel    [93].pFunct = &ScpiPacket::setVlanCfi1;
    strmLevel        [94].csKeyWord = "VLANDEI2";       strmLevel    [94].pFunct = &ScpiPacket::setVlanCfi2;
    strmLevel        [95].csKeyWord = "VLANDEI3";       strmLevel    [95].pFunct = &ScpiPacket::setVlanCfi3;
    strmLevel        [96].csKeyWord = "VLANDEI4";       strmLevel    [96].pFunct = &ScpiPacket::setVlanCfi4;
    strmLevel        [97].csKeyWord = "VLANDEI1?";      strmLevel    [97].pFunct = &ScpiPacket::getVlanCfi1;
    strmLevel        [98].csKeyWord = "VLANDEI2?";      strmLevel    [98].pFunct = &ScpiPacket::getVlanCfi2;
    strmLevel        [99].csKeyWord = "VLANDEI3?";      strmLevel    [99].pFunct = &ScpiPacket::getVlanCfi3;
    strmLevel       [100].csKeyWord = "VLANDEI4?";      strmLevel   [100].pFunct = &ScpiPacket::getVlanCfi4;
    strmLevel       [101].csKeyWord = "TRAFFICLAYER";   strmLevel   [101].pFunct = &ScpiPacket::setTrafficLayer;
    strmLevel       [102].csKeyWord = "TRAFFICLAYER?";  strmLevel   [102].pFunct = &ScpiPacket::getTrafficLayer;
    strmLevel       [103].csKeyWord = "PROTOCOL";       strmLevel   [103].pFunct = &ScpiPacket::setProtocol;
    strmLevel       [104].csKeyWord = "PROTOCOL?";      strmLevel   [104].pFunct = &ScpiPacket::getProtocol;
    strmLevel       [105].csKeyWord = "DURATION";       strmLevel   [105].pFunct = &ScpiPacket::setTrafficDuration;
    strmLevel       [106].csKeyWord = "DURATION?";      strmLevel   [106].pFunct = &ScpiPacket::getTrafficDuration;
    strmLevel       [107].csKeyWord = "L1";             strmLevel   [107].pFunct = &ScpiPacket::doStreamL1Level;
    strmLevel       [108].csKeyWord = "L2";             strmLevel   [108].pFunct = &ScpiPacket::doStreamL2Level;
    strmLevel       [109].csKeyWord = "CUR";            strmLevel   [109].pFunct = &ScpiPacket::doStreamCurLevel;
    strmLevel       [110].csKeyWord = "AVG";            strmLevel   [110].pFunct = &ScpiPacket::doStreamAvgLevel;
    strmLevel       [111].csKeyWord = "MAX";            strmLevel   [111].pFunct = &ScpiPacket::doStreamMaxLevel;
    strmLevel       [112].csKeyWord = "MIN";            strmLevel   [112].pFunct = &ScpiPacket::doStreamMinLevel;
                                                        strmLevel   [113].pFunct = NULL;

    streamRampLevel   [0].csKeyWord   = "CEILMBPS";      streamRampLevel    [0].pFunct  = &ScpiPacket::setRampMbps;
    streamRampLevel   [1].csKeyWord   = "CEILMBPS?";     streamRampLevel    [1].pFunct  = &ScpiPacket::getRampMbps;
    streamRampLevel   [2].csKeyWord   = "FLOORMBPS";     streamRampLevel    [2].pFunct  = &ScpiPacket::setRampStop;
    streamRampLevel   [3].csKeyWord   = "FLOORMBPS?";    streamRampLevel    [3].pFunct  = &ScpiPacket::getRampStop;
    streamRampLevel   [4].csKeyWord   = "STEPMBPS";      streamRampLevel    [4].pFunct  = &ScpiPacket::setRampStep;
    streamRampLevel   [5].csKeyWord   = "STEPMBPS?";     streamRampLevel    [5].pFunct  = &ScpiPacket::getRampStep;
    streamRampLevel   [6].csKeyWord   = "DUR";           streamRampLevel    [6].pFunct  = &ScpiPacket::setRampDur;
    streamRampLevel   [7].csKeyWord   = "DUR?";          streamRampLevel    [7].pFunct  = &ScpiPacket::getRampDur;
    streamRampLevel   [8].csKeyWord   = "UOM";           streamRampLevel    [8].pFunct  = &ScpiPacket::setRampUom;
    streamRampLevel   [9].csKeyWord   = "UOM?";          streamRampLevel    [9].pFunct  = &ScpiPacket::getRampUom;
    streamRampLevel   [10].csKeyWord  = "CEILBW";       streamRampLevel    [10].pFunct  = &ScpiPacket::setRampBw;
    streamRampLevel   [11].csKeyWord  = "CEILBW?";      streamRampLevel    [11].pFunct  = &ScpiPacket::getRampBw;
    streamRampLevel   [12].csKeyWord  = "FLOORBW";      streamRampLevel    [12].pFunct  = &ScpiPacket::setRampStop;
    streamRampLevel   [13].csKeyWord  = "FLOORBW?";     streamRampLevel    [13].pFunct  = &ScpiPacket::getRampStop;
    streamRampLevel   [14].csKeyWord  = "STEPBW";       streamRampLevel    [14].pFunct  = &ScpiPacket::setRampStep;
    streamRampLevel   [15].csKeyWord  = "STEPBW?";      streamRampLevel    [15].pFunct  = &ScpiPacket::getRampStep;
    streamRampLevel   [16].csKeyWord  = "FLOOR";        streamRampLevel    [16].pFunct  = &ScpiPacket::setRampStop;
    streamRampLevel   [17].csKeyWord  = "FLOOR?";       streamRampLevel    [17].pFunct  = &ScpiPacket::getRampStop;
    streamRampLevel   [18].csKeyWord  = "STEP";         streamRampLevel    [18].pFunct  = &ScpiPacket::setRampStep;
    streamRampLevel   [19].csKeyWord  = "STEP?";        streamRampLevel    [19].pFunct  = &ScpiPacket::getRampStep;
                                                        streamRampLevel    [20].pFunct  = NULL;

    streamIpv6Level   [0].csKeyWord   = "TRAFCLASS";      streamIpv6Level    [0].pFunct  = &ScpiPacket::setIpv6TrafClass;
    streamIpv6Level   [1].csKeyWord   = "TRAFCLASS?";     streamIpv6Level    [1].pFunct  = &ScpiPacket::getIpv6TrafClass;
    streamIpv6Level   [2].csKeyWord   = "HOPLIMIT";        streamIpv6Level    [2].pFunct  = &ScpiPacket::setIpv6NextHop;
    streamIpv6Level   [3].csKeyWord   = "HOPLIMIT?";       streamIpv6Level    [3].pFunct  = &ScpiPacket::getIpv6NextHop;
    streamIpv6Level   [4].csKeyWord   = "FLOWLABEL";      streamIpv6Level    [4].pFunct  = &ScpiPacket::setIpv6FlowControl;
    streamIpv6Level   [5].csKeyWord   = "FLOWLABEL?";     streamIpv6Level    [5].pFunct  = &ScpiPacket::getIpv6FlowControl;
    streamIpv6Level   [6].csKeyWord   = "IPSOURCE";       streamIpv6Level    [6].pFunct  = &ScpiPacket::setIpv6IpSourceAddress;
    streamIpv6Level   [7].csKeyWord   = "IPSOURCE?";      streamIpv6Level    [7].pFunct  = &ScpiPacket::getIpv6IpSourceAddress;
    streamIpv6Level   [8].csKeyWord   = "IPDEST";         streamIpv6Level    [8].pFunct  = &ScpiPacket::setIpv6IpDestAddress;
    streamIpv6Level   [9].csKeyWord   = "IPDEST?";        streamIpv6Level    [9].pFunct  = &ScpiPacket::getIpv6IpDestAddress;
                                                          streamIpv6Level   [10].pFunct  = NULL;

    // Fibre chan stream PARSE TABLE
    streamFcLevel   [0].csKeyWord  = "SOF";            streamFcLevel    [0].pFunct  = &ScpiPacket::setSof;
    streamFcLevel   [1].csKeyWord  = "SOF?";           streamFcLevel    [1].pFunct  = &ScpiPacket::getSof;
    streamFcLevel   [2].csKeyWord  = "EOF";            streamFcLevel    [2].pFunct  = &ScpiPacket::setEof;
    streamFcLevel   [3].csKeyWord  = "EOF?";           streamFcLevel    [3].pFunct  = &ScpiPacket::getEof;
    streamFcLevel   [4].csKeyWord  = "RCTL";           streamFcLevel    [4].pFunct  = &ScpiPacket::setRctl;
    streamFcLevel   [5].csKeyWord  = "RCTL?";          streamFcLevel    [5].pFunct  = &ScpiPacket::getRctl;
    streamFcLevel   [6].csKeyWord  = "DID";            streamFcLevel    [6].pFunct  = &ScpiPacket::setDid;
    streamFcLevel   [7].csKeyWord  = "DID?";           streamFcLevel    [7].pFunct  = &ScpiPacket::getDid;
    streamFcLevel   [8].csKeyWord  = "CSCTL";          streamFcLevel    [8].pFunct  = &ScpiPacket::setCsctl;
    streamFcLevel   [9].csKeyWord  = "CSCTL?";         streamFcLevel    [9].pFunct  = &ScpiPacket::getCsctl;
    streamFcLevel   [10].csKeyWord = "SID";            streamFcLevel    [10].pFunct = &ScpiPacket::setSid;
    streamFcLevel   [11].csKeyWord = "SID?";           streamFcLevel    [11].pFunct = &ScpiPacket::getSid;
    streamFcLevel   [12].csKeyWord = "TYPE";           streamFcLevel    [12].pFunct = &ScpiPacket::setType;
    streamFcLevel   [13].csKeyWord = "TYPE?";          streamFcLevel    [13].pFunct = &ScpiPacket::getType;
    streamFcLevel   [14].csKeyWord = "DFCTL";          streamFcLevel    [14].pFunct = &ScpiPacket::setDfctl;
    streamFcLevel   [15].csKeyWord = "DFCTL?";         streamFcLevel    [15].pFunct = &ScpiPacket::getDfctl;
    streamFcLevel   [16].csKeyWord = "SEQID";          streamFcLevel    [16].pFunct = &ScpiPacket::setSeqid;
    streamFcLevel   [17].csKeyWord = "SEQID?";         streamFcLevel    [17].pFunct = &ScpiPacket::getSeqid;
    streamFcLevel   [18].csKeyWord = "FCTL";           streamFcLevel    [18].pFunct = &ScpiPacket::setFctl;
    streamFcLevel   [19].csKeyWord = "FCTL?";          streamFcLevel    [19].pFunct = &ScpiPacket::getFctl;
    streamFcLevel   [20].csKeyWord = "OXID";           streamFcLevel    [20].pFunct = &ScpiPacket::setOxid;
    streamFcLevel   [21].csKeyWord = "OXID?";          streamFcLevel    [21].pFunct = &ScpiPacket::getOxid;
    streamFcLevel   [22].csKeyWord = "RXID";           streamFcLevel    [22].pFunct = &ScpiPacket::setRxid;
    streamFcLevel   [23].csKeyWord = "RXID?";          streamFcLevel    [23].pFunct = &ScpiPacket::getRxid;
    streamFcLevel   [24].csKeyWord = "PARM";           streamFcLevel    [24].pFunct = &ScpiPacket::setParm;
    streamFcLevel   [25].csKeyWord = "PARM?";          streamFcLevel    [25].pFunct = &ScpiPacket::getParm;
    streamFcLevel   [26].csKeyWord = "CLASS";          streamFcLevel    [26].pFunct = &ScpiPacket::setClass;
    streamFcLevel   [27].csKeyWord = "CLASS?";         streamFcLevel    [27].pFunct = &ScpiPacket::getClass;
    streamFcLevel   [28].csKeyWord = "WWNSOURCE";      streamFcLevel    [28].pFunct = &ScpiPacket::setFcMacsource;
    streamFcLevel   [29].csKeyWord = "WWNSOURCE?";     streamFcLevel    [29].pFunct = &ScpiPacket::getFcMacsource;
    streamFcLevel   [30].csKeyWord = "WWNDEST";        streamFcLevel    [30].pFunct = &ScpiPacket::setFcMacdest;
    streamFcLevel   [31].csKeyWord = "WWNDEST?";       streamFcLevel    [31].pFunct = &ScpiPacket::getFcMacdest;
    streamFcLevel   [32].csKeyWord = "B2BCREDIT";      streamFcLevel    [32].pFunct = &ScpiPacket::setB2BCredit;
    streamFcLevel   [33].csKeyWord = "B2BCREDIT?";     streamFcLevel    [33].pFunct = &ScpiPacket::getB2BCredit;
                                                       streamFcLevel    [34].pFunct = NULL;

    // SYNC PARSE TABLE
    streamSyncLevel  [0].csKeyWord = "SECS?";           streamSyncLevel    [0].pFunct = &ScpiPacket::getStreamSyncSecs;
    streamSyncLevel  [1].csKeyWord = "STATE?";          streamSyncLevel    [1].pFunct = &ScpiPacket::getStreamSyncState;
                                                        streamSyncLevel    [2].pFunct = NULL;

    // LOSS PARSE TABLE
    streamLossLevel  [0].csKeyWord = "COUNT?";          streamLossLevel   [0].pFunct = &ScpiPacket::getStreamLossCount;
    streamLossLevel  [1].csKeyWord = "ES?";             streamLossLevel   [1].pFunct = &ScpiPacket::getStreamLossES;
    streamLossLevel  [2].csKeyWord = "AVGRATE?";        streamLossLevel   [2].pFunct = &ScpiPacket::getStreamLossAvgRate;
    streamLossLevel  [3].csKeyWord = "CURRATE?";        streamLossLevel   [3].pFunct = &ScpiPacket::getStreamLossCurRate;
    streamLossLevel  [4].csKeyWord = "COUNTPS?";         streamLossLevel   [4].pFunct = &ScpiPacket::getStreamLossPerSec;
                                                        streamLossLevel   [5].pFunct = NULL;

    // SEQ PARSE TABLE
    streamSeqLevel   [0].csKeyWord = "COUNT?";          streamSeqLevel    [0].pFunct = &ScpiPacket::getStreamSeqCount;
    streamSeqLevel   [1].csKeyWord = "ES?";             streamSeqLevel    [1].pFunct = &ScpiPacket::getStreamSeqES;
    streamSeqLevel   [2].csKeyWord = "AVGRATE?";        streamSeqLevel    [2].pFunct = &ScpiPacket::getStreamSeqAvgRate;
    streamSeqLevel   [3].csKeyWord = "CURRATE?";        streamSeqLevel    [3].pFunct = &ScpiPacket::getStreamSeqCurRate;
                                                        streamSeqLevel    [4].pFunct = NULL;

    // BIT PARSE TABLE
    streamBitLevel   [0].csKeyWord = "COUNT?";          streamBitLevel    [0].pFunct = &ScpiPacket::getStreamBitCount;
    streamBitLevel   [1].csKeyWord = "ES?";             streamBitLevel    [1].pFunct = &ScpiPacket::getStreamBitES;
    streamBitLevel   [2].csKeyWord = "AVGRATE?";        streamBitLevel    [2].pFunct = &ScpiPacket::getStreamBitAvgRate;
    streamBitLevel   [3].csKeyWord = "CURRATE?";        streamBitLevel    [3].pFunct = &ScpiPacket::getStreamBitCurRate;
                                                        streamBitLevel    [4].pFunct = NULL;
    // LAT PARSE TABLE
    streamLatLevel   [0].csKeyWord = "MIN?";            streamLatLevel    [0].pFunct = &ScpiPacket::getStreamLatMin;
    streamLatLevel   [1].csKeyWord = "MAX?";            streamLatLevel    [1].pFunct = &ScpiPacket::getStreamLatMax;
    streamLatLevel   [2].csKeyWord = "AVG?";            streamLatLevel    [2].pFunct = &ScpiPacket::getStreamLatAvg;
    streamLatLevel   [3].csKeyWord = "CUR?";            streamLatLevel    [3].pFunct = &ScpiPacket::getStreamLatCur;
                                                        streamLatLevel    [4].pFunct = NULL;

    // JIT PARSE TABLE
    streamJitLevel   [0].csKeyWord = "MIN?";            streamJitLevel    [0].pFunct = &ScpiPacket::getStreamJitMin;
    streamJitLevel   [1].csKeyWord = "MAX?";            streamJitLevel    [1].pFunct = &ScpiPacket::getStreamJitMax;
    streamJitLevel   [2].csKeyWord = "AVG?";            streamJitLevel    [2].pFunct = &ScpiPacket::getStreamJitAvg;
                                                        streamJitLevel    [3].pFunct = NULL;
    // STRM:TAG Level
    streamTagLevel   [0].csKeyWord = "MODE?";           streamTagLevel     [0].pFunct = &ScpiPacket::getTagMode;
    streamTagLevel   [1].csKeyWord = "MODE";            streamTagLevel     [1].pFunct = &ScpiPacket::setTagMode;
    streamTagLevel   [2].csKeyWord = "LEVEL?";          streamTagLevel     [2].pFunct = &ScpiPacket::getTagLevel;
    streamTagLevel   [3].csKeyWord = "LEVEL";           streamTagLevel     [3].pFunct = &ScpiPacket::setTagLevel;
    streamTagLevel   [4].csKeyWord = "MPLS";            streamTagLevel     [4].pFunct = &ScpiPacket::doTagMpls;
    streamTagLevel   [5].csKeyWord = "VLAN";            streamTagLevel     [5].pFunct = &ScpiPacket::doTagVlan;
    streamTagLevel   [6].csKeyWord = "CUSTOM";          streamTagLevel     [6].pFunct = &ScpiPacket::doTagCustom;
                                                        streamTagLevel     [7].pFunct = NULL;

    // STRM:TAG:MPLS
    streamMplsLevel  [0].csKeyWord = "LABEL?";          streamMplsLevel    [0].pFunct = &ScpiPacket::getMplsLabel;
    streamMplsLevel  [1].csKeyWord = "LABEL";           streamMplsLevel    [1].pFunct = &ScpiPacket::setMplsLabel;
    streamMplsLevel  [2].csKeyWord = "TC?";             streamMplsLevel    [2].pFunct = &ScpiPacket::getMplsTC;
    streamMplsLevel  [3].csKeyWord = "TC";              streamMplsLevel    [3].pFunct = &ScpiPacket::setMplsTC;
    streamMplsLevel  [4].csKeyWord = "S?";              streamMplsLevel    [4].pFunct = &ScpiPacket::getMplsBos;
    streamMplsLevel  [5].csKeyWord = "S";               streamMplsLevel    [5].pFunct = &ScpiPacket::setMplsBos;
    streamMplsLevel  [6].csKeyWord = "TTL?";            streamMplsLevel    [6].pFunct = &ScpiPacket::getMplsTtl;
    streamMplsLevel  [7].csKeyWord = "TTL";             streamMplsLevel    [7].pFunct = &ScpiPacket::setMplsTtl;
                                                        streamMplsLevel    [8].pFunct = NULL;

    // STRM:TAG:VLAN
    streamVlanLevel  [0].csKeyWord = "CFI?";            streamVlanLevel[0].pFunct = &ScpiPacket::getVlanCfi;
    streamVlanLevel  [1].csKeyWord = "CFI";             streamVlanLevel[1].pFunct = &ScpiPacket::setVlanCfi;
    streamVlanLevel  [2].csKeyWord = "QOS?";            streamVlanLevel[2].pFunct = &ScpiPacket::getVlanQos;
    streamVlanLevel  [3].csKeyWord = "QOS";             streamVlanLevel[3].pFunct = &ScpiPacket::setVlanQos;
    streamVlanLevel  [4].csKeyWord = "TPID?";           streamVlanLevel[4].pFunct = &ScpiPacket::getVlanTpid;
    streamVlanLevel  [5].csKeyWord = "TPID";            streamVlanLevel[5].pFunct = &ScpiPacket::setVlanTpid;
    streamVlanLevel  [6].csKeyWord = "ID?";             streamVlanLevel[6].pFunct = &ScpiPacket::getVlanId;
    streamVlanLevel  [7].csKeyWord = "ID";              streamVlanLevel[7].pFunct = &ScpiPacket::setVlanId;
    streamVlanLevel  [8].csKeyWord = "DEI?";            streamVlanLevel[8].pFunct = &ScpiPacket::getVlanCfi;
    streamVlanLevel  [9].csKeyWord = "DEI";             streamVlanLevel[9].pFunct = &ScpiPacket::setVlanCfi;
                                                        streamVlanLevel[10].pFunct = NULL;
    // STRM:TAG:CUSTOM
    streamCustomLevel  [0].csKeyWord = "LEVEL?";      streamCustomLevel   [0].pFunct = &ScpiPacket::getCustomTagLevel;
    streamCustomLevel  [1].csKeyWord = "LEVEL";       streamCustomLevel   [1].pFunct = &ScpiPacket::setCustomTagLevel;
    streamCustomLevel  [2].csKeyWord = "DATA?";       streamCustomLevel   [2].pFunct = &ScpiPacket::getCustomTag;
    streamCustomLevel  [3].csKeyWord = "DATA";        streamCustomLevel   [3].pFunct = &ScpiPacket::setCustomTag;
                                                      streamCustomLevel   [4].pFunct = NULL;

    // STRM:L1 PARSE TABLE
    streamL1Level    [0].csKeyWord = "CUR";     streamL1Level                   [0].pFunct = &ScpiPacket::doStreamL1CurLevel;
    streamL1Level    [1].csKeyWord = "AVG";     streamL1Level                   [1].pFunct = &ScpiPacket::doStreamL1AvgLevel;
    streamL1Level    [2].csKeyWord = "MAX";     streamL1Level                   [2].pFunct = &ScpiPacket::doStreamL1MaxLevel;
    streamL1Level    [3].csKeyWord = "MIN";     streamL1Level                   [3].pFunct = &ScpiPacket::doStreamL1MinLevel;
                                                streamL1Level                   [4].pFunct = NULL;

    // STRM:L1:CUR PARSE TABLE
    streamL1CurLevel    [0].csKeyWord = "TXPCTBW?";     streamL1CurLevel        [0].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthNone;
    streamL1CurLevel    [1].csKeyWord = "RXPCTBW?";     streamL1CurLevel        [1].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthNone;
    streamL1CurLevel    [2].csKeyWord = "TXMBPS?";      streamL1CurLevel        [2].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecNone;
    streamL1CurLevel    [3].csKeyWord = "RXMBPS?";      streamL1CurLevel        [3].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecNone;
                                                        streamL1CurLevel        [4].pFunct = NULL;

    // STRM:L1:AVG PARSE TABLE
    streamL1AvgLevel    [0].csKeyWord = "TXPCTBW?";     streamL1AvgLevel        [0].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthAvgNone;
    streamL1AvgLevel    [1].csKeyWord = "RXPCTBW?";     streamL1AvgLevel        [1].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthAvgNone;
    streamL1AvgLevel    [2].csKeyWord = "TXMBPS?";      streamL1AvgLevel        [2].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecAvgNone;
    streamL1AvgLevel    [3].csKeyWord = "RXMBPS?";      streamL1AvgLevel        [3].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecAvgNone;
                                                        streamL1AvgLevel        [4].pFunct = NULL;

    // STRM:L1:MAX PARSE TABLE
    streamL1MaxLevel    [0].csKeyWord = "TXPCTBW?";     streamL1MaxLevel        [0].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthMaxNone;
    streamL1MaxLevel    [1].csKeyWord = "RXPCTBW?";     streamL1MaxLevel        [1].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthMaxNone;
    streamL1MaxLevel    [2].csKeyWord = "TXMBPS?";      streamL1MaxLevel        [2].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecMaxNone;
    streamL1MaxLevel    [3].csKeyWord = "RXMBPS?";      streamL1MaxLevel        [3].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecMaxNone;
                                                        streamL1MaxLevel        [4].pFunct = NULL;

    // STRM:L1:MIN PARSE TABLE
    streamL1MinLevel    [0].csKeyWord = "TXPCTBW?";     streamL1MinLevel        [0].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthMinNone;
    streamL1MinLevel    [1].csKeyWord = "RXPCTBW?";     streamL1MinLevel        [1].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthMinNone;
    streamL1MinLevel    [2].csKeyWord = "TXMBPS?";      streamL1MinLevel        [2].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecMinNone;
    streamL1MinLevel    [3].csKeyWord = "RXMBPS?";      streamL1MinLevel        [3].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecMinNone;
                                                        streamL1MinLevel        [4].pFunct = NULL;

    // STRM:L2 PARSE TABLE
    streamL2Level    [0].csKeyWord = "CUR";            streamL2Level            [0].pFunct = &ScpiPacket::doStreamL2CurLevel;
    streamL2Level    [1].csKeyWord = "AVG";            streamL2Level            [1].pFunct = &ScpiPacket::doStreamL2AvgLevel;
    streamL2Level    [2].csKeyWord = "MAX";            streamL2Level            [2].pFunct = &ScpiPacket::doStreamL2MaxLevel;
    streamL2Level    [3].csKeyWord = "MIN";            streamL2Level            [3].pFunct = &ScpiPacket::doStreamL2MinLevel;
    streamL2Level    [4].csKeyWord = "TXBYTES?";       streamL2Level            [4].pFunct = &ScpiPacket::getTxStreamBytes;
    streamL2Level    [5].csKeyWord = "RXBYTES?";       streamL2Level            [5].pFunct = &ScpiPacket::getRxStreamBytes;
    streamL2Level    [6].csKeyWord = "TXBYTEPS?";      streamL2Level            [6].pFunct = &ScpiPacket::getStreamL2TxBytesPerSec;
    streamL2Level    [7].csKeyWord = "RXBYTEPS?";      streamL2Level            [7].pFunct = &ScpiPacket::getStreamL2RxBytesPerSec;
                                                       streamL2Level            [8].pFunct = NULL;

    // STRM:L2:CUR PARSE TABLE
    streamL2CurLevel    [0].csKeyWord = "TXPCTBW?";     streamL2CurLevel        [0].pFunct = &ScpiPacket::getStreamL2TxLinkPctBandwidthNone;
    streamL2CurLevel    [1].csKeyWord = "RXPCTBW?";     streamL2CurLevel        [1].pFunct = &ScpiPacket::getStreamL2RxLinkPctBandwidthNone;
    streamL2CurLevel    [2].csKeyWord = "TXMBPS?";      streamL2CurLevel        [2].pFunct = &ScpiPacket::getStreamL2TxLinkKBPerSecNone;
    streamL2CurLevel    [3].csKeyWord = "RXMBPS?";      streamL2CurLevel        [3].pFunct = &ScpiPacket::getStreamL2RxLinkKBPerSecNone;
                                                        streamL2CurLevel        [4].pFunct = NULL;

    // STRM:L2:AVG PARSE TABLE
    streamL2AvgLevel    [0].csKeyWord = "TXPCTBW?";     streamL2AvgLevel        [0].pFunct = &ScpiPacket::getStreamL2TxLinkPctBandwidthAvgNone;
    streamL2AvgLevel    [1].csKeyWord = "RXPCTBW?";     streamL2AvgLevel        [1].pFunct = &ScpiPacket::getStreamL2RxLinkPctBandwidthAvgNone;
    streamL2AvgLevel    [2].csKeyWord = "TXMBPS?";      streamL2AvgLevel        [2].pFunct = &ScpiPacket::getStreamL2TxLinkKBPerSecAvgNone;
    streamL2AvgLevel    [3].csKeyWord = "RXMBPS?";      streamL2AvgLevel        [3].pFunct = &ScpiPacket::getStreamL2RxLinkKBPerSecAvgNone;
                                                        streamL2AvgLevel        [4].pFunct = NULL;

    // STRM:L2:MAX PARSE TABLE
    streamL2MaxLevel    [0].csKeyWord = "TXPCTBW?";     streamL2MaxLevel        [0].pFunct = &ScpiPacket::getStreamL2TxLinkPctBandwidthMaxNone;
    streamL2MaxLevel    [1].csKeyWord = "RXPCTBW?";     streamL2MaxLevel        [1].pFunct = &ScpiPacket::getStreamL2RxLinkPctBandwidthMaxNone;
    streamL2MaxLevel    [2].csKeyWord = "TXMBPS?";      streamL2MaxLevel        [2].pFunct = &ScpiPacket::getStreamL2TxLinkKBPerSecMaxNone;
    streamL2MaxLevel    [3].csKeyWord = "RXMBPS?";      streamL2MaxLevel        [3].pFunct = &ScpiPacket::getStreamL2RxLinkKBPerSecMaxNone;
                                                        streamL2MaxLevel        [4].pFunct = NULL;

    // STRM:L2:MIN PARSE TABLE
    streamL2MinLevel    [0].csKeyWord = "TXPCTBW?";     streamL2MinLevel        [0].pFunct = &ScpiPacket::getStreamL2TxLinkPctBandwidthMinNone;
    streamL2MinLevel    [1].csKeyWord = "RXPCTBW?";     streamL2MinLevel        [1].pFunct = &ScpiPacket::getStreamL2RxLinkPctBandwidthMinNone;
    streamL2MinLevel    [2].csKeyWord = "TXMBPS?";      streamL2MinLevel        [2].pFunct = &ScpiPacket::getStreamL2TxLinkKBPerSecMinNone;
    streamL2MinLevel    [3].csKeyWord = "RXMBPS?";      streamL2MinLevel        [3].pFunct = &ScpiPacket::getStreamL2RxLinkKBPerSecMinNone;
                                                        streamL2MinLevel        [4].pFunct = NULL;

    // STRM:CUR PARSE TABLE
    streamCurLevel    [0].csKeyWord = "TXPPS?";       streamCurLevel      [0].pFunct = &ScpiPacket::getStreamTxLinkPacketPerSecNone;
    streamCurLevel    [1].csKeyWord = "RXPPS?";       streamCurLevel      [1].pFunct = &ScpiPacket::getStreamRxLinkPacketPerSecNone;
    streamCurLevel    [2].csKeyWord = "TXPCTBW?";     streamCurLevel      [2].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthNone;
    streamCurLevel    [3].csKeyWord = "RXPCTBW?";     streamCurLevel      [3].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthNone;
    streamCurLevel    [4].csKeyWord = "TXMBPS?";      streamCurLevel      [4].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecNone;
    streamCurLevel    [5].csKeyWord = "RXMBPS?";      streamCurLevel      [5].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecNone;
                                                      streamCurLevel      [6].pFunct = NULL;

    // STRM:AVG PARSE TABLE
    streamAvgLevel    [0].csKeyWord = "TXPPS?";       streamAvgLevel      [0].pFunct = &ScpiPacket::getStreamTxLinkPacketPerSecAvgNone;
    streamAvgLevel    [1].csKeyWord = "RXPPS?";       streamAvgLevel      [1].pFunct = &ScpiPacket::getStreamRxLinkPacketPerSecAvgNone;
    streamAvgLevel    [2].csKeyWord = "TXPCTBW?";     streamAvgLevel      [2].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthAvgNone;
    streamAvgLevel    [3].csKeyWord = "RXPCTBW?";     streamAvgLevel      [3].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthAvgNone;
    streamAvgLevel    [4].csKeyWord = "TXMBPS?";      streamAvgLevel      [4].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecAvgNone;
    streamAvgLevel    [5].csKeyWord = "RXMBPS?";      streamAvgLevel      [5].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecAvgNone;
                                                      streamAvgLevel      [6].pFunct = NULL;

    // STRM:MAX PARSE TABLE
    streamMaxLevel    [0].csKeyWord = "TXPPS?";       streamMaxLevel      [0].pFunct = &ScpiPacket::getStreamTxLinkPacketPerSecMaxNone;
    streamMaxLevel    [1].csKeyWord = "RXPPS?";       streamMaxLevel      [1].pFunct = &ScpiPacket::getStreamRxLinkPacketPerSecMaxNone;
    streamMaxLevel    [2].csKeyWord = "TXPCTBW?";     streamMaxLevel      [2].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthMaxNone;
    streamMaxLevel    [3].csKeyWord = "RXPCTBW?";     streamMaxLevel      [3].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthMaxNone;
    streamMaxLevel    [4].csKeyWord = "TXMBPS?";      streamMaxLevel      [4].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecMaxNone;
    streamMaxLevel    [5].csKeyWord = "RXMBPS?";      streamMaxLevel      [5].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecMaxNone;
                                                      streamMaxLevel      [6].pFunct = NULL;

    // STRM:MIN PARSE TABLE
    streamMinLevel    [0].csKeyWord = "TXPPS?";       streamMinLevel      [0].pFunct = &ScpiPacket::getStreamTxLinkPacketPerSecMinNone;
    streamMinLevel    [1].csKeyWord = "RXPPS?";       streamMinLevel      [1].pFunct = &ScpiPacket::getStreamRxLinkPacketPerSecMinNone;
    streamMinLevel    [2].csKeyWord = "TXPCTBW?";     streamMinLevel      [2].pFunct = &ScpiPacket::getStreamL1TxLinkPctBandwidthMinNone;
    streamMinLevel    [3].csKeyWord = "RXPCTBW?";     streamMinLevel      [3].pFunct = &ScpiPacket::getStreamL1RxLinkPctBandwidthMinNone;
    streamMinLevel    [4].csKeyWord = "TXMBPS?";      streamMinLevel      [4].pFunct = &ScpiPacket::getStreamL1TxLinkKBPerSecMinNone;
    streamMinLevel    [5].csKeyWord = "RXMBPS?";      streamMinLevel      [5].pFunct = &ScpiPacket::getStreamL1RxLinkKBPerSecMinNone;
                                                      streamMinLevel      [6].pFunct = NULL;

    // Service Disruption PARSE TABLE
    sdLevel  [0].csKeyWord = "ACTION?";   sdLevel  [0].pFunct = &ScpiPacket::getSDState;
    sdLevel  [1].csKeyWord = "CURTIME?";  sdLevel  [1].pFunct = &ScpiPacket::getSDCurTime;
    sdLevel  [2].csKeyWord = "CURFRAME?"; sdLevel  [2].pFunct = &ScpiPacket::getSDCurFrame;
    sdLevel  [3].csKeyWord = "MINTIME?";  sdLevel  [3].pFunct = &ScpiPacket::getSDMinTime;
    sdLevel  [4].csKeyWord = "MINFRAME?"; sdLevel  [4].pFunct = &ScpiPacket::getSDMinFrame;
    sdLevel  [5].csKeyWord = "MAXTIME?";  sdLevel  [5].pFunct = &ScpiPacket::getSDMaxTime;
    sdLevel  [6].csKeyWord = "MAXFRAME?"; sdLevel  [6].pFunct = &ScpiPacket::getSDMaxFrame;
    sdLevel  [7].csKeyWord = "AVGTIME?";  sdLevel  [7].pFunct = &ScpiPacket::getSDAvgTime;
    sdLevel  [8].csKeyWord = "AVGFRAME?"; sdLevel  [8].pFunct = &ScpiPacket::getSDAvgFrame;
    sdLevel  [9].csKeyWord = "GOODTIME";  sdLevel  [9].pFunct = &ScpiPacket::setSDGoodTime;
    sdLevel [10].csKeyWord = "GOODTIME?"; sdLevel [10].pFunct = &ScpiPacket::getSDGoodTime;
    sdLevel [11].csKeyWord = "GOODFRAME"; sdLevel [11].pFunct = &ScpiPacket::setSDGoodFrame;
    sdLevel [12].csKeyWord = "GOODFRAME?";sdLevel [12].pFunct = &ScpiPacket::getSDGoodFrame;
    sdLevel [13].csKeyWord = "BADTIME";   sdLevel [13].pFunct = &ScpiPacket::setSDBadTime;
    sdLevel [14].csKeyWord = "BADTIME?";  sdLevel [14].pFunct = &ScpiPacket::getSDBadTime;
    sdLevel [15].csKeyWord = "BADFRAME";  sdLevel [15].pFunct = &ScpiPacket::setSDBadFrame;
    sdLevel [16].csKeyWord = "BADFRAME?"; sdLevel [16].pFunct = &ScpiPacket::getSDBadFrame;
    sdLevel [17].csKeyWord = "ACTION";    sdLevel [17].pFunct = &ScpiPacket::setSDAction;
    sdLevel [18].csKeyWord = "RECTIME?";  sdLevel [18].pFunct = &ScpiPacket::getSDRecentTime;
    sdLevel [19].csKeyWord = "RECFRAME?"; sdLevel [19].pFunct = &ScpiPacket::getSDRecentFrame;
                                          sdLevel [20].pFunct = NULL;


    // Y1564 PARSE TABLE
    y1564Level   [0].csKeyWord = "DESTPORT";       y1564Level   [0].pFunct = &ScpiPacket::rfcSetDestination;
    y1564Level   [1].csKeyWord = "DESTPORT?";      y1564Level   [1].pFunct = &ScpiPacket::rfcGetDestination;
    y1564Level   [2].csKeyWord = "TRIALDUR?";      y1564Level   [2].pFunct = &ScpiPacket::y1564GetTrialDur;
    y1564Level   [3].csKeyWord = "TRIALDUR";       y1564Level   [3].pFunct = &ScpiPacket::y1564SetTrialDur;
    y1564Level   [4].csKeyWord = "PERFDUR?";       y1564Level   [4].pFunct = &ScpiPacket::y1564GetPerfDur;
    y1564Level   [5].csKeyWord = "PERFDUR";        y1564Level   [5].pFunct = &ScpiPacket::y1564SetPerfDur;
    y1564Level   [6].csKeyWord = "ENABLE?";        y1564Level   [6].pFunct = &ScpiPacket::y1564GetEnable;
    y1564Level   [7].csKeyWord = "ENABLE";         y1564Level   [7].pFunct = &ScpiPacket::y1564SetEnable;
    y1564Level   [8].csKeyWord = "MASKSTEP?";      y1564Level   [8].pFunct = &ScpiPacket::y1564GetMaskStep;
    y1564Level   [9].csKeyWord = "MASKSTEP";       y1564Level   [9].pFunct = &ScpiPacket::y1564SetMaskStep;
    y1564Level  [10].csKeyWord = "RATESTEP?";      y1564Level  [10].pFunct = &ScpiPacket::y1564GetRateStep;
    y1564Level  [11].csKeyWord = "RATESTEP";       y1564Level  [11].pFunct = &ScpiPacket::y1564SetRateStep;
    y1564Level  [12].csKeyWord = "CIREIR?";        y1564Level  [12].pFunct = &ScpiPacket::y1564GetCirEir;
    y1564Level  [13].csKeyWord = "CIREIR";         y1564Level  [13].pFunct = &ScpiPacket::y1564SetCirEir;
    y1564Level  [14].csKeyWord = "CIR?";           y1564Level  [14].pFunct = &ScpiPacket::y1564GetCir;
    y1564Level  [15].csKeyWord = "CIR";            y1564Level  [15].pFunct = &ScpiPacket::y1564SetCir;
    y1564Level  [16].csKeyWord = "MAXJIT?";        y1564Level  [16].pFunct = &ScpiPacket::y1564GetMaxJit;
    y1564Level  [17].csKeyWord = "MAXJIT";         y1564Level  [17].pFunct = &ScpiPacket::y1564SetMaxJit;
    y1564Level  [18].csKeyWord = "MAXLOSS?";       y1564Level  [18].pFunct = &ScpiPacket::y1564GetMaxLoss;
    y1564Level  [19].csKeyWord = "MAXLOSS";        y1564Level  [19].pFunct = &ScpiPacket::y1564SetMaxLoss;
    y1564Level  [20].csKeyWord = "MAXLAT?";        y1564Level  [20].pFunct = &ScpiPacket::y1564GetMaxLat;
    y1564Level  [21].csKeyWord = "MAXLAT";         y1564Level  [21].pFunct = &ScpiPacket::y1564SetMaxLat;
    y1564Level  [22].csKeyWord = "SERVICENAME?";   y1564Level  [22].pFunct = &ScpiPacket::y1564GetServiceName;
    y1564Level  [23].csKeyWord = "SERVICENAME";    y1564Level  [23].pFunct = &ScpiPacket::y1564SetServiceName;
    y1564Level  [24].csKeyWord = "ACT?";           y1564Level  [24].pFunct = &ScpiPacket::y1564GetActivate;
    y1564Level  [25].csKeyWord = "ACT";            y1564Level  [25].pFunct = &ScpiPacket::y1564SetActivate;
    y1564Level  [26].csKeyWord = "LOSSPERF?";      y1564Level  [26].pFunct = &ScpiPacket::y1564GetLossPerf;
    y1564Level  [27].csKeyWord = "SEQPERF?";       y1564Level  [27].pFunct = &ScpiPacket::y1564GetSeqPerf;
    y1564Level  [28].csKeyWord = "RXPERF?";        y1564Level  [28].pFunct = &ScpiPacket::y1564GetRxPerf;
    y1564Level  [29].csKeyWord = "JITPERF?";       y1564Level  [29].pFunct = &ScpiPacket::y1564GetJitPerf;
    y1564Level  [30].csKeyWord = "LATPERF?";       y1564Level  [30].pFunct = &ScpiPacket::y1564GetLatPerf;
    y1564Level  [31].csKeyWord = "RAMPSTATUS?";    y1564Level  [31].pFunct = &ScpiPacket::y1564GetRampStatus;
    y1564Level  [32].csKeyWord = "PERFSTATUS?";    y1564Level  [32].pFunct = &ScpiPacket::y1564GetPerfStatus;
    y1564Level  [33].csKeyWord = "RAMP?";          y1564Level  [33].pFunct = &ScpiPacket::y1564GetRamp;
    y1564Level  [34].csKeyWord = "STEP?";          y1564Level  [34].pFunct = &ScpiPacket::y1564GetStep;
    y1564Level  [35].csKeyWord = "PERF?";          y1564Level  [35].pFunct = &ScpiPacket::y1564GetPerf;
    y1564Level  [36].csKeyWord = "DEFAULT";        y1564Level  [36].pFunct = &ScpiPacket::y1564SetFactoryDeflt;
                                                   y1564Level  [37].pFunct = NULL;


    // RFC PARSE TABLE
    rfcLevel  [0].csKeyWord = "THRU";         rfcLevel  [0].pFunct = &ScpiPacket::doRfcThruLevel;
    rfcLevel  [1].csKeyWord = "FRAME";        rfcLevel  [1].pFunct = &ScpiPacket::doRfcFrameLevel;
    rfcLevel  [2].csKeyWord = "BW";           rfcLevel  [2].pFunct = &ScpiPacket::doRfcBwLevel;
    rfcLevel  [3].csKeyWord = "TEST";         rfcLevel  [3].pFunct = &ScpiPacket::doRfcTestLevel;
    rfcLevel  [4].csKeyWord = "STATE?";       rfcLevel  [4].pFunct = &ScpiPacket::rfcGetState;
    rfcLevel  [5].csKeyWord = "B2B";          rfcLevel  [5].pFunct = &ScpiPacket::doRfcB2BLevel;
                                              rfcLevel  [6].pFunct = NULL;

    // RFC THRU PUT PARSE TABLE
    rfcThruLevel   [0].csKeyWord = "LOSS";     rfcThruLevel   [0].pFunct = &ScpiPacket::rfcSetThruLoss;
    rfcThruLevel   [1].csKeyWord = "LOSS?";    rfcThruLevel   [1].pFunct = &ScpiPacket::rfcGetThruLoss;
    rfcThruLevel   [2].csKeyWord = "RES";      rfcThruLevel   [2].pFunct = &ScpiPacket::rfcSetThruRes;
    rfcThruLevel   [3].csKeyWord = "RES?";     rfcThruLevel   [3].pFunct = &ScpiPacket::rfcGetThruRes;
    rfcThruLevel   [4].csKeyWord = "ACT";      rfcThruLevel   [4].pFunct = &ScpiPacket::rfcSetThruActivate;
    rfcThruLevel   [5].csKeyWord = "ACT?";     rfcThruLevel   [5].pFunct = &ScpiPacket::rfcGetThruActivate;
    rfcThruLevel   [6].csKeyWord = "PASS?";    rfcThruLevel   [6].pFunct = &ScpiPacket::rfcGetThruPass;
    rfcThruLevel   [7].csKeyWord = "TX?";      rfcThruLevel   [7].pFunct = &ScpiPacket::rfcGetThruTx;
    rfcThruLevel   [8].csKeyWord = "RX?";      rfcThruLevel   [8].pFunct = &ScpiPacket::rfcGetThruRx;
    rfcThruLevel   [9].csKeyWord = "MIN?";     rfcThruLevel   [9].pFunct = &ScpiPacket::rfcGetThruMin;
    rfcThruLevel  [10].csKeyWord = "MAX?";     rfcThruLevel  [10].pFunct = &ScpiPacket::rfcGetThruMax;
    rfcThruLevel  [11].csKeyWord = "AVG?";     rfcThruLevel  [11].pFunct = &ScpiPacket::rfcGetThruAvg;
    rfcThruLevel  [12].csKeyWord = "LAT";      rfcThruLevel  [12].pFunct = &ScpiPacket::rfcSetLatencyIterations;
    rfcThruLevel  [13].csKeyWord = "LAT?";     rfcThruLevel  [13].pFunct = &ScpiPacket::rfcGetLatencyIterations;
                                               rfcThruLevel  [14].pFunct = NULL;

    // RFC FRAME LOSS PARSE TABLE
    rfcFrameLevel  [0].csKeyWord = "TX?";      rfcFrameLevel  [0].pFunct = &ScpiPacket::rfcGetFrameTx;
    rfcFrameLevel  [1].csKeyWord = "RX?";      rfcFrameLevel  [1].pFunct = &ScpiPacket::rfcGetFrameRx;
    rfcFrameLevel  [2].csKeyWord = "ACT";      rfcFrameLevel  [2].pFunct = &ScpiPacket::rfcSetFrameActivate;
    rfcFrameLevel  [3].csKeyWord = "ACT?";     rfcFrameLevel  [3].pFunct = &ScpiPacket::rfcGetFrameActivate;
    rfcFrameLevel  [4].csKeyWord = "LOSS?";    rfcFrameLevel  [4].pFunct = &ScpiPacket::rfcGetFrameLoss;
    rfcFrameLevel  [5].csKeyWord = "RATE?";    rfcFrameLevel  [5].pFunct = &ScpiPacket::rfcGetFrameRate;
                                               rfcFrameLevel  [6].pFunct = NULL;

    // RFC BANDWIDTH PARSE TABLE
    rfcBwLevel     [0].csKeyWord = "CEILING";      rfcBwLevel       [0].pFunct = &ScpiPacket::rfcSetBwCeiling;
    rfcBwLevel     [1].csKeyWord = "CEILING?";     rfcBwLevel       [1].pFunct = &ScpiPacket::rfcGetBwCeiling;
    rfcBwLevel     [2].csKeyWord = "FLOOR";        rfcBwLevel       [2].pFunct = &ScpiPacket::rfcSetBwFloor;
    rfcBwLevel     [3].csKeyWord = "FLOOR?";       rfcBwLevel       [3].pFunct = &ScpiPacket::rfcGetBwFloor;
                                                   rfcBwLevel       [4].pFunct = NULL;

    // RFC TEST PARSE TABLE
    rfcTestLevel     [0].csKeyWord = "SIZE";        rfcTestLevel     [0].pFunct = &ScpiPacket::rfcSetTestSize;
    rfcTestLevel     [1].csKeyWord = "SIZE?";       rfcTestLevel     [1].pFunct = &ScpiPacket::rfcGetTestSize;
    rfcTestLevel     [2].csKeyWord = "MODE";        rfcTestLevel     [2].pFunct = &ScpiPacket::rfcSetTestMode;
    rfcTestLevel     [3].csKeyWord = "MODE?";       rfcTestLevel     [3].pFunct = &ScpiPacket::rfcGetTestMode;
    rfcTestLevel     [4].csKeyWord = "DUR";         rfcTestLevel     [4].pFunct = &ScpiPacket::rfcSetTestDuration;
    rfcTestLevel     [5].csKeyWord = "DUR?";        rfcTestLevel     [5].pFunct = &ScpiPacket::rfcGetTestDuration;
    rfcTestLevel     [6].csKeyWord = "STREAM";      rfcTestLevel     [6].pFunct = &ScpiPacket::rfcSetStream;
    rfcTestLevel     [7].csKeyWord = "STREAM?";     rfcTestLevel     [7].pFunct = &ScpiPacket::rfcGetStream;
    rfcTestLevel     [8].csKeyWord = "DEST";        rfcTestLevel     [8].pFunct = &ScpiPacket::rfcSetDestination;
    rfcTestLevel     [9].csKeyWord = "DEST?";       rfcTestLevel     [9].pFunct = &ScpiPacket::rfcGetDestination;
    rfcTestLevel    [10].csKeyWord = "DEFAULT";     rfcTestLevel    [10].pFunct = &ScpiPacket::rfcSetFactoryDeflt;
                                                    rfcTestLevel    [11].pFunct = NULL;

    // RFC B2B PARSE TABLE
    rfcB2BLevel     [0].csKeyWord = "ACT";         rfcB2BLevel     [0].pFunct = &ScpiPacket::rfcSetActivate;
    rfcB2BLevel     [1].csKeyWord = "ACT?";        rfcB2BLevel     [1].pFunct = &ScpiPacket::rfcGetActivate;
    rfcB2BLevel     [2].csKeyWord = "RES";         rfcB2BLevel     [2].pFunct = &ScpiPacket::rfcSetResolution;
    rfcB2BLevel     [3].csKeyWord = "RES?";        rfcB2BLevel     [3].pFunct = &ScpiPacket::rfcGetResolution;
    rfcB2BLevel     [4].csKeyWord = "REP";         rfcB2BLevel     [4].pFunct = &ScpiPacket::rfcSetRepititions;
    rfcB2BLevel     [5].csKeyWord = "REP?";        rfcB2BLevel     [5].pFunct = &ScpiPacket::rfcGetRepititions;
    rfcB2BLevel     [6].csKeyWord = "MAXPOS?";     rfcB2BLevel     [6].pFunct = &ScpiPacket::rfcGetMaxPossible;
    rfcB2BLevel     [7].csKeyWord = "AVGOBS?";     rfcB2BLevel     [7].pFunct = &ScpiPacket::rfcGetAvgObServed;
                                                   rfcB2BLevel     [8].pFunct = NULL;

    // RX PARSE TABLE
    rxLevel  [0].csKeyWord = "OPP?";        rxLevel  [0].pFunct = &ScpiPacket::rxGetOpticalPower;
    rxLevel  [1].csKeyWord = "PAT";         rxLevel  [1].pFunct = &ScpiPacket::setRxGfpPat;
    rxLevel  [2].csKeyWord = "PAT?";        rxLevel  [2].pFunct = &ScpiPacket::getRxGfpPat;
    rxLevel  [3].csKeyWord = "FCTOV";       rxLevel  [3].pFunct = &ScpiPacket::setRxFcTov;
    rxLevel  [4].csKeyWord = "FCTOV?";      rxLevel  [4].pFunct = &ScpiPacket::getRxFcTov;
    rxLevel  [5].csKeyWord = "TPID";        rxLevel  [5].pFunct = &ScpiPacket::doTpidLevel;
    rxLevel  [6].csKeyWord = "CID";         rxLevel  [6].pFunct = &ScpiPacket::setRxCid;
    rxLevel  [7].csKeyWord = "CID?";        rxLevel  [7].pFunct = &ScpiPacket::getRxCid;
    rxLevel  [8].csKeyWord = "OH";          rxLevel  [8].pFunct = &ScpiPacket::doResCaptureLevel;
    rxLevel  [9].csKeyWord = "PAUSE?";      rxLevel  [9].pFunct = &ScpiPacket::getPpPauseState;
    rxLevel [10].csKeyWord = "PAUSE";       rxLevel [10].pFunct = &ScpiPacket::setPpPauseState;
    rxLevel [11].csKeyWord = "CAPSIZE";     rxLevel [11].pFunct = &ScpiPacket::setCaptureSize;
    rxLevel [12].csKeyWord = "CAPSIZE?";    rxLevel [12].pFunct = &ScpiPacket::getCaptureSize;
    rxLevel [13].csKeyWord = "CAPSTART";    rxLevel [13].pFunct = &ScpiPacket::startCapture;
    rxLevel [14].csKeyWord = "CAPSTOP";     rxLevel [14].pFunct = &ScpiPacket::stopCapture;
    rxLevel [15].csKeyWord = "CAPSAVE";     rxLevel [15].pFunct = &ScpiPacket::doCaptureSaveLevel;
                                            rxLevel [16].pFunct = NULL;

    tpidLevel               [0].csKeyWord =  "VALUE";      tpidLevel           [0].pFunct = &ScpiPacket::setRxTpidValue;
    tpidLevel               [1].csKeyWord =  "VALUE?";     tpidLevel           [1].pFunct = &ScpiPacket::getRxTpidValue;
    tpidLevel               [2].csKeyWord =  "STATE";      tpidLevel           [2].pFunct = &ScpiPacket::setRxTpidState;
    tpidLevel               [3].csKeyWord =  "STATE?";     tpidLevel           [3].pFunct = &ScpiPacket::getRxTpidState;
                                                           tpidLevel           [4].pFunct = NULL;

    rxCaptureSaveLevel [0].csKeyWord = "PCAPNG";    rxCaptureSaveLevel [0].pFunct = &ScpiPacket::saveCapturePcapNg;
    rxCaptureSaveLevel [1].csKeyWord = "NANOPCAP";  rxCaptureSaveLevel [1].pFunct = &ScpiPacket::saveCaptureNanoPcap;
    rxCaptureSaveLevel [2].csKeyWord = "MICROPCAP"; rxCaptureSaveLevel [2].pFunct = &ScpiPacket::saveCapturePcap;
    rxCaptureSaveLevel [3].csKeyWord = "PCAP";      rxCaptureSaveLevel [3].pFunct = &ScpiPacket::saveCapturePcap;
                                                    rxCaptureSaveLevel [4].pFunct = NULL;

    // TX PARSE TABLE
    txLevel  [0].csKeyWord = "LASERTYPE?";      txLevel  [0].pFunct = &ScpiPacket::txGetLaserType;
    txLevel  [1].csKeyWord = "LASERTYPE";       txLevel  [1].pFunct = &ScpiPacket::txSetLaserType;
    txLevel  [2].csKeyWord = "LASERPUP?";       txLevel  [2].pFunct = &ScpiPacket::txGetLaserPwrUp;
    txLevel  [3].csKeyWord = "LASERPUP";        txLevel  [3].pFunct = &ScpiPacket::txSetLaserPwrUp;
    txLevel  [4].csKeyWord = "PAUSE";           txLevel  [4].pFunct = &ScpiPacket::txSetPause;
    txLevel  [5].csKeyWord = "PAUSE?";          txLevel  [5].pFunct = &ScpiPacket::txGetPause;
    txLevel  [6].csKeyWord = "EMIXMODE?";       txLevel  [6].pFunct = &ScpiPacket::txGetEmixMode;
    txLevel  [7].csKeyWord = "EMIXMODE";        txLevel  [7].pFunct = &ScpiPacket::txSetEmixMode;
    txLevel  [8].csKeyWord = "IPR";             txLevel  [8].pFunct = &ScpiPacket::txSetIPReflection;
    txLevel  [9].csKeyWord = "IPR?";            txLevel  [9].pFunct = &ScpiPacket::txGetIPReflection;
    txLevel [10].csKeyWord = "AUTO";            txLevel [10].pFunct = &ScpiPacket::txSetAutoNeg;
    txLevel [11].csKeyWord = "AUTO?";           txLevel [11].pFunct = &ScpiPacket::txGetAutoNeg;
    txLevel [12].csKeyWord = "ERR";             txLevel [12].pFunct = &ScpiPacket::doTxErrLevel;
    txLevel [13].csKeyWord = "SET?";            txLevel [13].pFunct = &ScpiPacket::txGetSet;
    txLevel [14].csKeyWord = "LINECONTROL";     txLevel [14].pFunct = &ScpiPacket::txSetLineControl;
    txLevel [15].csKeyWord = "LINECONTROL?";    txLevel [15].pFunct = &ScpiPacket::txGetLineControl;
    txLevel [16].csKeyWord = "FLOWCONTROL";     txLevel [16].pFunct = &ScpiPacket::txSetFlowControl;
    txLevel [17].csKeyWord = "FLOWCONTROL?";    txLevel [17].pFunct = &ScpiPacket::txGetFlowControl;
    txLevel [18].csKeyWord = "STATUS?";         txLevel [18].pFunct = &ScpiPacket::txGetMode;
    txLevel [19].csKeyWord = "REPLY";           txLevel [19].pFunct = &ScpiPacket::txSetReply;
    txLevel [20].csKeyWord = "REPLY?";          txLevel [20].pFunct = &ScpiPacket::txGetReply;
    txLevel [21].csKeyWord = "MAP";             txLevel [21].pFunct = &ScpiPacket::setPortMap;
    txLevel [22].csKeyWord = "MAP?";            txLevel [22].pFunct = &ScpiPacket::getPortMap;
    txLevel [23].csKeyWord = "PAT";             txLevel [23].pFunct = &ScpiPacket::setGfpPat;
    txLevel [24].csKeyWord = "PAT?";            txLevel [24].pFunct = &ScpiPacket::getGfpPat;
    txLevel [25].csKeyWord = "PFCS";            txLevel [25].pFunct = &ScpiPacket::setGfpPfcs;
    txLevel [26].csKeyWord = "PFCS?";           txLevel [26].pFunct = &ScpiPacket::getGfpPfcs;
    txLevel [27].csKeyWord = "EXI";             txLevel [27].pFunct = &ScpiPacket::setGfpExi;
    txLevel [28].csKeyWord = "EXI?";            txLevel [28].pFunct = &ScpiPacket::getGfpExi;
    txLevel [29].csKeyWord = "UPI";             txLevel [29].pFunct = &ScpiPacket::setGfpUpi;
    txLevel [30].csKeyWord = "UPI?";            txLevel [30].pFunct = &ScpiPacket::getGfpUpi;
    txLevel [31].csKeyWord = "CID";             txLevel [31].pFunct = &ScpiPacket::setGfpCid;
    txLevel [32].csKeyWord = "CID?";            txLevel [32].pFunct = &ScpiPacket::getGfpCid;
    txLevel [33].csKeyWord = "LEN";             txLevel [33].pFunct = &ScpiPacket::setGfpLen;
    txLevel [34].csKeyWord = "LEN?";            txLevel [34].pFunct = &ScpiPacket::getGfpLen;
    txLevel [35].csKeyWord = "RATE";            txLevel [35].pFunct = &ScpiPacket::setGfpRate;
    txLevel [36].csKeyWord = "RATE?";           txLevel [36].pFunct = &ScpiPacket::getGfpRate;
    txLevel [37].csKeyWord = "FABRICLOGIN";     txLevel [37].pFunct = &ScpiPacket::fabricLogin;
    txLevel [38].csKeyWord = "FABRICLOGIN?";    txLevel [38].pFunct = &ScpiPacket::getFabricLoginStatus;
    txLevel [39].csKeyWord = "PORTLOGIN";       txLevel [39].pFunct = &ScpiPacket::portLogin;
    txLevel [40].csKeyWord = "PORTLOGIN?";      txLevel [40].pFunct = &ScpiPacket::getPortLoginStatus;
    txLevel [41].csKeyWord = "BBCREDITBYPASS";  txLevel [41].pFunct = &ScpiPacket::setBBCreditBypass;
    txLevel [42].csKeyWord = "BBCREDITBYPASS?"; txLevel [42].pFunct = &ScpiPacket::getBBCreditBypass;
    txLevel [43].csKeyWord = "BBCREDIT";        txLevel [43].pFunct = &ScpiPacket::setBBCredit;
    txLevel [44].csKeyWord = "BBCREDIT?";       txLevel [44].pFunct = &ScpiPacket::getBBCredit;
    txLevel [45].csKeyWord = "FCPRIM";          txLevel [45].pFunct = &ScpiPacket::setTxFcPrim;
    txLevel [46].csKeyWord = "PTI";             txLevel [46].pFunct = &ScpiPacket::setTxPti;
    txLevel [47].csKeyWord = "PTI?";            txLevel [47].pFunct = &ScpiPacket::getTxPti;
    txLevel [48].csKeyWord = "SPARE";           txLevel [48].pFunct = &ScpiPacket::setTxSpare;
    txLevel [49].csKeyWord = "SPARE?";          txLevel [49].pFunct = &ScpiPacket::getTxSpare;
    txLevel [50].csKeyWord = "DEFICIT";         txLevel [50].pFunct = &ScpiPacket::setDeficitIdle;
    txLevel [51].csKeyWord = "DEFICIT?";        txLevel [51].pFunct = &ScpiPacket::getDeficitIdle;
    txLevel [52].csKeyWord = "PREAMBLE";        txLevel [52].pFunct = &ScpiPacket::setPreamble;
    txLevel [53].csKeyWord = "PREAMBLE?";       txLevel [53].pFunct = &ScpiPacket::getPreamble;
    txLevel [54].csKeyWord = "SCRAMBLE?";       txLevel [54].pFunct = &ScpiPacket::getScramble;
    txLevel [55].csKeyWord = "SCRAMBLE";        txLevel [55].pFunct = &ScpiPacket::setScramble;
    txLevel [56].csKeyWord = "LINKINIT?";       txLevel [56].pFunct = &ScpiPacket::getLinkinit;
    txLevel [57].csKeyWord = "LINKINIT";        txLevel [57].pFunct = &ScpiPacket::setLinkinit;
    txLevel [58].csKeyWord = "FILLWORD?";       txLevel [58].pFunct = &ScpiPacket::getFillword;
    txLevel [59].csKeyWord = "FILLWORD";        txLevel [59].pFunct = &ScpiPacket::setFillword;
    txLevel [60].csKeyWord = "SUPERBLK";        txLevel [60].pFunct = &ScpiPacket::setSuperBlock;
    txLevel [61].csKeyWord = "SUPERBLK?";       txLevel [61].pFunct = &ScpiPacket::getSuperBlock;
    txLevel [62].csKeyWord = "LASER";           txLevel [62].pFunct = &ScpiPacket::txSetLaserMode;
    txLevel [63].csKeyWord = "LASER?";          txLevel [63].pFunct = &ScpiPacket::txGetLaserMode;
    txLevel [64].csKeyWord = "AL";              txLevel [64].pFunct = &ScpiPacket::doTxAlarmLevel;
    txLevel [65].csKeyWord = "MODE";            txLevel [65].pFunct = &ScpiPacket::txSetMode;
    txLevel [66].csKeyWord = "MODE?";           txLevel [66].pFunct = &ScpiPacket::getPortInterface;
    txLevel [67].csKeyWord = "VLANFLOOD?";      txLevel [67].pFunct = &ScpiPacket::getVlanFlooding;
    txLevel [68].csKeyWord = "VLANFLOOD";       txLevel [68].pFunct = &ScpiPacket::setVlanFlooding;
    txLevel [69].csKeyWord = "LATENCYMODE";     txLevel [69].pFunct = &ScpiPacket::setLatencyMode;
    txLevel [70].csKeyWord = "LATENCYMODE?";    txLevel [70].pFunct = &ScpiPacket::getLatencyMode;
                                                txLevel [71].pFunct = NULL;

    //TX:ALarm TABLE
    txAlarmLevel [0].csKeyWord= "TYPE?"; txAlarmLevel [0].pFunct= &ScpiPacket::txGetAlarmType;
    txAlarmLevel [1].csKeyWord= "TYPE";  txAlarmLevel [1].pFunct= &ScpiPacket::txSetAlarmType;
                                         txAlarmLevel [2].pFunct= NULL;

     // TX:ERRor PARSE TABLE
    txErrLevel        [0].csKeyWord = "RATE";           txErrLevel    [0].pFunct = &ScpiPacket::txSetErrRate;
    txErrLevel        [1].csKeyWord = "RATE?";          txErrLevel    [1].pFunct = &ScpiPacket::txGetErrRate;
    txErrLevel        [2].csKeyWord = "TYPE";           txErrLevel    [2].pFunct = &ScpiPacket::txSetErrType;
    txErrLevel        [3].csKeyWord = "TYPE?";          txErrLevel    [3].pFunct = &ScpiPacket::txGetErrType;
    txErrLevel        [4].csKeyWord = "RUNTSIZE";       txErrLevel    [4].pFunct = &ScpiPacket::txSetRuntSize;
    txErrLevel        [5].csKeyWord = "RUNTSIZE?";      txErrLevel    [5].pFunct = &ScpiPacket::txGetRuntSize;
                                                        txErrLevel    [6].pFunct = NULL;
////////////// End Updated Parse Tables by Mike ///////////////////////

    // SEEDAB
    seedABLevel     [0].csKeyWord = "ABPAT";        seedABLevel     [0].pFunct = &ScpiPacket::setSeedABPat;
    seedABLevel     [1].csKeyWord = "ABPAT?";       seedABLevel     [1].pFunct = &ScpiPacket::getSeedABPat;
    seedABLevel     [2].csKeyWord = "APAT";         seedABLevel     [2].pFunct = &ScpiPacket::setSeedAPat;//TBD
    seedABLevel     [3].csKeyWord = "APAT?";        seedABLevel     [3].pFunct = &ScpiPacket::getSeedAPat;//TBD
    seedABLevel     [4].csKeyWord = "BPAT";         seedABLevel     [4].pFunct = &ScpiPacket::setSeedBPat;//TBD
    seedABLevel     [5].csKeyWord = "BPAT?";        seedABLevel     [5].pFunct = &ScpiPacket::getSeedBPat;//TBD
    seedABLevel     [6].csKeyWord = "COUNT?";       seedABLevel     [6].pFunct = &ScpiPacket::getSeedABCount;
    seedABLevel     [7].csKeyWord = "ES?";          seedABLevel     [7].pFunct = &ScpiPacket::getSeedABES;
    seedABLevel     [8].csKeyWord = "AVGRATE?";     seedABLevel     [8].pFunct = &ScpiPacket::getSeedABAvgRate;
    seedABLevel     [9].csKeyWord = "CURRATE?";     seedABLevel     [9].pFunct = &ScpiPacket::getSeedABCurRate;
                                                    seedABLevel     [10].pFunct = NULL;
    // PING
    pingLevel       [0].csKeyWord = "MACSRC";       pingLevel       [0].pFunct = &ScpiPacket::setMACSrc;
    pingLevel       [1].csKeyWord = "MACSRC?";      pingLevel       [1].pFunct = &ScpiPacket::getMACSrc;
    pingLevel       [2].csKeyWord = "IPSRC";        pingLevel       [2].pFunct = &ScpiPacket::setIPSrc;
    pingLevel       [3].csKeyWord = "IPSRC?";       pingLevel       [3].pFunct = &ScpiPacket::getIPSrc;
    pingLevel       [4].csKeyWord = "IPDEST";       pingLevel       [4].pFunct = &ScpiPacket::setIPDest;
    pingLevel       [5].csKeyWord = "IPDEST?";      pingLevel       [5].pFunct = &ScpiPacket::getIPDest;
    pingLevel       [6].csKeyWord = "PKTLEN";       pingLevel       [6].pFunct = &ScpiPacket::setPktLen;
    pingLevel       [7].csKeyWord = "PKTLEN?";      pingLevel       [7].pFunct = &ScpiPacket::getPktLen;
    pingLevel       [8].csKeyWord = "NUMPINGS";     pingLevel       [8].pFunct = &ScpiPacket::setNumPings;
    pingLevel       [9].csKeyWord = "NUMPINGS?";    pingLevel       [9].pFunct = &ScpiPacket::getNumPings;
    pingLevel       [10].csKeyWord = "TTL";         pingLevel       [10].pFunct = &ScpiPacket::setTTL;
    pingLevel       [11].csKeyWord = "TTL?";        pingLevel       [11].pFunct = &ScpiPacket::getTTL;
    pingLevel       [12].csKeyWord = "TIMEOUT";     pingLevel       [12].pFunct = &ScpiPacket::setTimeOut;
    pingLevel       [13].csKeyWord = "TIMEOUT?";    pingLevel       [13].pFunct = &ScpiPacket::getTimeOut;
    pingLevel       [14].csKeyWord = "START";       pingLevel       [14].pFunct = &ScpiPacket::setStart;
    pingLevel       [15].csKeyWord = "STOP";        pingLevel       [15].pFunct = &ScpiPacket::setStop;
    pingLevel       [16].csKeyWord = "REPLY?";      pingLevel       [16].pFunct = &ScpiPacket::getReply;
    pingLevel       [17].csKeyWord = "BYTESRX?";    pingLevel       [17].pFunct = &ScpiPacket::getBytesRx;
    pingLevel       [18].csKeyWord = "SEQNO?";      pingLevel       [18].pFunct = &ScpiPacket::getSeqNo;
    pingLevel       [19].csKeyWord = "PKTTTL?";     pingLevel       [19].pFunct = &ScpiPacket::getPktTTL;
    pingLevel       [20].csKeyWord = "PKTTIME?";    pingLevel       [20].pFunct = &ScpiPacket::getPktTime;
    pingLevel       [21].csKeyWord = "TX?";         pingLevel       [21].pFunct = &ScpiPacket::getTx;
    pingLevel       [22].csKeyWord = "RX?";         pingLevel       [22].pFunct = &ScpiPacket::getRx;
    pingLevel       [23].csKeyWord = "LOSS?";       pingLevel       [23].pFunct = &ScpiPacket::getLoss;
    pingLevel       [24].csKeyWord = "RTDMIN?";     pingLevel       [24].pFunct = &ScpiPacket::getRTDMin;
    pingLevel       [25].csKeyWord = "RTDMAX?";     pingLevel       [25].pFunct = &ScpiPacket::getRTDMax;
    pingLevel       [26].csKeyWord = "RTDAVG?";     pingLevel       [26].pFunct = &ScpiPacket::getRTDAvg;
    pingLevel       [27].csKeyWord = "DESTMAC?";    pingLevel       [27].pFunct = &ScpiPacket::getDestMAC;
    pingLevel       [28].csKeyWord = "SUBNET";      pingLevel       [28].pFunct = &ScpiPacket::setSubnetAddr;
    pingLevel       [29].csKeyWord = "SUBNET?";     pingLevel       [29].pFunct = &ScpiPacket::getSubnetAddr;
    pingLevel       [30].csKeyWord = "GATEWAY";     pingLevel       [30].pFunct = &ScpiPacket::setGatewayAddr;
    pingLevel       [31].csKeyWord = "GATEWAY?";    pingLevel       [31].pFunct = &ScpiPacket::getGatewayAddr;
                                                pingLevel       [32].pFunct = NULL;

    // ARP
    arpLevel       [0].csKeyWord = "MACSRC";       arpLevel       [0].pFunct = &ScpiPacket::setMACSrc;
    arpLevel       [1].csKeyWord = "MACSRC?";      arpLevel       [1].pFunct = &ScpiPacket::getMACSrc;
    arpLevel       [2].csKeyWord = "IPSRC";        arpLevel       [2].pFunct = &ScpiPacket::setIPSrc;
    arpLevel       [3].csKeyWord = "IPSRC?";       arpLevel       [3].pFunct = &ScpiPacket::getIPSrc;
    arpLevel       [4].csKeyWord = "SUBNET";       arpLevel       [4].pFunct = &ScpiPacket::setSubnetAddr;
    arpLevel       [5].csKeyWord = "SUBNET?";      arpLevel       [5].pFunct = &ScpiPacket::getSubnetAddr;
    arpLevel       [6].csKeyWord = "GATEWAY";      arpLevel       [6].pFunct = &ScpiPacket::setGatewayAddr;
    arpLevel       [7].csKeyWord = "GATEWAY?";     arpLevel       [7].pFunct = &ScpiPacket::getGatewayAddr;
                                                   arpLevel       [8].pFunct = NULL;

}


//********************************************************
// Call CORBA method to get Packet statistics
//********************************************************
int ScpiPacket::callGetPacketStatistics(IdlPacket2Stats& idlStatPacket)
{
    CORBA::Boolean resultStatus;

    IdlTestExecutionId idlTestExecutionId;
    memset((void*)&idlTestExecutionId, 0, sizeof(IdlTestExecutionId));

    StartCatch()

    IdlPacket2Stats_var IdlPacket2Stats_var = new IdlPacket2Stats;
    resultStatus = g_DataMgr3->getPacket2Data(m_globs->g_ppIndexStruct, idlTestExecutionId, IdlPacket2Stats_var);

    if(resultStatus == false)
    {
        return(ScpiProxyServer::INVALID_RESULTS);
    }
    memcpy(&idlStatPacket, IdlPacket2Stats_var.operator->(), sizeof(IdlPacket2Stats));
    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketStatistics", pExp)
}

int ScpiPacket::callGetPacketStreamStatistics(IdlPacket2AllStreamStats& idlStreamStatPacket)
{
    CORBA::Boolean resultStatus;

    IdlTestExecutionId idlTestExecutionId;
    memset((void*)&idlTestExecutionId, 0, sizeof(IdlTestExecutionId));

    StartCatch()
    IdlPacket2AllStreamStats_var idlPacketStreamStatistics_var = new IdlPacket2AllStreamStats;
    resultStatus = g_DataMgr3->getPacket2StreamData(m_globs->g_ppIndexStruct, idlTestExecutionId, idlPacketStreamStatistics_var);
    idlStreamStatPacket = idlPacketStreamStatistics_var;
    if(resultStatus == false)
    {
        return(ScpiProxyServer::INVALID_RESULTS);
    }
    //memcpy(&idlStreamStatPacket, idlPacket2StreamStats.operator->(), sizeof(IdlPacket2AllStreamStats));
    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketStreamStatistics", pExp)
}

int ScpiPacket::callGetPacketStreamStatistics2(IdlPacket2AllStreamStats2& idlStreamStat2Packet)
{
    CORBA::Boolean resultStatus;

    IdlTestExecutionId idlTestExecutionId;
    memset((void*)&idlTestExecutionId, 0, sizeof(IdlTestExecutionId));

    StartCatch()
    IdlPacket2AllStreamStats2_var idlPacketStreamStatistics2_var = new IdlPacket2AllStreamStats2;
    resultStatus = g_DataMgr3->getPacket2StreamData2(m_globs->g_ppIndexStruct, idlTestExecutionId, idlPacketStreamStatistics2_var);
    idlStreamStat2Packet = idlPacketStreamStatistics2_var;
    if(resultStatus == false)
    {
        return(ScpiProxyServer::INVALID_RESULTS);
    }
    //memcpy(&idlStreamStat2Packet, idlPacket2StreamStats2.operator->(), sizeof(IdlPacket2AllStreamStats2));
    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketStreamStatistics2", pExp)
}

int ScpiPacket::callGetPacketServiceStatistics(IdlPacket2AllServiceStats& idlStreamStatPacket)
{
    CORBA::Boolean resultStatus;

    IdlTestExecutionId idlTestExecutionId;
    memset((void*)&idlTestExecutionId, 0, sizeof(IdlTestExecutionId));

    StartCatch()
    IdlPacket2AllServiceStats_var idlPacket2ServiceStats_var = new IdlPacket2AllServiceStats;
    resultStatus = g_DataMgr3->getPacket2ServiceData(m_globs->g_ppIndexStruct, idlTestExecutionId, idlPacket2ServiceStats_var);
    idlStreamStatPacket = idlPacket2ServiceStats_var;
    if(resultStatus == false)
    {
        return(ScpiProxyServer::INVALID_RESULTS);
    }
    //memcpy(&idlStreamStatPacket, idlPacket2StreamStats.operator->(), sizeof(IdlPacket2AllStreamStats));
    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketServiceStatistics", pExp)
}

int ScpiPacket::getPacket2AllowedSettings(IdlPacket2AllSettings&     packetAllSettings,
                                          IdlPacket2AllowedSettings& packetAllowedSettings)
{
    int status;
    IdlPacket2AllowedSettings*  packetAllowedSettingsPtr;
    IdlPacket2AllSettings*      packetAllSettingsPtr;
    CORBA::Any_var anyStructureVar=new CORBA::Any;
    CORBA::Any_var anyStructure=new CORBA::Any;

    StartCatch()

    // Get Current Settings
    status = callGetAllSettings(anyStructure, m_globs);
    if (status != IDL_SUCCESS)
        return status;
    if (anyStructure >>= packetAllSettingsPtr)
        packetAllSettings = *packetAllSettingsPtr;
    else
        return ScpiProxyServer::INVALID_RESULTS;

    // Get Allowed settings
    anyStructureVar <<= packetAllSettings;
    status = callGetAllowedSettings(anyStructureVar, m_globs);
    if (status != IDL_SUCCESS)
        return status;
    if (!(anyStructureVar >>= packetAllowedSettingsPtr))
        return ScpiProxyServer::INVALID_SETTINGS;
    packetAllowedSettings = *packetAllowedSettingsPtr;

    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::getPacket2AllowedSettings", pExp)
}


//*****************************************
// Parse the input command, recursive.
//*****************************************
void ScpiPacket::parseCommandGiGe(CString& csScpiCmd)//parseCommandGiGe? mike!!
{
   CString csBuf;

   if( false == m_pScpiProxyServer->isPPSelected(m_globs))
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DLI_INVALID_PP_MODE);
   }
   else
   {   // Processing the command
        int iParseRet = TStartParse(this, rootPacket, csScpiCmd, m_globs);
        if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
         {
             // Flag error and send result
          m_pScpiProxyServer->m_errorOccurred = true;
          m_pScpiProxyServer->reportError(iParseRet);
         }
   }
}



//*****************************************
//       RES:ALARM LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResAlarmLevel (CString& csScpiCmd) {

    // Processing the command
    int iParseRet = TStartParse(this, resAlarmLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:CAPTURE LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResCaptureLevel (CString& csScpiCmd) {

    // Processing the command
    int iParseRet = TStartParse(this, resCaptureLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// STRM LEVEL PROCESSING
//*****************************************

void ScpiPacket::doStrmLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, strmLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}



//*****************************************
// Y1564 LEVEL PROCESSING
//*****************************************

void ScpiPacket::doY1564Level (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, y1564Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RFC LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRfcLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, rfcLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RFC:STATE?
//***************************
void ScpiPacket::rfcGetState (CString&)
{
#ifdef _MYDEBUG
   printf("\nRFC:STATE?");
#endif

    CString csResult;

   IdlPacket2Stats idlStatPacket;

   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (idlStatPacket.rfcState)
    {
    case IDL_PACKET2_RFC_STOPPED:
        csResult = "INACTIVE";
        break;
    case IDL_PACKET2_RFC_THROUGHPUT_ACTIVE:
        csResult = "Throughput active";
        break;
    case IDL_PACKET2_RFC_LATENCY_ACTIVE://I don't think this one is being used
        csResult = "Latency active";
        break;
    case IDL_PACKET2_RFC_FRAME_LOSS_ACTIVE:
        csResult = "Frameloss active";
        break;
    case IDL_PACKET2_RFC_BACK_TO_BACK_ACTIVE:// this one is not being used
        csResult = "BackToBack active";
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
        return;
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// RFC:*RST
//***************************
void ScpiPacket::rfcSetFactoryDeflt (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlOp1Struct    op1Struct;
    op1Struct.value = 1; // not really needed, dummy data

    anyStructure <<= op1Struct;
    ProtocolManager_var     g_ProtocolMgr;
    g_ProtocolMgr = CorbaClient::m_ProtocolMgr;
    int idlReturn = g_ProtocolMgr->setCommand(m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
        IDL_RFC2544_FACTORY_DEFAULT, anyStructure, m_globs->g_TestUnitId);

    if (idlReturn == IDL_SUCCESS)
        m_pScpiProxyServer->scpiResults("+0");
    else
        m_pScpiProxyServer->reportError(ScpiProxyServer::EXECUTION_ERR);
}


//*****************************************
// RFC B2B LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRfcB2BLevel (CString& csScpiCmd)
{
    // 10G does not support B2B
    if (m_globs->g_ppType == IDL_PP_HD_ENET_10G)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_INTERFACE);
        return;
    }
    // Processing the command
    int iParseRet = TStartParse(this, rfcB2BLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RFC THRU LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRfcThruLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, rfcThruLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}



//***************************
// RFC:THRU:LOSS
//***************************
void ScpiPacket::rfcSetThruLoss (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:THRU:LOSS <rate>");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int rate = atoi(csScpiCmd);

    if (rate < RFCSETTHRULOSS_LOWERLIMIT || rate > RFCSETTHRULOSS_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcAcceptLoss = static_cast<CORBA::UShort>(rate * 100);

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_ACCEPT_LOSS;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:THRU:LOSS?
//***************************
void ScpiPacket::rfcGetThruLoss (CString&)
{
#ifdef _MYDEBUG
    printf("\nRFC:THRU:LOSS?");
#endif

    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   int rate;

    if (idlSettingsPacket.rfcAcceptLoss != 0)
    {
        rate = idlSettingsPacket.rfcAcceptLoss;
    }
    else
    {
        rate = 0;
    }
    csResult.Format("%0.0f%%", rate / 100.0);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:RES
//***************************
void ScpiPacket::rfcSetThruRes (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:THRU:RES <rate>");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get test index number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());
    // get the parameter
    char seps[] = " ";
    char *next_token;
    char *token = strtok_s(parm, seps, &next_token);

    // validate the string is digits only

    int i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        i++;
    }
    int rate = static_cast<int>((atof(token) * 100) + 0.5);//to avoid decimal and make sure it rounds up if needed + 0.5

    //int rate = atoi(csScpiCmd);

    if (rate < RFCSETTHRURES_LOWERLIMIT || rate > RFCSETTHRURES_UPPERLIMIT * 100)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    //idlSettingsPacket.rfcResolution = static_cast<CORBA::UShort>(rate * 100);
    idlSettingsPacket.rfcResolution = static_cast<CORBA::UShort>(rate);

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_RESOLUTION;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:THRU:RES?
//***************************
void ScpiPacket::rfcGetThruRes (CString&)
{
#ifdef _MYDEBUG
    printf("\nRFC:THRU:RES?");
#endif

    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int rate;

    if (idlSettingsPacket.rfcResolution != 0)
    {
        rate = idlSettingsPacket.rfcResolution;
    }
    else
    {
        rate = 0;
    }
    csResult.Format("%0.2f%%", rate / 100.0);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:ACT
//***************************
void ScpiPacket::rfcSetThruActivate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:THRU:ACTivate <state>");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlOp1Struct idlOp1Settings;
    IdlPacket2AllSettings idlSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

//    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if (!csScpiCmd.CollateNoCase("ON"))
    {
        idlOp1Settings.value = IDL_PACKET2_RFC_THROUGHPUT_START;
    }
    else if (!csScpiCmd.CollateNoCase("OFF"))
    {
        idlOp1Settings.value = IDL_PACKET2_RFC_STOP;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Can't run RFC in ID337 mode.
    if (idlSettingsPacket.emixMode == IDL_PACKET2_EMIX_ID337)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // Set flag so GUI displays properly.
    if (idlSettingsPacket.ethSamOrRfc != IDL_RFC_VIEW)
    {
        CORBA::Any_var anyStructure2 = new CORBA::Any;
        idlSettingsPacket.reference  = IDL_PACKET2_REF_ETHSAM_OR_RFC;
        idlSettingsPacket.ethSamOrRfc = IDL_RFC_VIEW;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure2 <<= idlSettingsPacket;
        callSetAllSettings(anyStructure2, m_globs);
    }

    anyStructure<<=idlOp1Settings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_ARM_RFC_TEST, m_globs));
}

//***************************
// RFC:THRU:ACT?
//***************************
void ScpiPacket::rfcGetThruActivate (CString&)
{
#ifdef _MYDEBUG
    printf("\nRFC:THRU:ACT?");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));


    if(idlStatPacket.rfcState == IDL_PACKET2_RFC_THROUGHPUT_ACTIVE)
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
    }
    else
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
    }
}


//***************************
// RFC:THRU:PASS?
//***************************
void ScpiPacket::rfcGetThruPass (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:THRU:PASS? <selection>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int selection;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // convert into integer and put in selection var
    selection = atoi(token) - 1;

    csResult.Format("%0.2f", (float)(idlStatPacket.rfcThroughputPassingRate[selection] / 100.0));

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:TX?
//***************************
void ScpiPacket::rfcGetThruTx (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:THRU:TX? <selection>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int selection;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in selection var
    selection = atoi(token) - 1;

    csResult.Format("%I64u", idlStatPacket.rfcThroughputTxCount[selection]);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:TX?
//***************************
void ScpiPacket::rfcGetThruRx (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:THRU:RX? <selection>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int selection;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }


    // validate user input
    if(atoi(token) < 1 || atoi(token) > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in selection var
    selection = atoi(token) - 1;

    csResult.Format("%I64u", idlStatPacket.rfcThroughputRxCount[selection]);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:MIN?
//***************************
void ScpiPacket::rfcGetThruMin (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:THRU:MIN? <selection>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;

    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int selection;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in selection var
    selection = atoi(token) - 1;

    if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStatPacket.rfcLatencyMin[selection] / 1000.0);
    else if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStatPacket.rfcLatencyMin[selection] / 100.0);
    else if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStatPacket.rfcLatencyMin[selection] / 10.0);
    else
        csResult.Format("%d", idlStatPacket.rfcLatencyMin[selection]);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:MAX?
//***************************
void ScpiPacket::rfcGetThruMax (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:THRU:MAX? <selection>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;

    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int selection;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in selection var
    selection = atoi(token) - 1;

    if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStatPacket.rfcLatencyMax[selection] / 1000.0);
    else if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStatPacket.rfcLatencyMax[selection] / 100.0);
    else if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStatPacket.rfcLatencyMax[selection] / 10.0);
    else
        csResult.Format("%d", idlStatPacket.rfcLatencyMax[selection]);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:THRU:AVG?
//***************************
void ScpiPacket::rfcGetThruAvg (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:THRU:AVG? <selection>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;

    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int selection;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }
    // validate user input
    if(atoi(token) < 1 || atoi(token) > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in selection var
    selection = atoi(token) - 1;

    if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStatPacket.rfcLatencyAvg[selection] / 1000.0);
    else if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStatPacket.rfcLatencyAvg[selection] / 100.0);
    else if (packetAllowedSettings.rfcLatencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStatPacket.rfcLatencyAvg[selection] / 10.0);
    else
        csResult.Format("%d", idlStatPacket.rfcLatencyAvg[selection]);

    m_pScpiProxyServer->scpiResults(csResult);

}


//*****************************************
// RFC FRAMEloss LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRfcFrameLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, rfcFrameLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RFC:FRAMEloss:TX?
//***************************
void ScpiPacket::rfcGetFrameTx (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:FRAMEloss:TX? <frameIndex> <rateIndex>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int frameIndex;
    int rateIndex;
    char seps[]   = " ";

    // get the first parameter
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }
    //validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // convert into integer and put in frame var
    frameIndex = atoi(token) - 1;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }
    //validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // covert the parameter and put in rate var
    rateIndex = atoi(token) - 1;

    csResult.Format("%I64u", idlStatPacket.rfcLossTxCount[frameIndex][rateIndex]);

    m_pScpiProxyServer->scpiResults(csResult);

}


//***************************
// RFC:FRAMEloss:RX?
//***************************
void ScpiPacket::rfcGetFrameRx (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:FRAMEloss:RX? <frameIndex> <rateIndex>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int frameIndex;
    int rateIndex;
    char seps[]   = " ";

    // get the first parameter
    char *next_token;
    char *token = strtok_s(parm, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in frame var
    frameIndex = atoi(token) - 1;

    // get the second parameter
    token = strtok_s(NULL, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // covert the parameter and put in rate var
    rateIndex = atoi(token) - 1;

    csResult.Format("%I64u", idlStatPacket.rfcLossRxCount[frameIndex][rateIndex]);

    m_pScpiProxyServer->scpiResults(csResult);

}

//***************************
// RFC:FRAMEloss:LOSS?
//***************************
void ScpiPacket::rfcGetFrameLoss(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:FRAMEloss:LOSS? <frameIndex> <rateIndex>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int frameIndex;
    int rateIndex;
    char seps[]   = " ";

    // get the first parameter
    char *next_token;
    char *token = strtok_s(parm, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // convert into integer and put in frame var
    frameIndex = atoi(token) - 1;

    // get the second parameter
    token = strtok_s(NULL, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // covert the parameter and put in rate var
    rateIndex = atoi(token) - 1;
#if 1
    csResult.Format("%.7f%%", idlStatPacket.rfcLossPercent[frameIndex][rateIndex] * 1.0e-7);
#elif
    if (idlStatPacket.rfcLossTxCount[frameIndex][rateIndex] > idlStatPacket.rfcLossRxCount[frameIndex][rateIndex])
    {
        csResult.Format("%.4f", (float)(INT64)((idlStatPacket.rfcLossTxCount[frameIndex][rateIndex] -
        idlStatPacket.rfcLossRxCount[frameIndex][rateIndex]) * 100) /
        ((float)(INT64)idlStatPacket.rfcLossTxCount[frameIndex][rateIndex]));
    }
    else
            csResult.Format("%.4f%%", 0);
#endif

    m_pScpiProxyServer->scpiResults(csResult);

}

//***************************
// RFC:FRAMEloss:ACTivate
//***************************
void ScpiPacket::rfcSetFrameActivate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:FRAMEloss:ACTivate <state>");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlOp1Struct idlOp1Settings;
    IdlPacket2AllSettings idlSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if (!csScpiCmd.CollateNoCase("ON"))
    {
        idlOp1Settings.value = IDL_PACKET2_RFC_FRAME_LOSS_START;
    }
    else if (!csScpiCmd.CollateNoCase("OFF"))
    {
        idlOp1Settings.value = IDL_PACKET2_RFC_STOP;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Can't run RFC in ID337 mode.
    if (idlSettingsPacket.emixMode == IDL_PACKET2_EMIX_ID337)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // Set flag so GUI displays properly.
    if (idlSettingsPacket.ethSamOrRfc != IDL_RFC_VIEW)
    {
        CORBA::Any_var anyStructure2 = new CORBA::Any;
        idlSettingsPacket.reference  = IDL_PACKET2_REF_ETHSAM_OR_RFC;
        idlSettingsPacket.ethSamOrRfc = IDL_RFC_VIEW;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure2 <<= idlSettingsPacket;
        callSetAllSettings(anyStructure2, m_globs);
    }

    anyStructure<<=idlOp1Settings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_ARM_RFC_TEST, m_globs));
}

//***************************
// RFC:FRAMEloss:ACTivate?
//***************************
void ScpiPacket::rfcGetFrameActivate (CString&)
{
#ifdef _MYDEBUG
    printf("\nRFC:FRAMEloss:ACTivate?");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));


    if(idlStatPacket.rfcState == IDL_PACKET2_RFC_FRAME_LOSS_ACTIVE)
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
    }
    else
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
    }
}

//***************************
// RFC:FRAMEloss:RATE?
//***************************
void ScpiPacket::rfcGetFrameRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:FRAMEloss:RATE? <rateIndex>");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int rateIndex;
    char seps[]   = " ";

    // get the first parameter
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }
    //validate user input
    if(atoi(token) < 1 || atoi(token) > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // covert the parameter and put in rate var
    rateIndex = atoi(token) - 1;

    csResult.Format("%0.2f%%", idlStatPacket.rfcLossTxRate[rateIndex] / 100.0);

    m_pScpiProxyServer->scpiResults(csResult);

}

//*****************************************
// RFC BW LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRfcBwLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, rfcBwLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RFC:BW:CEILING
//***************************
void ScpiPacket::rfcSetBwCeiling(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:BW:CEILING");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    DLI_UINT32 rateCeiling = 0;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
   if (!(anyStructure >>= idlSettingsPacketPtr))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
   if( !(anyStructVar >>= currentPacketAllowedSettings))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
       return;
   }

   if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        // check the parameter
        // remove spaces on ends of command string
        csScpiCmd.TrimLeft(" ");
        csScpiCmd.TrimRight(" ");

        // Get test index number from the command string
        LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());
        // get the parameter
       char seps[] = " ";
       char *next_token;
       char *token = strtok_s(parm, seps, &next_token);

       // validate the string is digits only

       int i = 0;
       while (token[i] != NULL)
       {
           if (isdigit(token[i]) || (token[i] == '.'))
           {
           }
           else
           {
               m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
               return;
           }

           i++;
       }
       rateCeiling = static_cast<int>((atof(token) * 100) + 0.5);//to avoid decimal and make sure it rounds up if needed + 0.5

       // float check done above, this use to take only integers
       //if (m_pScpiProxyServer->checkNumeric(csScpiCmd.GetBuffer(csScpiCmd.GetLength()), rateCeiling))
       {

           if (((int)rateCeiling >= (int)(currentPacketAllowedSettings->rfcRateCeilingLo)) && ((int)rateCeiling <= (int)currentPacketAllowedSettings->rfcRateCeilingHi))
           {
               //idlSettingsPacket.rfcRateCeiling = static_cast<CORBA::UShort>(rateCeiling * 100);
               idlSettingsPacket.rfcRateCeiling = static_cast<CORBA::UShort>(rateCeiling);
           }
           else
           {
               m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
               return;
           }

           idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_RATE_CEILING;
           idlSettingsPacket.restartInhibit = TRUE;
           anyStructure<<=idlSettingsPacket;
           m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

       }
       //else
       //{
       //    m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
       //    return;
       //}
   }
   else
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
   }
}

//***************************
// RFC:BW:CEILING?
//***************************
void  ScpiPacket::rfcGetBwCeiling(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:BW:CEILING?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    CString csBuf;

    csBuf.Format("%0.2f%%", (idlSettingsPacket.rfcRateCeiling / 100.0));//default amt is 10000. But this is a percent value which only goes to 100%.
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RFC:BW:FLOOR
//***************************
void ScpiPacket::rfcSetBwFloor(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:BW:FLOOR");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    DLI_UINT32 rateFloor = 0;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
   if( !(anyStructVar >>= currentPacketAllowedSettings))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
       return;
   }

   if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        // check the parameter
        // remove spaces on ends of command string
        csScpiCmd.TrimLeft(" ");
        csScpiCmd.TrimRight(" ");

        // Get test index number from the command string
        LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());
        // get the parameter
       char seps[] = " ";
       char *next_token;
       char *token = strtok_s(parm, seps, &next_token);

       // validate the string is digits only

       int i = 0;
       while (token[i] != NULL)
       {
           if (isdigit(token[i]) || (token[i] == '.'))
           {
           }
           else
           {
               m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
               return;
           }

           i++;
       }
       rateFloor = static_cast<int>((atof(token) * 100) + 0.5);//to avoid decimal and make sure it rounds up if needed + 0.5

       // float check done above, this use to take only integers
       //if (m_pScpiProxyServer->checkNumeric(csScpiCmd.GetBuffer(csScpiCmd.GetLength()), rateFloor))
       {
           if (((int)rateFloor >= (int)currentPacketAllowedSettings->rfcRateFloorLo) && ((int)rateFloor <= (int)(currentPacketAllowedSettings->rfcRateFloorHi)))
           {
               //idlSettingsPacket.rfcRateFloor = static_cast<CORBA::UShort>(rateFloor * 100);
               idlSettingsPacket.rfcRateFloor = static_cast<CORBA::UShort>(rateFloor);
           }
           else
           {
               m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
               return;
           }

           idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_RATE_FLOOR;
           idlSettingsPacket.restartInhibit = TRUE;
           anyStructure<<=idlSettingsPacket;
           m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
       }
       //else
       //{
       //    m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
       //    return;
       //}
   }
   else
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
   }
}

//***************************
// RFC:BW:FLOOR?
//***************************
void  ScpiPacket::rfcGetBwFloor(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:BW:FLOOR?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csBuf;

    csBuf.Format("%0.2f%%", (idlSettingsPacket.rfcRateFloor / 100.0));
    m_pScpiProxyServer->scpiResults(csBuf);
}

//*****************************************
// RFC TEST LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRfcTestLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, rfcTestLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RFC:TEST:SIZE
//***************************
void ScpiPacket::rfcSetTestSize(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:TEST:SIZE");
#endif

    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    //DLI_UINT32 testIndex;
    char seps[] = " ";
    int testSize;
    int testIndex;
    int len;
    int i;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));//(anyStructure, IDL_ALL_SETTINGS_UPDATE, m_globs)
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get test index number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    // get the first parameter
    char *next_token;
    char *token = strtok_s(parm, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // convert into integer and put in testIndex var
    testIndex = atoi(token);

    // validate user input
    if(testIndex < 1 || testIndex > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // get the second parameter
    token = strtok_s(NULL, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // covert the parameter and put in testSize var
    testSize = atoi(token);

    if (testIndex > RFC_TESTINDEX_LOWERLIMIT && testIndex < RFC_TESTINDEX_UPPERLIMIT)
    {
        if (testSize >= RFC_TESTSIZE_LOWERLIMIT && testSize <= RFC_TESTSIZE_UPPERLIMIT)
        {
            testIndex--;
            idlSettingsPacket.rfcPacketSize[testIndex] = testSize;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }

        idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_PACKET_SIZE;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure <<= idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));//(anyStructure, IDL_ALL_SETTINGS_UPDATE, m_globs)
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// RFC:TEST:SIZE?
//***************************
void  ScpiPacket::rfcGetTestSize(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:SIZE?");
#endif
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    DLI_UINT32 testIndex;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
      idlSettingsPacket = *idlSettingsPacketPtr;



    if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {

        if (m_pScpiProxyServer->checkNumeric(csScpiCmd.GetBuffer(csScpiCmd.GetLength()), testIndex))
        {
            if (testIndex > RFC_TESTINDEX_LOWERLIMIT && testIndex < RFC_TESTINDEX_UPPERLIMIT)
            {

                testIndex--;
                CString csBuf;

               csBuf.Format("%d", idlSettingsPacket.rfcPacketSize[testIndex]);
               m_pScpiProxyServer->scpiResults(csBuf);

            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
                return;
            }
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// RFC:TEST:MODE
//***************************
void ScpiPacket::rfcSetTestMode(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:TEST:MODE");
#endif

    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    //DLI_UINT32 testIndex;

    char seps[] = " ";
    //int testSize;
    int testIndex;
    int len;
    int i;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));//(anyStructure, IDL_ALL_SETTINGS_UPDATE, m_globs)
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get test index number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    // get the first parameter
    char *next_token;
    char *token = strtok_s(parm, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    // convert into integer and put in testIndex var
    testIndex = atoi(token);
    if (testIndex < 1 || testIndex > 8) // 1-8 only accepted
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    else
        testIndex -= 1; // does not start at 0, but the index does so accommodate for that and minus one

    // get the second parameter
    token = strtok_s(NULL, seps, &next_token);

    // check if parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csTag;

    csTag = token;

    if (!csTag.CollateNoCase("ON"))
        {
            idlSettingsPacket.rfcPacketSizeEnableMask |= (0x01 << testIndex);
        }
        else if (!csTag.CollateNoCase("OFF"))
        {
            idlSettingsPacket.rfcPacketSizeEnableMask &= ~(0x01 << testIndex);
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
        idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_PACKET_SIZE_ENABLE;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure <<= idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

}

//***************************
// RFC:TEST:MODE?
//***************************
void  ScpiPacket::rfcGetTestMode(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:MODE?");
#endif

    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    DLI_UINT32 testIndex;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        if (m_pScpiProxyServer->checkNumeric(csScpiCmd.GetBuffer(csScpiCmd.GetLength()), testIndex))
        {
            if (testIndex > RFC_TESTINDEX_LOWERLIMIT && testIndex < RFC_TESTINDEX_UPPERLIMIT)
            {
                testIndex--;
                if (idlSettingsPacket.rfcPacketSizeEnableMask&(0x01 << testIndex))
                {
                    m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
                }
                else
                {
                    m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
                }
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
                return;
            }
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// RFC:TEST:DUR
//***************************
void ScpiPacket::rfcSetTestDuration (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:DUR <secs>");
#endif

   CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(csScpiCmd);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(csScpiCmd[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    int secs = atoi(csScpiCmd);

    if (secs < RFCSETTESTDURATION_LOWERLIMIT || secs > RFCSETTESTDURATION_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcTrialDuration = secs;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_TRIAL_DURATION;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:TEST:DUR?
//***************************
void ScpiPacket::rfcGetTestDuration (CString&)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:DUR?");
#endif

    CString csResult;

   CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%d secs", idlSettingsPacket.rfcTrialDuration);

   m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:TEST:STREAM
//***************************
void ScpiPacket::rfcSetStream(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:STREAM <rateIndex>");
#endif

    CString csResult;

   CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int streamId;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s(parm, seps, &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    streamId = atoi(token);
    //streamId--;

    if (streamId < 1 || streamId > 4)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcStreamId = streamId;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_STREAM_ID;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

}

//***************************
// RFC:TEST:STREAM?
//***************************
void ScpiPacket::rfcGetStream(CString&)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:STREAM?");
#endif

    CString csResult;

   CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   csResult.Format("%d", idlSettingsPacket.rfcStreamId);

   m_pScpiProxyServer->scpiResults(csResult);

}

//***************************
// RFC:TEST:DEST
//***************************
void ScpiPacket::rfcSetDestination (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:DEST <port>");
#endif

   CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(csScpiCmd);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(csScpiCmd[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    int port = atoi(csScpiCmd);

    if (port < 1 || port > 13)//valid ports are only 1-13
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcDestPort = port - 1;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_DEST_PORT;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:TEST:DEST?
//***************************
void ScpiPacket::rfcGetDestination (CString&)
{
#ifdef _MYDEBUG
    printf("\nRFC:TEST:DEST?");
#endif

    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("Destination is Port %u", idlSettingsPacket.rfcDestPort + 1);

    m_pScpiProxyServer->scpiResults(csResult);
}



//***************************
// TX:ERR:RUNTSIZE
//***************************
void ScpiPacket::txSetRuntSize (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRFC:TEST:DEST <port>");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    anyStructVar <<= idlSettingsPacket;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    int len;
    int i;

    // validate the string is digits only
    len = strlen(csScpiCmd);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(csScpiCmd[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    int runtSize = atoi(csScpiCmd);

    if ((runtSize < currentPacketAllowedSettings->runtSizeLo) ||
        (runtSize > currentPacketAllowedSettings->runtSizeHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.runtSize = runtSize;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RUNT_SIZE;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:ERR:RUNTSIZE?
//***************************
void ScpiPacket::txGetRuntSize (CString&)
{
#ifdef _MYDEBUG
   printf("\nRFC:TEST:DEST?");
#endif

    CString csResult;

   CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%u", idlSettingsPacket.runtSize);

   m_pScpiProxyServer->scpiResults(csResult);
}


//********************************************************
// COMMON GENERIC METHODS USED WITHIN
//********************************************************

//*****************************************
//       RES LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:LINK LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLinkLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLinkLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:CPP LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResCppLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resCppLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:LOS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLosLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLosLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}




//*****************************************
//       RES:UTILization LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:UTILization LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResVlanUtilLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:L1 LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilL1Level (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilL1Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L1:CUR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilCurLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilCurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L1:AVG LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilAvgLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilAvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L1:MAX LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMaxLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilMaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L1:MIN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMinLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilMinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:L2 LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilL2Level (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilL2Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L2:CUR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilL2CurLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilL2CurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L2:AVG LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilL2AvgLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilL2AvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L2:MAX LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilL2MaxLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilL2MaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UTIL:L2:MIN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilL2MinLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUtilL2MinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:HDRMM LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResHdrMMLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resHdrMMLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:LINECODE LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLinecodeLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLinecodeLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RES:LINECODE:COUNT?
//***************************
void ScpiPacket::getResLinecodeCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:LINECODE:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.lineCode);
}

//***************************
// RES:LINECODE:ES?
//***************************
void ScpiPacket::getResLinecodeES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:LINECODE:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.lineCode);
}

//***************************
// RES:LINECODE:AVGRATE?
//***************************
void ScpiPacket::getResLinecodeAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:LINECODE:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.lineCode);
}

//***************************
// RES:LINECODE:CURRATE?
//***************************
void ScpiPacket::getResLinecodeCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:LINECODE:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.lineCode);
}


//*****************************************
//       RES:SYNCHDR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResSyncHdrLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resSyncHdrLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RES:SYNCHDR:COUNT?
//***************************
void ScpiPacket::getResSyncHdrCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SYNCHDR:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.syncHdr);
}

//***************************
// RES:SYNCHDR:ES?
//***************************
void ScpiPacket::getResSyncHdrES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SYNCHDR:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.syncHdr);
}

//***************************
// RES:SYNCHDR:AVGRATE?
//***************************
void ScpiPacket::getResSyncHdrAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SYNCHDR:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.syncHdr);
}

//***************************
// RES:SYNCHDR:CURRATE?
//***************************
void ScpiPacket::getResSyncHdrCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SYNCHDR:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.syncHdr);
}

//*****************************************
//       RES:DISPARITY LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResDisparityLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resDisparityLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RES:DISPARITY:COUNT?
//***************************
void ScpiPacket::getResDisparityCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:DISPARITY:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.disparity);
}

//***************************
// RES:DISPARITY:ES?
//***************************
void ScpiPacket::getResDisparityES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:DISPARITY:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.disparity);
}

//***************************
// RES:DISPARITY:AVGRATE?
//***************************
void ScpiPacket::getResDisparityAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:DISPARITY:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.disparity);
}

//***************************
// RES:DISPARITY:CURRATE?
//***************************
void ScpiPacket::getResDisparityCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:DISPARITY:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.disparity);
}

//*****************************************
//       RES:COLLISIONS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResCollisionLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resCollisionLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:COLLISION:COUNT?
//***************************
void ScpiPacket::getResCollisionCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:COLLISION:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.collisions);
}

//***************************
// RES:COLLISION:ES?
//***************************
void ScpiPacket::getResCollisionES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:COLLISION:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.collisions);
}

//***************************
// RES:COLLISION:AVGRATE?
//***************************
void ScpiPacket::getResCollisionAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:COLLISION:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.collisions);
}

//***************************
// RES:COLLISION:CURRATE?
//***************************
void ScpiPacket::getResCollisionCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:COLLISION:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.collisions);
}


/////////////////////   GFP ////////////////////////////////////////////////
//*****************************************
//       RES:LFD LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLfdLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLfdLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:LOC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLocLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLocLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:LOCCS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLoccsLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLoccsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}




//*****************************************
//       RES:PFCS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResPfcsLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resPfcsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:SFCS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResSfcsLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resSfcsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:INVSUPER LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResInvSuperLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resInvSuperLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:CORRCHEC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResCorrCHecLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resCorrCHecLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UNCORRCHEC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUnCorrCHecLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUnCorrCHecLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:CORRTHEC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResCorrTHecLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resCorrTHecLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UNCORRTHEC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUnCorrTHecLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUnCorrTHecLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:CORREHEC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResCorrEHecLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resCorrEHecLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       RES:UNCORREHEC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUnCorrEHecLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUnCorrEHecLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       RES:FCS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResFcsLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resFcsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RES:PFCS:COUNT?
//***************************
void ScpiPacket::getResPfcsCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:PFCS:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.gfpFcs);
}


//***************************
// RES:SFCS:COUNT?
//***************************
void ScpiPacket::getResSfcsCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SFCS:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.superFcs);
}


//***************************
// RES:INVSUPER:COUNT?
//***************************
void ScpiPacket::getResInvSuperCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:INVSUPER:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.invalidSuper);
}


//***************************
// RES:CORRCHEC:COUNT?
//***************************
void ScpiPacket::getResCorrCHecCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRCHEC:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.correctableCHec);
}


//***************************
// RES:UNCORRCHEC:COUNT?
//***************************
void ScpiPacket::getResUnCorrCHecCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRCHEC:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.uncorrectableCHec);
}

//***************************
// RES:CORRTHEC:COUNT?
//***************************
void ScpiPacket::getResCorrTHecCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRTHEC:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.correctableTHec);
}


//***************************
// RES:UNCORRTHEC:COUNT?
//***************************
void ScpiPacket::getResUnCorrTHecCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRTHEC:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.uncorrectableTHec);
}

//***************************
// RES:CORREHEC:COUNT?
//***************************
void ScpiPacket::getResCorrEHecCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORREHEC:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.correctableEHec);
}


//***************************
// RES:UNCORREHEC:COUNT?
//***************************
void ScpiPacket::getResUnCorrEHecCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORREHEC:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.uncorrectableEHec);
}



//***************************
// RES:PFCS:ES?
//***************************
void ScpiPacket::getResPfcsES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:PFCS:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.gfpFcs);
}


//***************************
// RES:SFCS:ES?
//***************************
void ScpiPacket::getResSfcsES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SFCS:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.superFcs);
}


//***************************
// RES:INVSUPER:ES?
//***************************
void ScpiPacket::getResInvSuperES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:INVSUPER:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.invalidSuper);
}


//***************************
// RES:CORRCHEC:ES?
//***************************
void ScpiPacket::getResCorrCHecES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRCHEC:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.correctableCHec);
}


//***************************
// RES:UNCORRCHEC:ES?
//***************************
void ScpiPacket::getResUnCorrCHecES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRCHEC:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.uncorrectableCHec);
}

//***************************
// RES:CORRTHEC:ES?
//***************************
void ScpiPacket::getResCorrTHecES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRTHEC:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.correctableTHec);
}


//***************************
// RES:UNCORRTHEC:ES?
//***************************
void ScpiPacket::getResUnCorrTHecES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRTHEC:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.uncorrectableTHec);
}

//***************************
// RES:CORREHEC:ES?
//***************************
void ScpiPacket::getResCorrEHecES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORREHEC:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.correctableEHec);
}


//***************************
// RES:UNCORREHEC:ES?
//***************************
void ScpiPacket::getResUnCorrEHecES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORREHEC:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.uncorrectableEHec);
}


//***************************
// RES:PFCS:AVGRATE?
//***************************
void ScpiPacket::getResPfcsAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:PFCS:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.gfpFcs);
}


//***************************
// RES:SFCS:AVGRATE?
//***************************
void ScpiPacket::getResSfcsAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SFCS:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.superFcs);
}


//***************************
// RES:INVSUPER:AVGRATE?
//***************************
void ScpiPacket::getResInvSuperAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:INVSUPER:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.invalidSuper);
}


//***************************
// RES:CORRCHEC:AVGRATE?
//***************************
void ScpiPacket::getResCorrCHecAvgRate(CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRCHEC:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.correctableCHec);
}


//***************************
// RES:UNCORRCHEC:AVGRATE?
//***************************
void ScpiPacket::getResUnCorrCHecAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRCHEC:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.uncorrectableCHec);
}

//***************************
// RES:CORRTHEC:AVGRATE?
//***************************
void ScpiPacket::getResCorrTHecAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRTHEC:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.correctableTHec);
}


//***************************
// RES:UNCORRTHEC:AVGRATE?
//***************************
void ScpiPacket::getResUnCorrTHecAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRTHEC:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.uncorrectableTHec);
}

//***************************
// RES:CORREHEC:AVGRATE?
//***************************
void ScpiPacket::getResCorrEHecAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORREHEC:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.correctableEHec);
}


//***************************
// RES:UNCORREHEC:AVGRATE?
//***************************
void ScpiPacket::getResUnCorrEHecAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORREHEC:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.uncorrectableEHec);
}


//***************************
// RES:PFCS:CURRATE?
//***************************
void ScpiPacket::getResPfcsCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:PFCS:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.gfpFcs);
}


//***************************
// RES:SFCS:CURRATE?
//***************************
void ScpiPacket::getResSfcsCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:SFCS:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.superFcs);
}


//***************************
// RES:INVSUPER:CURRATE?
//***************************
void ScpiPacket::getResInvSuperCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:INVSUPER:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.invalidSuper);
}


//***************************
// RES:CORRCHEC:CURRATE?
//***************************
void ScpiPacket::getResCorrCHecCurRate(CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRCHEC:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.correctableCHec);
}


//***************************
// RES:UNCORRCHEC:CURRATE?
//***************************
void ScpiPacket::getResUnCorrCHecCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRCHEC:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.uncorrectableCHec);
}

//***************************
// RES:CORRTHEC:CURRATE?
//***************************
void ScpiPacket::getResCorrTHecCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORRTHEC:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.correctableTHec);
}


//***************************
// RES:UNCORRTHEC:CURRATE?
//***************************
void ScpiPacket::getResUnCorrTHecCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORRTHEC:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.uncorrectableTHec);
}

//***************************
// RES:CORREHEC:CURRATE?
//***************************
void ScpiPacket::getResCorrEHecCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:CORREHEC:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.correctableEHec);
}


//***************************
// RES:UNCORREHEC:CURRATE?
//***************************
void ScpiPacket::getResUnCorrEHecCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNCORREHEC:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.uncorrectableEHec);
}



/////////////////////// End GFP  ////////////////////////////////////////////////


//*****************************************
//       RES:FCALIGN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResFcAlignLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resFcAlignLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:FCALIGN:COUNT?
//***************************
void ScpiPacket::getResFcAlignCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCALIGN:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.fcAlignment);
}

//***************************
// RES:FCALIGN:ES?
//***************************
void ScpiPacket::getResFcAlignES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCALIGN:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.fcAlignment);
}

//***************************
// RES:FCALIGN:AVGRATE?
//***************************
void ScpiPacket::getResFcAlignAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCALIGN:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.fcAlignment);
}

//***************************
// RES:FCALIGN:CURRATE?
//***************************
void ScpiPacket::getResFcAlignCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCALIGN:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.fcAlignment);
}


//*****************************************
//       RES:FCALIGN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResFcDispLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resFcDispLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:FCDISP:COUNT?
//***************************
void ScpiPacket::getResFcDispCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCDISP:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.rxOsdErrCnt);
}

//***************************
// RES:FCDISP:ES?
//***************************
void ScpiPacket::getResFcDispES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCDISP:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.rxOsdErrCnt);
}

//***************************
// RES:FCDISP:AVGRATE?
//***************************
void ScpiPacket::getResFcDispAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCDISP:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.rxOsdErrCnt);
}

//***************************
// RES:FCDISP:CURRATE?
//***************************
void ScpiPacket::getResFcDispCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCDISP:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.rxOsdErrCnt);
}





//*****************************************
//       RES:FCEOFA LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResFcEofALevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resFcEofALevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:FCEOFA:COUNT?
//***************************
void ScpiPacket::getResFcEofACount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFA:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.fcEofAbort);
}

//***************************
// RES:FCEOFA:ES?
//***************************
void ScpiPacket::getResFcEofAES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFA:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.fcEofAbort);
}

//***************************
// RES:FCEOFA:AVGRATE?
//***************************
void ScpiPacket::getResFcEofAAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFA:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.fcEofAbort);
}

//***************************
// RES:FCEOFA:CURRATE?
//***************************
void ScpiPacket::getResFcEofACurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFA:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.fcEofAbort);
}



//*****************************************
//       RES:FCEOFERR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResFcEofErrLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resFcEofErrLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:FCEOFERR:COUNT?
//***************************
void ScpiPacket::getResFcEofErrCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFERR:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.fcEofErr);
}

//***************************
// RES:FCEOFERR:ES?
//***************************
void ScpiPacket::getResFcEofErrES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFERR:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.fcEofErr);
}

//***************************
// RES:FCEOFERR:AVGRATE?
//***************************
void ScpiPacket::getResFcEofErrAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFERR:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.fcEofErr);
}

//***************************
// RES:FCEOFERR:CURRATE?
//***************************
void ScpiPacket::getResFcEofErrCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCEOFERR:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.fcEofErr);
}


//*****************************************
//       RES:IPCHECKSUM LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResIpChecksumLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resIpChecksumLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:IPCHECKSUM:COUNT?
//***************************
void ScpiPacket::getResIpChecksumCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:IPCHECKSUM:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.ipChecksum);
}

//***************************
// RES:IPCHECKSUM:ES?
//***************************
void ScpiPacket::getResIpChecksumES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:IPCHECKSUM:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.ipChecksum);
}

//***************************
// RES:IPCHECKSUM:AVGRATE?
//***************************
void ScpiPacket::getResIpChecksumAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:IPCHECKSUM:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.ipChecksum);
}

//***************************
// RES:IPCHECKSUM:CURRATE?
//***************************
void ScpiPacket::getResIpChecksumCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:IPCHECKSUM:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.ipChecksum);
}

//*****************************************
//       RES:TCPCHECKSUM LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResTcpChecksumLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resTcpChecksumLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:TCPERR:COUNT?
//***************************
void ScpiPacket::getResTcpChecksumCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:TCPERR:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.tcpChecksum);
}

//***************************
// RES:TCPERR:ES?
//***************************
void ScpiPacket::getResTcpChecksumES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:TCPERR:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.tcpChecksum);
}

//***************************
// RES:TCPERR:AVGRATE?
//***************************
void ScpiPacket::getResTcpChecksumAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:TCPERR:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.tcpChecksum);
}

//***************************
// RES:TCPERR:CURRATE?
//***************************
void ScpiPacket::getResTcpChecksumCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:TCPERR:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.tcpChecksum);
}

//*****************************************
//       RES:UDPCHECKSUM LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUdpChecksumLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUdpChecksumLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:UDPERR:COUNT?
//***************************
void ScpiPacket::getResUdpChecksumCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UDPERR:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.udpChecksum);
}

//***************************
// RES:UDPERR:ES?
//***************************
void ScpiPacket::getResUdpChecksumES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UDPERR:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.udpChecksum);
}

//***************************
// RES:UDPERR:AVGRATE?
//***************************
void ScpiPacket::getResUdpChecksumAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UDPERR:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.udpChecksum);
}

//***************************
// RES:UDPERR:CURRATE?
//***************************
void ScpiPacket::getResUdpChecksumCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UDPERR:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.udpChecksum);
}

//*****************************************
//       RES:OVERSIZED LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResOversizedLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resOversizedLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:OVERSIZED:COUNT?
//***************************
void ScpiPacket::getResOversizedCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:OVERSIZED:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.oversized);
}

//***************************
// RES:OVERSIZED:ES?
//***************************
void ScpiPacket::getResOversizedES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:OVERSIZED:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.oversized);
}

//***************************
// RES:OVERSIZED:AVGRATE?
//***************************
void ScpiPacket::getResOversizedAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:OVERSIZED:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.oversized);
}

//***************************
// RES:OVERSIZED:CURRATE?
//***************************
void ScpiPacket::getResOversizedCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:OVERSIZED:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.oversized);
}

//*****************************************
//       RES:UNDERSIZED LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUndersizedLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resUndersizedLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:UNDERSIZED:COUNT?
//***************************
void ScpiPacket::getResUndersizedCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNDERSIZED:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.undersized);
}

//***************************
// RES:UNDERSIZED:ES?
//***************************
void ScpiPacket::getResUndersizedES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNDERSIZED:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.undersized);
}

//***************************
// RES:UNDERSIZED:AVGRATE?
//***************************
void ScpiPacket::getResUndersizedAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNDERSIZED:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.undersized);
}

//***************************
// RES:UNDERSIZED:CURRATE?
//***************************
void ScpiPacket::getResUndersizedCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:UNDERSIZED:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.undersized);
}

//*****************************************
//       RES:RUNT LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResRuntLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resRuntLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:RUNT:COUNT?
//***************************
void ScpiPacket::getResRuntCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:RUNT:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.runt);
}

//***************************
// RES:RUNT:ES?
//***************************
void ScpiPacket::getResRuntES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:RUNT:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.runt);
}

//***************************
// RES:RUNT:AVGRATE?
//***************************
void ScpiPacket::getResRuntAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:RUNT:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.runt);
}

//***************************
// RES:RUNT:CURRATE?
//***************************
void ScpiPacket::getResRuntCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:RUNT:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.runt);
}


//***************************
// RES:LFD:STATE?
//***************************
void ScpiPacket::getResLfdState (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LFD:STATE?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.gfpLfd.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RES:LOC:STATE?
//***************************
void ScpiPacket::getResLocState (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOC:STATE?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.gfpLocs.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// RES:LOCCS:STATE?
//***************************
void ScpiPacket::getResLoccsState (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOCCS:STATE?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.gfpLoccs.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// RES:LFD:SECS?
//***************************
void ScpiPacket::getResLfdSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LFD:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.gfpLfd.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// RES:LOC:SECS?
//***************************
void ScpiPacket::getResLocSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOC:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.gfpLocs.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:LOCCS:SECS?
//***************************
void ScpiPacket::getResLoccsSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOCCS:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.gfpLoccs.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}



//***************************
// RES:LOS:STATE?
//***************************
void ScpiPacket::getResLosState (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOS:STATE?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.los.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RES:LOS:SECS?
//***************************
void ScpiPacket::getResLosSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOS:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.los.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// RES:HDRMM:STATE?
//***************************
void ScpiPacket::getResHdrMMState (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOS:STATE?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.gfpHdrMismatch.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RES:HDRMM:SECS?
//***************************
void ScpiPacket::getResHdrMMSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LOS:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.gfpHdrMismatch.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// RES:CPPOWERLOSS:STATE?
//***************************
void ScpiPacket::getResCpPowerLossState (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:CPPOWERLOSS:STATE?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.cpPowerLoss.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);

}

//***************************
// RES:CPPOWERLOSS:SECS?
//***************************
void ScpiPacket::getResCpPowerLossSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:CPPOWERLOSS:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.cpPowerLoss.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:LINKSTATE?
//***************************
void  ScpiPacket::getResLinkState (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:LINK:STATE?");
#endif

    CString csResult = "OFF";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2Stats idlStatPacket;//for idlStatPacket.link.ledstate

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.link.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);

}

//***************************
// RES:LINK:SECS?
//***************************
void ScpiPacket::getResLinkSecs (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LINK:SECS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.link.alarmSecs);

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:LINK:STATUS?
//***************************
void ScpiPacket::getResLinkStatus (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:LINK:STATUS?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csResult.Format("%u",idlStatPacket.link.alarmSecs);

    int linkState   = idlStatPacket.loginStatus & 0x000F;
    switch(linkState)
    {
    default:
        csResult.Format("State Unknown!!!!");
        break;

    case 0:
        csResult.Format("Active");
        break;

    case 5:
        csResult.Format("Reset (LR1) ");
        break;

    case 6:
        csResult.Format("Reset (LR2) ");
        break;

    case 7:
        csResult.Format("Reset (LR3) ");
        break;

    case 9:
        csResult.Format("Failure (LF1) ");
        break;

    case 10:
        csResult.Format("Failure (LF2) ");
        break;

    case 13:
        csResult.Format("Offline (OL1) ");
        break;

    case 14:
        csResult.Format("Offline (OL2) ");
        break;

    case 15:
        csResult.Format("Offline (OL3) ");
        break;

    }

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// RES:AL:MODULESTATUS?
//***************************
void  ScpiPacket::getResSummaryModuleState (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:AL:MODULESTATUS?");
#endif

    CString csResult = "OFF";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2Stats idlStatPacket;//for idlStatPacket.summaryModuleLed

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.summaryModuleLed & 0x20)
        csResult = "ON";
    else if (idlStatPacket.summaryModuleLed & 0x40)
        csResult = "WARN";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);

}

///////////////////////////////////////////////////////////////////////////////
// RES:ALARM:PAUSED?
void ScpiPacket::getResAlarmPausedState (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRES:ALARM:PAUSED?");
#endif

    CString csResult = "OFF";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (idlStatPacket.ppPaused.ledState & 0x20)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}

//************************************
// RES:FABRICLOGIN? || TX:FABRICLOGIN?
//************************************
void ScpiPacket::getFabricLoginStatus (CString&)
{
    IdlPacket2Stats idlStatPacket;
    CString csResult;

#ifdef _MYDEBUG
    printf("\nRES:FABRICLOGIN?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    int fabricState = (idlStatPacket.loginStatus & 0x0F00) >> 8;
    switch(fabricState)
    {
    default:
        csResult.Format("Fabric: State Unknown");
        break;

    case 1:
        csResult.Format("Fabric: Not Logged in");
        break;

    case 2:
        csResult.Format("Fabric: Waiting for Response");
        break;

    case 3:
        csResult.Format("Fabric: Logged in");
        break;

    case 4:
        csResult.Format("Fabric: Login Rejected");
        break;
    }

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//********************************
// RES:PORTLOGIN? || TX:PORTLOGIN?
//********************************
void ScpiPacket::getPortLoginStatus (CString&)
{
   IdlPacket2Stats idlStatPacket;
   CString csResult;

#ifdef _MYDEBUG
      printf("\nRES:PORTLOGIN?");
#endif

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    int portState   = (idlStatPacket.loginStatus & 0x00F0) >> 4;
    switch(portState)
    {
        default:
            csResult.Format("Port: State Unknown");
            break;

        case 1:
            csResult.Format("Port: Not Logged in");
            break;

        case 2:
            csResult.Format("Port: Waiting for Response");
            break;

        case 3:
            csResult.Format("Port: Logged in");
            break;

        case 4:
            csResult.Format("Port: Login Rejected");
            break;
    }

    //Put the Result in scpi result buffer.
    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// TX:PORTLOGIN
//***************************
void ScpiPacket::portLogin      (CString& csScpiCmd)
{


    CORBA::Any_var anyStructure=new CORBA::Any;
    int val = atoi(csScpiCmd);

    IdlOp1Struct    op1Struct;
    op1Struct.value = IDL_PACKET2_FC_LOGIN_2;
    anyStructure <<= op1Struct;
    int idlReturn = (CorbaClient::m_ProtocolMgr)->setCommand(m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
                                                             IDL_TX_SINGLE_PACKET_BUFFER, anyStructure, m_globs->g_TestUnitId);

    m_pScpiProxyServer->scpiResults("+0");

}

//***************************
// STRM:BURST
//***************************
void ScpiPacket::sendBurst        (CString& csScpiCmd)
{

    CORBA::Any_var anyStructure=new CORBA::Any;

    int val = atoi(csScpiCmd);

    IdlOp1Struct    op1Struct;
    op1Struct.value = IDL_PACKET2_BURST;
    int streamId = atoi(csScpiCmd);
    if (streamId != NULL)
    {
        long stream = streamId;
        stream = stream << 24;
        op1Struct.value  |= stream;
    }

    anyStructure <<= op1Struct;
    ProtocolManager_var     g_ProtocolMgr;
    g_ProtocolMgr = CorbaClient::m_ProtocolMgr;
    int idlReturn = g_ProtocolMgr->setCommand(m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
        IDL_TX_SINGLE_PACKET_BUFFER, anyStructure, m_globs->g_TestUnitId);

    m_pScpiProxyServer->scpiResults("+0");

}

//***************************
// TX:FABRICLOGIN
//***************************
void ScpiPacket::fabricLogin        (CString& csScpiCmd)
{

    CORBA::Any_var anyStructure=new CORBA::Any;

    int val = atoi(csScpiCmd);

    IdlOp1Struct    op1Struct;
    op1Struct.value = IDL_PACKET2_FC_LOGIN_1;
    anyStructure <<= op1Struct;
    ProtocolManager_var     g_ProtocolMgr;
    g_ProtocolMgr = CorbaClient::m_ProtocolMgr;
    int idlReturn = g_ProtocolMgr->setCommand(m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
        IDL_TX_SINGLE_PACKET_BUFFER, anyStructure, m_globs->g_TestUnitId);

    m_pScpiProxyServer->scpiResults("+0");

}


//***************************
// TX:BBCREDIT?
//***************************
void ScpiPacket::getBBCredit (CString&)
{
    //char buf[MAX_STR_SIZE];

#ifdef _MYDEBUG
      printf("\nTX:BBCREDIT?");
#endif
    CString csResult;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   csResult.Format("%d",idlSettingsPacket.fcB2bCredits);

   m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
//TX:BBCREDIT
//***************************
void  ScpiPacket::setBBCredit (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:BBCREDIT");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    int credit;
    // validate the string is digits only

    credit = atoi(token);//to avoid decimal

    idlSettingsPacket.fcB2bCredits = credit;

    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_B2B_CREDITS;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// TX:BBCREDITBYPASS
//***************************
void ScpiPacket::setBBCreditBypass (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:BBCREDITBYPASS");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        if(!csScpiCmd.CollateNoCase("ON"))
            idlSettingsPacket.fcB2bCreditsBypass = 1;
        else if(!csScpiCmd.CollateNoCase("OFF"))
            idlSettingsPacket.fcB2bCreditsBypass = 0;
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_FC_B2B_CREDITS_BYPASS;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }

}


//***************************
// TX:BBCREDITBYPASS?
//***************************
void ScpiPacket::getBBCreditBypass (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:BBCREDITBYPASS?");
#endif

   CString csResults = "Err";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.fcB2bCreditsBypass == 1)
       csResults = "ON";
   else if(idlSettingsPacket.fcB2bCreditsBypass == 0)
       csResults = "OFF";


   m_pScpiProxyServer->scpiResults(csResults);
}


//***************************
// RES:TXBYTes?
//***************************
void ScpiPacket::getResTxBytes (CString&)
{
#ifdef _MYDEBUG
      printf("\nRES:TXBYTes?");
#endif

   IdlPacket2Stats idlStatPacket;
   CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%I64i",idlStatPacket.txBytes.count);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:RXBYTes?
//***************************
void ScpiPacket::getResRxBytes (CString&)
{
#ifdef _MYDEBUG
      printf("\nRES:RXBYTes?");
#endif

   IdlPacket2Stats idlStatPacket;
   CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%I64i",idlStatPacket.rxBytes.count);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:TXPACKets?
//***************************
void ScpiPacket::getResTxPackets (CString&)
{
#ifdef _MYDEBUG
      printf("\nRES:TXPACKets?");
#endif

   IdlPacket2Stats idlStatPacket;
   CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%I64i",idlStatPacket.txPackets.count);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:RXPACKets?
//***************************
void ScpiPacket::getResRxPackets (CString&)
{
#ifdef _MYDEBUG
      printf("\nRES:RXPACKets?");
#endif

   IdlPacket2Stats idlStatPacket;
   CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%I64i",idlStatPacket.rxPackets.count);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:JUMBO?
//***************************
void ScpiPacket::getResRxJumboPackets (CString&)
{
#ifdef _MYDEBUG
      printf("\nRES:JUMBO?");
#endif

   IdlPacket2Stats idlStatPacket;
   CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%I64i",idlStatPacket.rxJumboPackets.count);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// RES:TXPCTBW?
//***************************
void ScpiPacket::getResTxLinkPctBandwidth (CString& csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPCTBW?");
#endif

    float temp;

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = idlStatPacket.txLinkPctBandwidthVlan;
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = idlStatPacket.txLinkPctBandwidthMpls;
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = idlStatPacket.txLinkPctBandwidthIpv4;
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = idlStatPacket.txLinkPctBandwidthIpv6;
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = idlStatPacket.txLinkL2PctBandwidth;
          else
            temp = idlStatPacket.txLinkPctBandwidth;
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:RXPCTBW?
//***************************
void ScpiPacket::getResRxLinkPctBandwidth (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
      printf("\nRES:RXPCTBW?");
#endif

      float temp;
      IdlPacket2Stats idlStatPacket;
      CString csResult;

      TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

      switch (tagging)
      {
        case UTIL_VLAN:
        {
            temp = idlStatPacket.rxLinkPctBandwidthVlan;
            break;
        }

        case UTIL_MPLS:
        {
            if (IsMplsLicensed())
                temp = idlStatPacket.rxLinkPctBandwidthMpls;
          else
              return;

            break;
        }

        case UTIL_IPV4:
        {
            temp = idlStatPacket.rxLinkPctBandwidthIpv4;
            break;
        }

        case UTIL_IPV6:
        {
            if (IsIpv6Licensed())
                temp = idlStatPacket.rxLinkPctBandwidthIpv6;
          else
              return;

            break;
        }

        default:
        {
          if (isL2)
            temp = idlStatPacket.rxLinkL2PctBandwidth;
          else
            temp = idlStatPacket.rxLinkPctBandwidth;
            break;
        }
      }

      temp = temp / 100;
      csResult.Format("%.2f", temp);

      if(!csResult.IsEmpty())
      {
          m_pScpiProxyServer->m_queryFlag = true;
          m_pScpiProxyServer->scpiResults(csResult);
      }
      else
      {
          m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      }
}

//***************************
// RES:TXMBPS?
//***************************
void ScpiPacket::getResTxLinkKBPerSec (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXMBPS?");
#endif
    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.txLinkL2KBitPerSec);
          else
            temp = static_cast<float>(idlStatPacket.txLinkKBitPerSec);
          break;
      }
    }

    csResult.Format("%.2f", ((float)temp * 1.0e-3));

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:RXMBPS?
//***************************
void ScpiPacket::getResRxLinkKBPerSec (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.rxLinkL2KBitPerSec);
          else
            temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSec);
          break;
      }
    }

    csResult.Format("%.2f", ((float)temp * 1.0e-3));

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:TXPPS?
//***************************
void ScpiPacket::getResTxLinkPacketPerSec (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
      printf("\nRES:TXPPS?");
#endif

   IdlPacket2Stats idlStatPacket;
   CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSec);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:RXPPS?
//***************************
void ScpiPacket::getResRxLinkPacketPerSec (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSec);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

////////////////////
//AVG

//***************************
// RES:UTIL:AVG:TXPCTBW?
//***************************
void ScpiPacket::getResTxLinkPctBandwidthAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPCTBW?");
#endif
    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = idlStatPacket.txLinkPctBandwidthAvgVlan;
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = idlStatPacket.txLinkPctBandwidthAvgMpls;
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = idlStatPacket.txLinkPctBandwidthAvgIpv4;
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = idlStatPacket.txLinkPctBandwidthAvgIpv6;
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = idlStatPacket.txLinkL2PctBandwidthAvg;
          else
            temp = idlStatPacket.txLinkPctBandwidthAvg;
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:AVG:RXPCTBW?
//***************************
void ScpiPacket::getResRxLinkPctBandwidthAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPCTBW?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = idlStatPacket.rxLinkPctBandwidthAvgVlan;
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = idlStatPacket.rxLinkPctBandwidthAvgMpls;
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = idlStatPacket.rxLinkPctBandwidthAvgIpv4;
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = idlStatPacket.rxLinkPctBandwidthAvgIpv6;
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = idlStatPacket.rxLinkL2PctBandwidthAvg;
          else
            temp = idlStatPacket.rxLinkPctBandwidthAvg;
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:AVG:TXMBPS?
//***************************
void ScpiPacket::getResTxLinkKBPerSecAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecAvgVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecAvgMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecAvgIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecAvgIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.txLinkL2KBitPerSecAvg);
          else
            temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecAvg);
          break;
      }
    }

    temp = temp / 1000;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:AVG:RXMBPS?
//***************************
void ScpiPacket::getResRxLinkKBPerSecAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecAvgVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecAvgMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecAvgIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecAvgIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.rxLinkL2KBitPerSecAvg);
          else
            temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecAvg);
          break;
      }
    }

    temp = temp / 1000;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:AVG:TXPPS?
//***************************
void ScpiPacket::getResTxLinkPacketPerSecAvg (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecAvgVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecAvgMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecAvgIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecAvgIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecAvg);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:AVG:RXPPS?
//***************************
void ScpiPacket::getResRxLinkPacketPerSecAvg (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecAvgVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecAvgMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecAvgIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecAvgIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecAvg);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


// END AVG
/////////////



////////////////////
//MAX

//***************************
// RES:UTIL:MAX:TXPCTBW?
//***************************
void ScpiPacket::getResTxLinkPctBandwidthMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPCTBW?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = idlStatPacket.txLinkPctBandwidthMaxVlan;
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = idlStatPacket.txLinkPctBandwidthMaxMpls;
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = idlStatPacket.txLinkPctBandwidthMaxIpv4;
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = idlStatPacket.txLinkPctBandwidthMaxIpv6;
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = idlStatPacket.txLinkL2PctBandwidthMax;
          else
            temp = idlStatPacket.txLinkPctBandwidthMax;
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MAX:RXPCTBW?
//***************************
void ScpiPacket::getResRxLinkPctBandwidthMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPCTBW?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = idlStatPacket.rxLinkPctBandwidthMaxVlan;
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = idlStatPacket.rxLinkPctBandwidthMaxMpls;
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = idlStatPacket.rxLinkPctBandwidthMaxIpv4;
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = idlStatPacket.rxLinkPctBandwidthMaxIpv6;
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = idlStatPacket.rxLinkL2PctBandwidthMax;
          else
            temp = idlStatPacket.rxLinkPctBandwidthMax;
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MAX:TXMBPS?
//***************************
void ScpiPacket::getResTxLinkKBPerSecMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMaxVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMaxMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMaxIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMaxIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.txLinkL2KBitPerSecMax);
          else
            temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMax);
          break;
      }
    }

    temp = temp / 1000;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MAX:RXMBPS?
//***************************
void ScpiPacket::getResRxLinkKBPerSecMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMaxVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMaxMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMaxIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMaxIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.rxLinkL2KBitPerSecMax);
          else
            temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMax);
          break;
      }
    }

    temp = temp / 1000;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MAX:TXPPS?
//***************************
void ScpiPacket::getResTxLinkPacketPerSecMax (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMaxVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMaxMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMaxIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMaxIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMax);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MAX:RXPPS?
//***************************
void ScpiPacket::getResRxLinkPacketPerSecMax (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMaxVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMaxMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMaxIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMaxIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMax);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


// END MAX
/////////////

////////////////////
//MIN

//***************************
// RES:UTIL:MIN:TXPCTBW?
//***************************
void ScpiPacket::getResTxLinkPctBandwidthMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPCTBW?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.txLinkPctBandwidthMinVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.txLinkPctBandwidthMinMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.txLinkPctBandwidthMinIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.txLinkPctBandwidthMinIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.txLinkL2PctBandwidthMin);
          else
            temp = static_cast<float>(idlStatPacket.txLinkPctBandwidthMin);
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MIN:RXPCTBW?
//***************************
void ScpiPacket::getResRxLinkPctBandwidthMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPCTBW?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkPctBandwidthMinVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.rxLinkPctBandwidthMinMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkPctBandwidthMinIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.rxLinkPctBandwidthMinIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.rxLinkL2PctBandwidthMin);
          else
            temp = static_cast<float>(idlStatPacket.rxLinkPctBandwidthMin);
          break;
      }
    }

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MIN:TXMBPS?
//***************************
void ScpiPacket::getResTxLinkKBPerSecMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:TXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMinVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMinMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMinIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMinIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.txLinkL2KBitPerSecMin);
          else
            temp = static_cast<float>(idlStatPacket.txLinkKBitPerSecMin);
          break;
      }
    }

    temp = temp / 1000;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MIN:RXMBPS?
//***************************
void ScpiPacket::getResRxLinkKBPerSecMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nRES:RXMBPS?");
#endif

    float temp;
    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMinVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMinMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMinIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMinIpv6);
          else
              return;

          break;
      }

      default:
      {
          if (isL2)
            temp = static_cast<float>(idlStatPacket.rxLinkL2KBitPerSecMin);
          else
            temp = static_cast<float>(idlStatPacket.rxLinkKBitPerSecMin);
          break;
      }
    }

    temp = temp / 1000;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MIN:TXPPS?
//***************************
void ScpiPacket::getResTxLinkPacketPerSecMin (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMinVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMinMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMinIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMinIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.txLinkPacketPerSecMin);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// RES:UTIL:MIN:RXPPS?
//***************************
void ScpiPacket::getResRxLinkPacketPerSecMin (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nRES:RXPPS?");
#endif

    IdlPacket2Stats idlStatPacket;
    CString csResult;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (tagging)
    {
      case UTIL_VLAN:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMinVlan);
          break;
      }

      case UTIL_MPLS:
      {
          if (IsMplsLicensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMinMpls);
          else
              return;

          break;
      }

      case UTIL_IPV4:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMinIpv4);
          break;
      }

      case UTIL_IPV6:
      {
          if (IsIpv6Licensed())
              csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMinIpv6);
          else
              return;

          break;
      }

      default:
      {
          csResult.Format("%u",idlStatPacket.rxLinkPacketPerSecMin);
          break;
      }
    }

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


// END MIN
/////////////

//*****************************************
// RES:EVENTLOG?
//*****************************************
void ScpiPacket::getEventLog (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRES:EVENTLOG?");
#endif

    CString csResult  = "";
    CString csTemp  = "";
    DLI_UINT32 paramValue;
    IdlEventLog eventLog;
    //IdlTestExecutionId idlTestExecutionId;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    //Remove the question mark
    csScpiCmd.Delete(csScpiCmd.GetLength() -1);

    if (!m_pScpiProxyServer->checkNumeric(csScpiCmd.GetBuffer(csScpiCmd.GetLength()), paramValue))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
        return;
    }
    csScpiCmd.ReleaseBuffer();

    DLI_INT32 resultStatus = callGetEventLog(m_globs, eventLog, atoi(csScpiCmd));

    if(resultStatus != IDL_SUCCESS)
    {
        return;
    }

    else
    {
        csTemp.Format("%d,", eventLog.totalRecs);
        csResult += "\"" + csTemp + "\"" + ", ";

        csTemp.Format("%d,", eventLog.startRec);
        csResult += "\"" + csTemp + "\"" + ", ";

        csTemp.Format("%d,", eventLog.recCount);
        csResult += "\"" + csTemp + "\"" + ", ";

        csTemp.Format("%d,", eventLog.storedCount);
        csResult += "\"" + csTemp + "\"" + "; ";

        CDLIEvent* pcEventIds = CDLIEvent::GetInstance();

        for (WORD wIndex = 0; wIndex < eventLog.recCount; wIndex++)
        {
//            if (pcEventIds->IsPacketValidEvent(eventLog.records[wIndex].eventId) == TRUE)//model specific
            {
                pcEventIds->GetPacketString(eventLog.records[wIndex].eventId, csTemp);//model specific
                csTemp.TrimLeft();
                csTemp.TrimRight();
                csResult += "\"" + csTemp + "\"" + ", ";

                csTemp.Format("%6u", eventLog.records[wIndex].count);
                csTemp.TrimLeft();
                csTemp.TrimRight();
                csResult += "\"" + csTemp + "\"" + ", ";

                if (resultStatus == IDL_SUCCESS)
                {
                    CTime ctStartTime = MakeDliTime(eventLog.StartTime.time, eventLog.StartTime.date);
                    CTimeSpan ctsElapsed = eventLog.records[wIndex].timeStamp;
                    ctStartTime += ctsElapsed;
                    // Print the time according to local format setting.
                    csTemp = ctStartTime.Format("%x %X");
                    csTemp.TrimLeft();
                    csTemp.TrimRight();
                }
                csResult += "\"" + csTemp + "\"" + ", ";

                csTemp.Format("%6u", eventLog.records[wIndex].duration);
                csTemp.TrimLeft();
                csTemp.TrimRight();
                csResult += "\"" + csTemp + "\"";
                if (wIndex != eventLog.recCount - 1)
                    csResult += "; ";
            }
        }//End for
    }//End else

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
}


//***************************
// RES:STSD?
//***************************
void ScpiPacket::getResSTSD (CString&)
{
#ifdef _MYDEBUG
      printf("\nRES:STSD?");
#endif

    IdlPacket2Stats idlStatPacket;
    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    CORBA::Any_var anyStructOnly=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    CString csResult;
    CString csTemp1;
    CString csTemp2;
    CString csTemp3;
    CString csTemp4;
    CString csTemp5;
    UINT64  count1;
    UINT64  count2;
    UINT64  count3;
    UINT64  count4;
    //UINT64  count5;


    //Get Error data
    count1 = idlStatPacket.lineCode.errCount;
    csTemp1.Format("%I64u", count1);
    count2 = idlStatPacket.lineCode.errSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStatPacket.udpChecksum.errCount;
    csTemp3.Format("%I64u", count3);
    count4 = idlStatPacket.udpChecksum.errSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Error data
    count1 = idlStatPacket.fcs.errCount;
    csTemp1.Format("%I64u", count1);
    count2 = idlStatPacket.fcs.errSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStatPacket.ipChecksum.errCount;
    csTemp3.Format("%I64u", count3);
    count4 = idlStatPacket.ipChecksum.errSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    if (currentPacketAllowedSettings->fcEofAbortValid)
    {
        //clear the temp strings
        csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

        //Get Error data
        count1 = idlStatPacket.oversized.errCount;
        csTemp1.Format("%I64u", count1);
        count2 = idlStatPacket.oversized.errSecs;
        csTemp2.Format("%I64u", count2);
        count3 = idlStatPacket.undersized.errCount;
        csTemp3.Format("%I64u", count3);
        count4 = idlStatPacket.undersized.errSecs;
        csTemp4.Format("%I64u", count4);
        csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
            + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";
    }

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Error data
    count1 = idlStreamStatPacket.streamStats[0].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);
    count2 = idlStreamStatPacket.streamStats[0].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStreamStatPacket.streamStats[0].streamBit.errCount;
    csTemp3.Format("%I64u", count3);
    count4 = idlStreamStatPacket.streamStats[0].streamBit.errSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Error data
    count1 = idlStreamStatPacket.streamStats[1].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);
    count2 = idlStreamStatPacket.streamStats[1].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStreamStatPacket.streamStats[1].streamBit.errCount;
    csTemp3.Format("%I64u", count3);
    count4 = idlStreamStatPacket.streamStats[1].streamBit.errSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Error data
    count1 = idlStreamStatPacket.streamStats[2].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);
    count2 = idlStreamStatPacket.streamStats[2].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStreamStatPacket.streamStats[2].streamBit.errCount;
    csTemp3.Format("%I64u", count3);
    count4 = idlStreamStatPacket.streamStats[2].streamBit.errSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Error data
    count1 = idlStreamStatPacket.streamStats[3].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);
    count2 = idlStreamStatPacket.streamStats[3].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStreamStatPacket.streamStats[3].streamBit.errCount;
    csTemp3.Format("%I64u", count3);
    count4 = idlStreamStatPacket.streamStats[3].streamBit.errSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Alarm data
    count1 = idlStatPacket.cpPowerLoss.alarmSecs;
    csTemp1.Format("%I64u", count1);
    count2 = idlStatPacket.ppPaused.alarmSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStatPacket.los.alarmSecs;
    csTemp3.Format("%I64u", count3);
    count4 = idlStatPacket.link.alarmSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStreamStatPacket.streamStats[0].streamPatternSync.alarmSecs;
    csTemp1.Format("%I64u", count1);
    count2 = idlStreamStatPacket.streamStats[1].streamPatternSync.alarmSecs;
    csTemp2.Format("%I64u", count2);
    count3 = idlStreamStatPacket.streamStats[2].streamPatternSync.alarmSecs;
    csTemp3.Format("%I64u", count3);
    count4 = idlStreamStatPacket.streamStats[3].streamPatternSync.alarmSecs;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", " + "|";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    m_pScpiProxyServer->m_queryFlag = true;
    m_pScpiProxyServer->scpiResults(csResult);//asdf

}
//***************************
// RES:SPM?
//***************************
void ScpiPacket::getResSPM (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:SPM?");
#endif

    IdlPacket2Stats idlStatPacket;
    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    CORBA::Any_var anyStructOnly=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    CString csResult;
    CString csTemp1;
    CString csTemp2;
    CString csTemp3;
    CString csTemp4;
    CString csTemp5;
    UINT64  count1;
    UINT64  count2;
    UINT64  count3;
    UINT64  count4;
    UINT64  count5;

    //Get the TX data for the TX statistics
    count1 = idlStatPacket.txPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.txLinkPacketPerSec;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.txBytes.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.txLinkKBitPerSec;
    csTemp4.Format("%I64u", count4);

    count5 = idlStatPacket.txLinkPctBandwidth;
    csTemp5.Format("%I64u", count5);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", " + "\"" + csTemp5 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the RX data for the RX statistics
    count1 = idlStatPacket.rxPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.rxLinkPacketPerSec;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.rxBytes.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.rxLinkKBitPerSec;
    csTemp4.Format("%I64u", count4);

    count5 = idlStatPacket.rxLinkPctBandwidth;
    csTemp5.Format("%I64u", count5);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", " + "\"" + csTemp5 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Linecode data
    count1 = idlStatPacket.lineCode.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.lineCode.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStatPacket.lineCode.avgErrRateDen !=0)
        count3 = count1/idlStatPacket.lineCode.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStatPacket.lineCode.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStatPacket.lineCode.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStatPacket.lineCode.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Invalid UDP data
    count1 = idlStatPacket.udpChecksum.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.udpChecksum.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStatPacket.udpChecksum.avgErrRateDen !=0)
        count3 = count1/idlStatPacket.udpChecksum.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStatPacket.udpChecksum.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStatPacket.udpChecksum.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStatPacket.udpChecksum.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Invalid FCS data
    count1 = idlStatPacket.fcs.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.fcs.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStatPacket.fcs.avgErrRateDen !=0)
        count3 = count1/idlStatPacket.fcs.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStatPacket.fcs.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStatPacket.fcs.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStatPacket.fcs.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Invalid IP data
    count1 = idlStatPacket.ipChecksum.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.ipChecksum.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStatPacket.ipChecksum.avgErrRateDen !=0)
        count3 = count1/idlStatPacket.ipChecksum.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStatPacket.ipChecksum.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStatPacket.ipChecksum.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStatPacket.ipChecksum.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    if (currentPacketAllowedSettings->fcEofAbortValid)
    {
        //clear the temp strings
        csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

         //Get the Oversized data
        count1 = idlStatPacket.oversized.errCount;
        csTemp1.Format("%I64u", count1);

        count2 = idlStatPacket.oversized.errSecs;
        csTemp2.Format("%I64u", count2);
        if(idlStatPacket.oversized.avgErrRateDen !=0)
            count3 = count1/idlStatPacket.oversized.avgErrRateDen;

        csTemp3.Format("%#1.2e", count3);
        if(idlStatPacket.oversized.curErrRateDen !=0)
            count4 = static_cast<UINT64>((DOUBLE)(idlStatPacket.oversized.curErrRateNum)/
                                   (DOUBLE)(INT64)(idlStatPacket.oversized.curErrRateDen));

        csTemp4.Format("%#1.2e", count4);
        csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
            + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";
    }

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

     //Get the Undersized data
    count1 = idlStatPacket.undersized.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.undersized.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStatPacket.undersized.avgErrRateDen !=0)
        count3 = count1/idlStatPacket.undersized.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStatPacket.undersized.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStatPacket.undersized.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStatPacket.undersized.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

     //Get the Stream #1 data
    count1 = idlStreamStatPacket.streamStats[0].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[0].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[0].streamSequence.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[0].streamSequence.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[0].streamSequence.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[0].streamSequence.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[0].streamSequence.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStreamStatPacket.streamStats[0].streamBit.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[0].streamBit.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[0].streamBit.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[0].streamBit.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[0].streamBit.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[0].streamBit.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[0].streamBit.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Stream #2 data
    count1 = idlStreamStatPacket.streamStats[1].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[1].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[1].streamSequence.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[1].streamSequence.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[1].streamSequence.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[1].streamSequence.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[1].streamSequence.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStreamStatPacket.streamStats[1].streamBit.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[1].streamBit.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[1].streamBit.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[1].streamBit.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[1].streamBit.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[1].streamBit.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[1].streamBit.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Stream #3 data
    count1 = idlStreamStatPacket.streamStats[2].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[2].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[2].streamSequence.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[2].streamSequence.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[2].streamSequence.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[2].streamSequence.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[2].streamSequence.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStreamStatPacket.streamStats[2].streamBit.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[2].streamBit.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[2].streamBit.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[2].streamBit.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[2].streamBit.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[2].streamBit.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[2].streamBit.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the Stream #4 data
    count1 = idlStreamStatPacket.streamStats[3].streamSequence.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[3].streamSequence.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[3].streamSequence.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[3].streamSequence.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[3].streamSequence.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[3].streamSequence.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[3].streamSequence.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStreamStatPacket.streamStats[3].streamBit.errCount;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[3].streamBit.errSecs;
    csTemp2.Format("%I64u", count2);
    if(idlStreamStatPacket.streamStats[3].streamBit.avgErrRateDen !=0)
        count3 = count1/idlStreamStatPacket.streamStats[3].streamBit.avgErrRateDen;

    csTemp3.Format("%#1.2e", count3);
    if(idlStreamStatPacket.streamStats[3].streamBit.curErrRateDen !=0)
        count4 = static_cast<UINT64>((DOUBLE)(idlStreamStatPacket.streamStats[3].streamBit.curErrRateNum)/
                               (DOUBLE)(INT64)(idlStreamStatPacket.streamStats[3].streamBit.curErrRateDen));

    csTemp4.Format("%#1.2e", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get Alarm data
    count1 = idlStatPacket.cpPowerLoss.alarmSecs;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.ppPaused.alarmSecs;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.los.alarmSecs;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.link.alarmSecs;
    csTemp4.Format("%I64u", count4);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStreamStatPacket.streamStats[0].streamPatternSync.alarmSecs;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[1].streamPatternSync.alarmSecs;
    csTemp2.Format("%I64u", count2);

    count3 = idlStreamStatPacket.streamStats[2].streamPatternSync.alarmSecs;
    csTemp3.Format("%I64u", count3);

    count4 = idlStreamStatPacket.streamStats[3].streamPatternSync.alarmSecs;
    csTemp4.Format("%I64u", count4);

    csResult += csTemp1 + ", " + csTemp2 + ", " + csTemp3 + ", " + csTemp4 + ", ";

    //clear the temp strings
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //Get Packet counts
    count1 = idlStatPacket.rxJumboPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.rxPausePackets.count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.rxPauseQuanta.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.rxPauseEndPackets.count;
    csTemp4.Format("%I64u", count4);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStatPacket.rxIpPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.rxIcmpPackets.count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.rxTcpPackets.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.rxUdpPackets.count;
    csTemp4.Format("%I64u", count4);

    count5 = idlStatPacket.rxIgmpPackets.count;
    csTemp5.Format("%I64u", count5);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", " + "\"" + csTemp5 + "\"" + ", ";

    //Note that the packet counts BGP and OSPF and MPLS are not used.

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the VLAN data
    count1 = idlStatPacket.rxVlanPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.rxVlanPacketsQos[0].count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.rxVlanPacketsQos[1].count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.rxVlanPacketsQos[2].count;
    csTemp4.Format("%I64u", count4);

    count5 = idlStatPacket.rxVlanPacketsQos[3].count;
    csTemp5.Format("%I64u", count5);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", " + "\"" + csTemp5 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    count1 = idlStatPacket.rxVlanPacketsQos[4].count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStatPacket.rxVlanPacketsQos[5].count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStatPacket.rxVlanPacketsQos[6].count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStatPacket.rxVlanPacketsQos[7].count;
    csTemp4.Format("%I64u", count4);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Get the individual Stream data
    //Stream #1
    count1 = idlStreamStatPacket.streamStats[0].txStreamPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[0].rxStreamPackets.count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStreamStatPacket.streamStats[0].txStreamBytes.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStreamStatPacket.streamStats[0].rxStreamBytes.count;
    csTemp4.Format("%I64u", count4);
    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Stream #2
    count1 = idlStreamStatPacket.streamStats[1].txStreamPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[1].rxStreamPackets.count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStreamStatPacket.streamStats[1].txStreamBytes.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStreamStatPacket.streamStats[1].rxStreamBytes.count;
    csTemp4.Format("%I64u", count4);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Stream #3
    count1 = idlStreamStatPacket.streamStats[2].txStreamPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[2].rxStreamPackets.count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStreamStatPacket.streamStats[2].txStreamBytes.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStreamStatPacket.streamStats[2].rxStreamBytes.count;
    csTemp4.Format("%I64u", count4);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();

    //Stream #4
    count1 = idlStreamStatPacket.streamStats[3].txStreamPackets.count;
    csTemp1.Format("%I64u", count1);

    count2 = idlStreamStatPacket.streamStats[3].rxStreamPackets.count;
    csTemp2.Format("%I64u", count2);

    count3 = idlStreamStatPacket.streamStats[3].txStreamBytes.count;
    csTemp3.Format("%I64u", count3);

    count4 = idlStreamStatPacket.streamStats[3].rxStreamBytes.count;
    csTemp4.Format("%I64u", count4);

    csResult += "\"" + csTemp1 + "\"" + ", " + "\"" + csTemp2 + "\"" + ", " + "\""
        + csTemp3 + "\"" + ", " + "\"" + csTemp4 + "\"" + ", ";

    //Stats.settingsChangeCount
    csTemp1.Format("%d", idlStatPacket.settingsChangeCount);
    csResult += "\"" + csTemp1 + "\"" + ", " + "|";

    //clear the temp strings
    csTemp1.Empty();    csTemp2.Empty();    csTemp3.Empty();    csTemp4.Empty();    csTemp5.Empty();


    m_pScpiProxyServer->m_queryFlag = true;
    m_pScpiProxyServer->scpiResults(csResult);

}


//*****************************************
// RES PAUSE LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResPauseLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resPauseLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:PAUSE:STATE?
//***************************
void ScpiPacket::getResPauseState (CString&)
{
    //char buf[MAX_STR_SIZE];

#ifdef _MYDEBUG
   printf("\nRES:PAUSE:STATE?");
#endif

   CORBA::Any_var anyStructure=new CORBA::Any;
   IdlPacket2AllSettings idlSettingsPacket;
   IdlPacket2AllSettings *idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.ppPauseState == IDL_ON_STATE)
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
}

//******************************************************
// RES:PAUSE:SECS?   OR   RES:PAUSED:SECS?
//******************************************************
void ScpiPacket::getResPauseSecs (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PAUSE:SECS? OR RES:PAUSED:SECS?");
#endif

   char buf[MAX_STR_SIZE];
   memset(buf,0,sizeof(buf));

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

   sprintf_s(buf, sizeof(buf),"%d", idlStatPacket.ppPaused.alarmSecs);
   m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// RES:PAUSE:PACKETS?
//***************************
void ScpiPacket::getResPausePackets (CString&)
{
   char buf[MAX_STR_SIZE];

#ifdef _MYDEBUG
      printf("\nRES:PAUSE:PACKets?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

   memset(buf,0,sizeof(buf));
   sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxPausePackets.count);
   m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PAUSE:QUANTAS?
//***************************
void ScpiPacket::getResPauseQuantas (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PAUSE:QUANtas?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxPauseQuanta.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PAUSE:ENDPACKETS?
//***************************
void ScpiPacket::getResPauseEndPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PAUSE:ENDPACKets?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxPauseEndPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PAUSE:TXPACKETS?
//***************************
void ScpiPacket::getResTxPausePackets (CString&)
{
   char buf[MAX_STR_SIZE];

#ifdef _MYDEBUG
      printf("\nRES:PAUSE:TXPACKets?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

   memset(buf,0,sizeof(buf));
   sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txPausePackets.count);
   m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PAUSE:TXQUANTAS?
//***************************
void ScpiPacket::getResTxPauseQuantas (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PAUSE:TXQUANtas?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txPauseQuanta.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PAUSE:TXENDPACKETS?
//***************************
void ScpiPacket::getResTxPauseEndPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PAUSE:TXENDPACKets?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txPauseEndPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//*****************************************
// RES PACKET LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResPacketLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resPacketLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES RX PACKET LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResRxPacketLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resRxPacketLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES RX PACKET MPLS LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResRxPacketMplsLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resRxPacketMplsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES RX PACKET PAUSE LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResRxPacketPauseLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resRxPacketPauseLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES RX PACKET SIZE LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResRxPacketSizeLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resRxPacketSizeLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES RX PACKET VLAN LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResRxPacketVlanLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resRxPacketVlanLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES TX PACKET LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResTxPacketLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resTxPacketLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES TX PACKET PAUSE LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResTxPacketPauseLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resTxPacketPauseLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:PACKETS:IP?
//***************************
void ScpiPacket::getResIpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:IP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    CORBA::Any_var anyStructVar=new CORBA::Any;
    CORBA::Any_var anyStructOnly=new CORBA::Any;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    if (currentPacketAllowedSettings->rxIpPacketsValid)
    {
        if (currentPacketAllowedSettings->ipv4UtilizationValid)
            sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxIpv4Packets.count);
        else
            sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxIpPackets.count);
    }
    else
        sprintf_s(buf, sizeof(buf), "0");
    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// RES:PACKETS:IPV6?
//***************************
void ScpiPacket::getResIpv6Packets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:IPV6?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxIpv6Packets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// RES:TXPACKets:IP?
//***************************
void ScpiPacket::getResTxIpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:IP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txIpv4Packets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:TXPACKets:IPV6?
//***************************
void ScpiPacket::getResTxIpv6Packets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:IPV6?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txIpv6Packets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// RES:PACKETS:ICMP?
//***************************
void ScpiPacket::getResIcmpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:ICMP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxIcmpPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PACKETS:TCP?
//***************************
void ScpiPacket::getResTcpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:TCP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxTcpPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PACKETS:UDP?
//***************************
void ScpiPacket::getResUdpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:UDP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxUdpPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PACKETS:IGMP?
//***************************
void ScpiPacket::getResIgmpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:IGMP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxIgmpPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PACKETS:BGP?
//***************************
void ScpiPacket::getResBgpPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:BGP?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxBgpPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PACKETS:OSPF?
//***************************
void ScpiPacket::getResOspfPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:OSPF?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxOspfPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:PACKETS:MPLS?
//***************************
void ScpiPacket::getResMplsPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:PACKETS:MPLS?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMplsPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:TXPACKETS:MPLS?
//***************************
void ScpiPacket::getResTxMplsPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPACKETS:MPLS?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txMplsPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:TXPACKETS:VLAN?
//***************************
void ScpiPacket::getResTxVlanPackets (CString&)
{
#ifdef _MYDEBUG
    printf("\nRES:TXPACKETS:VLAN?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.txVlanPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//*****************************************
// RES VLAN LEVEL PROCESSING
//*****************************************

void ScpiPacket::doResVlanLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resVlanLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RES:VLAN:PACKETS? <level>
//***************************
void ScpiPacket::getResVlanPacketsByLevel (CString& csScpiCmd, int Level)
{
#ifdef _MYDEBUG
    printf("\nRES:VLAN:PACKets? <level | ALL>");
#endif

    INT64 Aggregate = 0;
    int index = 0;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        //validation
        if(csScpiCmd.IsEmpty() || csScpiCmd == "")
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // check the parameter
        // remove spaces on ends of command string
        csScpiCmd.TrimLeft(" ");
        csScpiCmd.TrimRight(" ");

        // Check if All Lane specified
        if(!csScpiCmd.CollateNoCase("ALL"))
        {
            Aggregate = idlStatPacket.rxVlanPackets.count;
            sprintf_s(buf, sizeof(buf),"%I64u", Aggregate);
        }
        else
        {
            // Get traffic generator number from the command string
            parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

            token = strtok_s(parm, seps , &next_token);
            if (token == NULL)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
            Level = atoi (token);

            // Verify Level range
            if ((Level < 1) || (Level > 4))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                return;
            }
        }
    }

    switch(Level)
    {
    case 1:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlanPackets.count);
        break;

    case 2:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlan2Packets.count);
        break;

    case 3:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlan3Packets.count);
        break;

    case 4:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlan4Packets.count);
        break;

    default:
        break;
    }


    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:VLAN:PACKETSQOS?
//***************************
void ScpiPacket::getResVlanPacketsQosByLevel (CString& csScpiCmd, int Level)
{
#ifdef _MYDEBUG
    printf("\nRES:VLAN:PACKETSQos?");
#endif
    int index = 0;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        //validation
        if(csScpiCmd.IsEmpty() || csScpiCmd == "")
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // check the parameter
        // remove spaces on ends of command string
        csScpiCmd.TrimLeft(" ");
        csScpiCmd.TrimRight(" ");

        // Get traffic generator number from the command string
        parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

        token = strtok_s(parm, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }

        // Get QOS Level
        token = strtok_s(NULL, seps , &next_token);
    }
    else
    {
        // check the parameter
        // remove spaces on ends of command string
        csScpiCmd.TrimLeft(" ");
        csScpiCmd.TrimRight(" ");

        // Get traffic generator number from the command string
        parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

        // Get QOS Level
        token = strtok_s(parm, seps , &next_token);
    }

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token);
    if ((index < 0) || (index > 7))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch(Level)
    {
    case 1:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlanPacketsQos[index].count);
        break;

    case 2:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlan2PacketsQos[index].count);
        break;

    case 3:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlan3PacketsQos[index].count);
        break;

    case 4:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxVlan4PacketsQos[index].count);
        break;

    default:
        break;
    }

    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// RES:TAG:MPLS:TC <stream> <level>?
//***************************
void ScpiPacket::getResMplsTC (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRES:TAG:MPLS:TC? <stream> Traffic_Class");
#endif

    int level;
    int tc;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    char buf[MAX_STR_SIZE];
    // Initialize buffer before using
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;

    // check the parameter

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Class of Service
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    // Get MPLS Level
    token = strtok_s(parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    level = atoi(token);

    // Verify Level range
    if ((level < 1) || (level > 4))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    token = strtok_s(NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // Class of Service
    tc = atoi(token);
    if ((tc < 0) || (tc > 7))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(level)
    {
    case 1:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls1PacketsCos[tc].count);
        break;

    case 2:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls2PacketsCos[tc].count);
        break;

    case 3:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls3PacketsCos[tc].count);
        break;

    case 4:
        sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls4PacketsCos[tc].count);
        break;

    default:
        break;
    }

    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// RES:MPLS:PACKETS<level>?
//***************************
void ScpiPacket::getResMplsPacketsByLevel (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nRES:MPLS:PACKETS <level | ALL>?");
#endif

    INT64 Aggregate = 0;
    int level = 0;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2Stats idlStatPacket;

    // Verify command args exist
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Check if All Lane specified
    if(!csScpiCmd.CollateNoCase("ALL"))
    {
        Aggregate = idlStatPacket.rxMpls1Packets.count;
        sprintf_s(buf, sizeof(buf),"%I64u", Aggregate);
    }
    else
    {
        // Get Level from the command string
        parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

        // Get MPLS Level
        token = strtok_s(parm, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }
        level = atoi(token);

        // Verify Level range
        if ((level < 1) || (level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }

        switch(level)
        {
        case 1:
            sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls1Packets.count);
            break;

        case 2:
            sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls2Packets.count);
            break;

        case 3:
            sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls3Packets.count);
            break;

        case 4:
            sprintf_s(buf, sizeof(buf),"%I64u", idlStatPacket.rxMpls4Packets.count);
            break;

        default:
            break;
        }
    }

    m_pScpiProxyServer->setResultBuf(buf);
}

//*****************************************
// RES:UTIL:VLAN: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilVlanLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilVlanLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:VLAN:CUR: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilVlanCurLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilVlanCurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// RES:UTIL:VLAN:AVG: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilVlanAvgLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilVlanAvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:VLAN:MAX: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilVlanMaxLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilVlanMaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}
//*****************************************
// RES:UTIL:VLAN:MIN: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilVlanMinLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilVlanMinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}



//*****************************************
// RES:MPLS: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResMplsLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resMplsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:MPLS: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMplsLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilMplsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:MPLS:CUR: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMplsCurLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilMplsCurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// RES:UTIL:MPLS:AVG: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMplsAvgLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilMplsAvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:MPLS:MAX: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMplsMaxLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilMplsMaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}
//*****************************************
// RES:UTIL:MPLS:MIN: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilMplsMinLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilMplsMinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//////////////////   IPV4 //////////////////////////

//*****************************************
// RES:UTIL:IPV4: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv4Level (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv4Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:MPLS:CUR: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv4CurLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv4CurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// RES:UTIL:Ipv4:AVG: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv4AvgLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv4AvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:Ipv4:MAX: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv4MaxLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv4MaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}
//*****************************************
// RES:UTIL:Ipv4:MIN: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv4MinLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv4MinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//////////////////   IPV6 //////////////////////////

//*****************************************
// RES:UTIL:IPV6: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv6Level (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv6Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:IPV6:CUR: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv6CurLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv6CurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// RES:UTIL:Ipv4:AVG: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv6AvgLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv6AvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// RES:UTIL:Ipv6:MAX: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv6MaxLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv6MaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}
//*****************************************
// RES:UTIL:Ipv6:MIN: LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResUtilIpv6MinLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, resUtilIpv6MinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// STREAM BIT LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamBitLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamBitLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM LOSS LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamLossLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamLossLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM SEQ LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamSeqLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamSeqLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM SYNC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamSyncLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamSyncLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM SYNC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamLatLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamLatLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//**
//*****************************************
//  STREAM SYNC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamJitLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamJitLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//  STREAM SYNC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamFcLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamFcLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//  STREAM IPV6 LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamIpv6Level (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamIpv6Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM RAMP LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamRampLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamRampLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM L1 LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL1Level (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL1Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L1:CUR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL1CurLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL1CurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L1:AVG LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL1AvgLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL1AvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L1:MAX LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL1MaxLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL1MaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L1:MIN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL1MinLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL1MinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM L2 LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL2Level (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL2Level, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L2:CUR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL2CurLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL2CurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L2:AVG LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL2AvgLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL2AvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L2:MAX LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL2MaxLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL2MaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       STRM:L2:MIN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamL2MinLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamL2MinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//  STREAM CUR LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamCurLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamCurLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM AVG LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamAvgLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamAvgLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM MAX LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamMaxLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamMaxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//  STREAM MIN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doStreamMinLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, streamMinLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// STRM:TAGGINGMODE? STRM
//***************************
void ScpiPacket::getTaggingMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAGGINGMODE? <strm>");
#endif

}

//***************************
// STRM:TAGGING STRM
//***************************
void ScpiPacket::setTaggingMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAGGING");
#endif

    int iStrmNum = 0;
    int iStreamRef = 0;
    int tagging = 0;

    LPTSTR parm;

    char seps[]   = " ";
    char *next_token;
    char *token;

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // Get updated pointer to rest of command line
    csScpiCmd = next_token;

    // Check if All Lane specified
    if(!csScpiCmd.CollateNoCase("VLAN"))
    {
        tagging = IDL_PACKET2_TAGGING_MASK_VLAN;
    }
    else
    {
        if(!csScpiCmd.CollateNoCase("MPLS"))
        {
            if (IsMplsLicensed())
                tagging = IDL_PACKET2_TAGGING_MASK_MPLS;
            else
                return;
        }
        else
        {
            if(!csScpiCmd.CollateNoCase("NONE"))
            {
                tagging = IDL_PACKET2_TAGGING_MASK_NONE;
            }
            else
            {
                // Invalid PARM
                m_pScpiProxyServer->reportError(ScpiProxyServer::ILLEGAL_PARAM_VALUE);
                return;
            }
        }
    }

    idlSettingsPacket.streamSet[iStrmNum].taggingMode = tagging;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_TAGGING;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:SYNC:SECS?
//***************************
void ScpiPacket::getStreamSyncSecs (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:SYNC:SECs?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    sprintf_s(buf, sizeof(buf),"%u", idlStreamStatPacket.streamStats[index].streamPatternSync.alarmSecs);//bert used patsync.alarmSecs
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// STRM:SYNC:STATE?
//***************************
void ScpiPacket::getStreamSyncState (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:SYNC:STATE?");
#endif

    //char buf[MAX_STR_SIZE];

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));


    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    CString csResult;

    if (idlStreamStatPacket.streamStats[index].streamPatternSync.ledState == 34)
        csResult = "ON";
    else
        csResult = "OFF";

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// STRM:TXPACKETS?
//***************************
void ScpiPacket::getTxStreamPackets (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TXPACKets?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStreamStatPacket.streamStats[index].txStreamPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// STRM:RXPACKETS?
//***************************
void ScpiPacket::getRxStreamPackets (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:RXPACKets?");
#endif
    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStreamStatPacket.streamStats[index].rxStreamPackets.count);
    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// STRM:RXLOSS?
//***************************
void ScpiPacket::getRxStreamLoss (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:RXLOSS?");
#endif
    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;
    UINT64 txPackets;
    UINT64 rxPackets;
    double lossRate = 0;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    CORBA::Any_var anyStructOnly=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    if (currentPacketAllowedSettings->streamAllowed[0].frameLossValid)
    {
        // Frame loss is an error.
        double fNum = (double) ((INT64) idlStreamStatPacket.streamStats[index].frameLoss.errCount);
        double fDen = (double) ((INT64) idlStreamStatPacket.streamStats[index].frameLoss.avgErrRateDen);
        if (fDen != 0)
            lossRate = fNum / fDen;
    }
    else
    {
        // Frame loss must be calculated from stream stats.
        txPackets = idlStreamStatPacket.streamStats[index].txStreamPackets.count;
        rxPackets = idlStreamStatPacket.streamStats[index].rxStreamPackets.count;

        if ((txPackets != 0) && (txPackets > rxPackets))
            lossRate = (double)((INT64) (txPackets - rxPackets)) /
                       (double)((INT64) txPackets);
    }

    sprintf_s(buf, sizeof(buf),"%1.2e", lossRate);
    m_pScpiProxyServer->setResultBuf(buf);
}



//***************************
// STRM:RXBW?
//***************************
void ScpiPacket::getRxStreamBw (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:RXBW?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    sprintf_s(buf, sizeof(buf),"%.2f %%", ((float)idlStreamStatPacket.streamStats[index].rxStreamPctBandwidth)/100);
    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// STRM:TXBW?
//***************************
void ScpiPacket::getTxStreamBw (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TXBW?");
#endif
    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    sprintf_s(buf, sizeof(buf),"%.2f %%", ((float)idlStreamStatPacket.streamStats[index].txStreamPctBandwidth)/100);
    m_pScpiProxyServer->setResultBuf(buf);
}


//***************************
// STRM:TXBYTES?
//***************************
void ScpiPacket::getTxStreamBytes (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TXBYTEs?");
#endif

    char buf[MAX_STR_SIZE];
    memset(buf,0,sizeof(buf));

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    sprintf_s(buf, sizeof(buf),"%I64u", idlStreamStatPacket.streamStats[index].txStreamBytes.count);
    m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// STRM:RXBYTES?
//***************************
void ScpiPacket::getRxStreamBytes (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:RXBYTEs?");
#endif
   char buf[MAX_STR_SIZE];
   memset(buf,0,sizeof(buf));

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

   // check the parameter

   // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

   // Get traffic generator number from the command string
   LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

   int index;

   char seps[]   = " ";
   char *next_token;
   char *token = strtok_s( parm, seps , &next_token);

   if (token == NULL)
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
       return;
   }

   // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

   sprintf_s(buf, sizeof(buf),"%I64u", idlStreamStatPacket.streamStats[index].rxStreamBytes.count);
   m_pScpiProxyServer->setResultBuf(buf);
}

//***************************
// STRM:LOSS:COUNT?
//***************************
void ScpiPacket::getStreamLossCount (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:LOSS:COUNT?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

   // check the parameter

   // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

   // Get traffic generator number from the command string

   LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

   int index;

   char seps[]   = " ";
   char *next_token;
   char *token = strtok_s( parm, seps , &next_token);

   if (token == NULL)
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
       return;
   }

   // validate traffic generator number parmaeter
   index = atoi(token) - 1;
   if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
       return;
   }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));


    if (packetAllowedSettings.streamAllowed[0].frameLossValid)
    {
        // Frame loss is an error.
        m_pScpiProxyServer->getErrCount(&idlStreamStatPacket.streamStats[index].frameLoss);
    }
    else
    {
        // Frame loss must be calculated from stream stats.
        UINT64 txPackets;
        UINT64 rxPackets;
        UINT64 lossCount = 0;
        char buf[MAX_STR_SIZE];

        txPackets = idlStreamStatPacket.streamStats[index].txStreamPackets.count;
        rxPackets = idlStreamStatPacket.streamStats[index].rxStreamPackets.count;

        if (txPackets > rxPackets)
            lossCount = txPackets - rxPackets;

        sprintf_s(buf, sizeof(buf),"%I64u", lossCount);
        m_pScpiProxyServer->setResultBuf(buf);
    }
}

//***************************
// STRM:LOSS:ES?
//***************************
void ScpiPacket::getStreamLossES (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:LOSS:ES?");
#endif
    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    m_pScpiProxyServer->getES(&idlStreamStatPacket.streamStats[index].frameLoss);
}

//***************************
// STRM:LOSS:AVGRATE?
//***************************
void ScpiPacket::getStreamLossAvgRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:LOSS:AVGRATE?");
#endif

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (packetAllowedSettings.streamAllowed[0].frameLossValid)
    {
        // Frame loss is an error.
        m_pScpiProxyServer->getAvgErrRate(&idlStreamStatPacket.streamStats[index].frameLoss);
    }
    else
    {
        // Frame loss must be calculated from stream stats.
        UINT64 txPackets;
        UINT64 rxPackets;
        double lossRate = 0;
        char buf[MAX_STR_SIZE];

        txPackets = idlStreamStatPacket.streamStats[index].txStreamPackets.count;
        rxPackets = idlStreamStatPacket.streamStats[index].rxStreamPackets.count;

        if ((txPackets != 0) && (txPackets > rxPackets))
            lossRate = (double)((INT64) (txPackets - rxPackets)) /
                       (double)((INT64) txPackets);

        sprintf_s(buf, sizeof(buf),"%1.2e", lossRate);
        m_pScpiProxyServer->setResultBuf(buf);
    }
}

//***************************
// STRM:LOSS:CURRATE?
//***************************
void ScpiPacket::getStreamLossCurRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:LOSS:CURRATE?");
#endif

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    m_pScpiProxyServer->getErrRate(&idlStreamStatPacket.streamStats[index].frameLoss);
}

//***************************
// STRM:LOSS:PERSEC?
//***************************
void ScpiPacket::getStreamLossPerSec (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:LOSS:PERSEC?");
#endif

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());
    int index;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    if (!packetAllowedSettings.streamAllowed[0].frameLossValid)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    CString csResult;
    csResult.Format("%I64u", idlStreamStat2Packet.streamStats[index].frameLossCntPerSec);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:SEQ:COUNT?
//***************************
void ScpiPacket::getStreamSeqCount (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:SEQ:COUNT?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

   // check the parameter

   // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

   // Get traffic generator number from the command string

   LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

   int index;

   char seps[]   = " ";
   char *next_token;
   char *token = strtok_s( parm, seps , &next_token);

   if (token == NULL)
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
       return;
   }

   // validate traffic generator number parmaeter
   index = atoi(token) - 1;
   if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
       return;
   }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStreamStatPacket.streamStats[index].streamSequence);
}

//***************************
// STRM:SEQ:ES?
//***************************
void ScpiPacket::getStreamSeqES (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:SEQ:ES?");
#endif
    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    m_pScpiProxyServer->getES(&idlStreamStatPacket.streamStats[index].streamSequence);
}

//***************************
// STRM:SEQ:AVGRATE?
//***************************
void ScpiPacket::getStreamSeqAvgRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:SEQ:AVGRATE?");
#endif

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    m_pScpiProxyServer->getAvgErrRate(&idlStreamStatPacket.streamStats[index].streamSequence);
}

//***************************
// STRM:SEQ:CURRATE?
//***************************
void ScpiPacket::getStreamSeqCurRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:SEQ:CURRATE?");
#endif

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    m_pScpiProxyServer->getErrRate(&idlStreamStatPacket.streamStats[index].streamSequence);
}

//***************************
// STRM:BIT:COUNT?
//***************************
void ScpiPacket::getStreamBitCount (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:BIT:COUNT?");
#endif

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        // validate traffic generator number parmaeter
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    m_pScpiProxyServer->getErrCount(&idlStreamStatPacket.streamStats[index].streamBit);
}

//***************************
// STRM:BIT:ES?
//***************************
void ScpiPacket::getStreamBitES (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BIT:ES?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)

    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
   m_pScpiProxyServer->getES(&idlStreamStatPacket.streamStats[index].streamBit);
}

//***************************
// STRM:BIT:AVGRATE?
//***************************
void ScpiPacket::getStreamBitAvgRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BIT:AVGRATE?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)

    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStreamStatPacket.streamStats[index].streamBit);
}

//***************************
// STRM:BIT:CURRATE?
//***************************
void ScpiPacket::getStreamBitCurRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BIT:CURRATE?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter

    // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)

    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // validate traffic generator number parmaeter
    if (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS)
    {
        index = atoi(token) - 1;
        if (index != 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }
    else
    {
        index = atoi(token) - 1;
        if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStreamStatPacket.streamStats[index].streamBit);
}

//***************************
// STRM:LAT:MIN?
//***************************
void ScpiPacket::getStreamLatMin (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:LAT:MIN?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

    csScpiCmd.TrimLeft(" ");

    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)

    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    CString csResult;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[index].latencyMin == -1)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[index].latencyMin / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[index].latencyMin / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[index].latencyMin / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[index].latencyMin);

   m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// STRM:LAT:MAX?
//***************************
void ScpiPacket::getStreamLatMax (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:LAT:MAX?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)

    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   CString csResult;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[index].latencyMin == -1)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[index].latencyMax / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[index].latencyMax / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[index].latencyMax / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[index].latencyMax);

   m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// STRM:LAT:AVG?
//***************************
void ScpiPacket::getStreamLatAvg (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:LAT:AVG?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter

    // remove spaces on ends of command string

   csScpiCmd.TrimLeft(" ");

   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string

    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)

    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

   IdlPacket2AllStreamStats idlStreamStatPacket;
   CString csResult;
   TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[index].latencyMin == -1)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[index].latencyAvg / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[index].latencyAvg / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[index].latencyAvg / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[index].latencyAvg);

   m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// STRM:LAT:CUR?
//***************************
void ScpiPacket::getStreamLatCur (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:LAT:CUR?");
#endif
    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;

    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int index;

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    index = atoi(token) - 1;
    if (IsStreamNumberInvalid(index, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats idlStreamStatPacket;
    CString csResult;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[index].latencyCurr == -1)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[index].latencyCurr / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[index].latencyCurr / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[index].latencyCurr / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[index].latencyCurr);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// STRM:PATTERN
//***************************
void ScpiPacket::setPattern (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:PATTERN ");
#endif

   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

/*
   IdlPacket2AllStreamSettings idlSettingsPacket;
   IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

   anyStructure <<= idlSettingsPacket;
   TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

*/

    DLI_UINT32 ulval = 0;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    int userFlag = 0;
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    // check second parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
   CString csNewString;
   CString csToken = token;
   if(!csToken.IsEmpty() && csToken != "")
   {
        if (!csToken.CollateNoCase("PRBS31"))
        {
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_31;
        }
        else if (!csToken.CollateNoCase("PRBS31INV"))
        {
            idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
            idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_31_INV;
        }
        else if (!csToken.CollateNoCase("PRBS23"))
        {
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_23;
        }
        else if (!csToken.CollateNoCase("PRBS23INV"))
        {
            idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
            idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_23_INV;
        }
        else if (!csToken.CollateNoCase("PRBS20"))
        {
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_20;
        }
        else if (!csToken.CollateNoCase("PRBS20INV"))
        {
            idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
            idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_20_INV;
        }
        else if (!csToken.CollateNoCase("PRBS15"))
        {
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_15;
        }
        else if (!csToken.CollateNoCase("PRBS15INV"))
        {
            idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
            idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_15_INV;
        }
        else if (!csToken.CollateNoCase("PRBS11"))
        {
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_11;
        }
        else if (!csToken.CollateNoCase("PRBS11INV"))
        {
            idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
            idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_11_INV;
        }
        else if (!csToken.CollateNoCase("PRBS9"))
        {
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_9;
        }
        else if (!csToken.CollateNoCase("PRBS9INV"))
        {
            idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
            idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_PRBS_9_INV;
        }
        else
        {  // user defined
           idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PATTERN;
           idlSettingsPacket.streamSet[iStrmNum].pattern = IDL_PACKET2_PATTERN_USER;
           userFlag = 1;
        }
   }
     else
     {
       m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
       return;
     }

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    // check if USER payload was selected
    if (userFlag)
    {

        // check if the parameter exists
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        csToken = token;
        if (csToken.Find('#') == 0)
        {
            if (csToken.Find("#b") == 0 || csToken.Find("#B") == 0)
            {
                csToken.TrimLeft("#");
                csToken.TrimLeft("#b");
                csToken.TrimLeft("#B");
                // check if the parameter still exists
                if (csToken.IsEmpty() || csToken == "")
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

                int bits = 0, tempInt = 0;
                CString csInt, csTempInt;

                bits = strlen(csToken);
                //looking for the string to be 32 bits long
                while (bits < 32)//if not 32 bits make it a little longer
                {
                    csToken += csToken;
                    bits = strlen(csToken);
                }

                token = (char *)(LPCTSTR) csToken;
                for (int index = 0; index < 8; index++)
                {
                    csInt = "";
                    for (int count4 = 0; count4 < 4; count4++)
                    {
                        csTempInt = token[(count4 + (index * 4))];
                        if (csTempInt == "1" || csTempInt == "0")
                            csInt += csTempInt;
                        else
                        {
                            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                            return;
                        }
                    }

                    if (csInt == "0000")//had to do if else vs switch case to preserve 4 char comparison.
                        csNewString += "0";
                    else if (csInt == "0001")
                        csNewString += "1";
                    else if (csInt == "0010")
                        csNewString += "2";
                    else if (csInt == "0011")
                        csNewString += "3";
                    else if (csInt == "0100")
                        csNewString += "4";
                    else if (csInt == "0101")
                        csNewString += "5";
                    else if (csInt == "0110")
                        csNewString += "6";
                    else if (csInt == "0111")
                        csNewString += "7";
                    else if (csInt == "1000")
                        csNewString += "8";
                    else if (csInt == "1001")
                        csNewString += "9";
                    else if (csInt == "1010")
                        csNewString += "a";
                    else if (csInt == "1011")
                        csNewString += "b";
                    else if (csInt == "1100")
                        csNewString += "c";
                    else if (csInt == "1101")
                        csNewString += "d";
                    else if (csInt == "1110")
                        csNewString += "e";
                    else if (csInt == "1111")
                        csNewString += "f";

                }//for index loop
                token = (char *)(LPCTSTR) csNewString;
            }else if (csToken.Find("#h") == 0 || csToken.Find("#H") == 0)
            {
                csToken.TrimLeft("#");
                csToken.TrimLeft("h");
                csToken.TrimLeft("H");
                // check if the parameter still exists
                if (csToken.IsEmpty() || csToken == "")
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }
                token = (char *)(LPCTSTR) csToken;
            }else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
        }

        // the data must be converted from ascii to unsigned long value
        ulval = static_cast<DLI_UINT32>(CUtils::hexAsciiIntoInt(token));

        // check the value to be within the limits
        if (ulval < STRMSETPAYLOAD_LOWERLIMIT || ulval > STRMSETPAYLOAD_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // put in the structure
        idlSettingsPacket.streamSet[iStrmNum].userPattern = ulval;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_USER_PATTERN;

        idlSettingsPacket.reference = iStreamRef;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    }


}

//***************************
// STRM:PATTERN?
//***************************
void ScpiPacket::getPattern (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:PATTERN?");
#endif

    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csPattern;

    switch(idlSettingsPacket.streamSet[iStrmNum].pattern)
    {
    case IDL_PACKET2_PATTERN_PRBS_31:
        m_pScpiProxyServer->scpiResults("PRBS31");
        break;
    case IDL_PACKET2_PATTERN_PRBS_31_INV:
        m_pScpiProxyServer->scpiResults("PRBS31INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_23:
        m_pScpiProxyServer->scpiResults("PRBS23");
        break;
    case IDL_PACKET2_PATTERN_PRBS_23_INV:
        m_pScpiProxyServer->scpiResults("PRBS23INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_20:
        m_pScpiProxyServer->scpiResults("PRBS20");
        break;
    case IDL_PACKET2_PATTERN_PRBS_20_INV:
        m_pScpiProxyServer->scpiResults("PRBS20INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_15:
        m_pScpiProxyServer->scpiResults("PRBS15");
        break;
    case IDL_PACKET2_PATTERN_PRBS_15_INV:
        m_pScpiProxyServer->scpiResults("PRBS15INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_11:
        m_pScpiProxyServer->scpiResults("PRBS11");
        break;
    case IDL_PACKET2_PATTERN_PRBS_11_INV:
        m_pScpiProxyServer->scpiResults("PRBS11INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_9:
        m_pScpiProxyServer->scpiResults("PRBS9");
        break;
    case IDL_PACKET2_PATTERN_PRBS_9_INV:
        m_pScpiProxyServer->scpiResults("PRBS9INV");
        break;
    case IDL_PACKET2_PATTERN_USER:
        csPattern.Format("#H%08x", idlSettingsPacket.streamSet[iStrmNum].userPattern);
        m_pScpiProxyServer->scpiResults(csPattern);
        break;
    default:
        m_pScpiProxyServer->scpiResults("UNKNOWN");
        break;
    }
}
////////////////////  FC ///////////////////////////////////

//***************************
// STRM:FC:WWNSOURCE
//***************************
void ScpiPacket::setFcMacsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MACSOURCE ");
#endif

    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    char    dash[] = "-";
    char    *cpAddr = strtok_s(parms, dash, &next_token);

    cpAddr = strtok_s(token, dash, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_SRC_MAC_ADDRESS;

    // loop to get all 6 address elements - should be separated by '-'
    do
    {
        if (cpAddr == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // convert the second parameter to integer
        addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));

        // check if value is in a valid range
        if (addr < STRMSETSRCMAC_LOWERLIMIT || addr > STRMSETSRCMAC_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // set the structure with the proper value and increment the count
        idlSettingsPacket.streamSet[iStrmNum].srcMacAddress[count++] = addr;

        //get the next byte
        cpAddr = strtok_s(NULL, dash, &next_token);

    }while (count < 8);

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:FC:WWNSOURCE?
//***************************
void ScpiPacket::getFcMacsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:MACSOURCE?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 8; i++)
    {
        csVal.Format("%x", idlSettingsPacket.streamSet[iStrmNum].srcMacAddress[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 7)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);

}

//***************************
// STRM:FC:MACDEST
//***************************
void ScpiPacket::setFcMacdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MACDEST ");
#endif

    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    char    dash[] = "-";
    char    *cpAddr = strtok_s(parms, dash, &next_token);

    cpAddr = strtok_s(token, dash, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_DST_MAC_ADDRESS;

    // loop to get all 6 address elements - should be separated by '-'
    do
    {
        if (cpAddr == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // convert the second parameter to integer
        addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));

        // check if value is in a valid range
        if (addr < STRMSETDESTMAC_LOWERLIMIT || addr > STRMSETDESTMAC_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // set the structure with the proper value and increment the count
        idlSettingsPacket.streamSet[iStrmNum].dstMacAddress[count++] = addr;

        //get the next byte
        cpAddr = strtok_s(NULL, dash, &next_token);
    }
    while (count < 8);

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:FC:WWNDEST?
//***************************
void ScpiPacket::getFcMacdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:MACDEST?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 8; i++)
    {
        csVal.Format("%x", idlSettingsPacket.streamSet[iStrmNum].dstMacAddress[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 7)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);

}


///////////////////////////////////////////////////////////



//***************************
// STRM:MACSOURCE
//***************************
void ScpiPacket::setMacsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MACSOURCE ");
#endif

    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;

    // check for 2 parameters
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int    addr;
    char   dash[] = "-";
    char   *cpAddr = strtok_s(parms, dash, &next_token);

    cpAddr = strtok_s(token, dash, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_SRC_MAC_ADDRESS;

    // loop to get all 6 address elements - should be separated by '-'
    do
    {
        if (cpAddr == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // convert the second parameter to integer
        addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));

        // check if value is in a valid range
        if (addr < STRMSETSRCMAC_LOWERLIMIT || addr > STRMSETSRCMAC_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // set the structure with the proper value and increment the count
        idlSettingsPacket.streamSet[iStrmNum].srcMacAddress[count++] = addr;

        //get the next byte
        cpAddr = strtok_s(NULL, dash, &next_token);
    }while (count < 6);

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:MACSOURCE?
//***************************
void ScpiPacket::getMacsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:MACSOURCE?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 6; i++)
    {
        csVal.Format("%x", idlSettingsPacket.streamSet[iStrmNum].srcMacAddress[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 5)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);

}

//***************************
// STRM:MACDEST
//***************************
void ScpiPacket::setMacdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MACDEST ");
#endif

    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    char    dash[] = "-";
    char    *cpAddr = strtok_s(parms, dash, &next_token);

    cpAddr = strtok_s(token, dash, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_DST_MAC_ADDRESS;

    // loop to get all 6 address elements - should be separated by '-'
    do
    {
        if (cpAddr == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // convert the second parameter to integer
        addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));

        // check if value is in a valid range
        if (addr < STRMSETDESTMAC_LOWERLIMIT || addr > STRMSETDESTMAC_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // set the structure with the proper value and increment the count
        idlSettingsPacket.streamSet[iStrmNum].dstMacAddress[count++] = addr;

        //get the next byte
        cpAddr = strtok_s(NULL, dash, &next_token);
    }while (count < 6);

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:MACDEST?
//***************************
void ScpiPacket::getMacdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:MACDEST?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 6; i++)
    {
        csVal.Format("%x", idlSettingsPacket.streamSet[iStrmNum].dstMacAddress[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 5)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);

}

//***************************
// STRM:IPV6:TRAFCLASS
//***************************
void ScpiPacket::setIpv6TrafClass (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTOS");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    if (idlSettingsPacket.streamSet[iStrmNum].ipType != 0x86DD)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int tos;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // convert the second parameter to integer
    tos = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    if ((tos < STRMSETIPTOS_LOWERLIMIT) || (tos > STRMSETIPTOS_UPPERLIMIT))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].ipv6trafficClass = tos;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IPV6TRAFFICCLASS;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPV6:TRAFCLASS?
//***************************
void ScpiPacket::getIpv6TrafClass (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TRAFCLASS?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%02X", idlSettingsPacket.streamSet[iStrmNum].ipv6trafficClass);

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:IPV6:NEXTHOP
//***************************
void ScpiPacket::setIpv6NextHop (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:NEXTHOP");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;



    if (idlSettingsPacket.streamSet[iStrmNum].ipType != 0x86DD)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int ttl;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    ttl = atoi(token);
    if ((ttl < STRMSETIPTTL_LOWERLIMIT) || (ttl > STRMSETIPTTL_UPPERLIMIT))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].ipv6nextHop = ttl;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IPV6NEXTHOP;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPV6:NEXTHOP?
//***************************
void ScpiPacket::getIpv6NextHop (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:NEXTHOP?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].ipv6nextHop);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:IPV6:FLOWCNTRL
//***************************
void ScpiPacket::setIpv6FlowControl (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:FLOWCNTRL");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    if (idlSettingsPacket.streamSet[iStrmNum].ipType != 0x86DD)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int ttl;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    ttl = static_cast<int>(atof(token));

    if ((ttl < 0) || (ttl > 1048575))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].ipv6flowControl = ttl;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IPV6FLOWCONTROL;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPV6:FLOWCNTRL?
//***************************
void ScpiPacket::getIpv6FlowControl (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:FLOWCNTRL?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].ipv6flowControl);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:IPV6:IPSOURCE?
//***************************
void ScpiPacket::getIpv6IpSourceAddress (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPSOURCE?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    int addr;
    int addr1;
    int addr2;
    CString csAddress;
    CString csVal;
    csAddress.Empty();
    int j = 0;
    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 8; i++)
    {
        addr = 0;
        addr1 = (idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[j] & 0x00FF) << 8;
        j++;
        addr2 = (idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[j]);
        j++;
        addr = addr1 + addr2;
        csVal.Format("%X", addr);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 7)
            csAddress += ':';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}

//***************************
// STRM:IPV6:IPSOURCE
//***************************
void ScpiPacket::setIpv6IpSourceAddress (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPSOURCE");
#endif

   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    int     addr1;
    int     addr2;
    char    period[] = ":";
    char    *cpAddr = strtok_s(parms, period, &next_token);

    cpAddr = strtok_s(token, period, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

     idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_SRC_IP_ADDRESS;


    // loop to get all 8 address elements - should be separated by '.'
        do
        {
            if (cpAddr == NULL)
            {
               // cpAddr = "0";
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
            // convert the second parameter to integer
            addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));
            // check if value is in a valid range
            if (addr < 0 || addr > 0xFFFF)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
            addr1 = (addr & 0xFF00) >> 8;
            addr2 = (addr & 0x00FF);
            // set the structure with the proper value and increment the count
            idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[count++] = addr1;
            idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[count++] = addr2;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 16);

        idlSettingsPacket.reference = iStreamRef;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// STRM:IPV6:IPDEST
//***************************
void ScpiPacket::setIpv6IpDestAddress (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPDEST");
#endif

   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    int     addr1;
    int     addr2;
    char    period[] = ":";
    char    *cpAddr = strtok_s(parms, period, &next_token);

    cpAddr = strtok_s(token, period, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

     idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_DST_IP_ADDRESS;


    // loop to get all 8 address elements - should be separated by '.'
        do
        {
            if (cpAddr == NULL)
            {
               // cpAddr = "0";
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
            // convert the second parameter to integer
            addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));
            // check if value is in a valid range
            if (addr < 0 || addr > 0xFFFF)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
            addr1 = (addr & 0xFF00) >> 8;
            addr2 = (addr & 0x00FF);
            // set the structure with the proper value and increment the count
            idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[count++] = addr1;
            idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[count++] = addr2;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 16);

        idlSettingsPacket.reference = iStreamRef;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPV6:IPDEST?
//***************************
void ScpiPacket::getIpv6IpDestAddress (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPDEST?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    int addr;
    int addr1;
    int addr2;
    CString csAddress;
    CString csVal;
    csAddress.Empty();
    int j = 0;
    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 8; i++)
    {
        addr = 0;
        addr1 = (idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[j] & 0x00FF) << 8;
        j++;
        addr2 = (idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[j]);
        j++;
        addr = addr1 + addr2;
        csVal.Format("%X", addr);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 7)
            csAddress += ':';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}


//***************************
// STRM:IPSOURCE
//***************************
void ScpiPacket::setIpsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPSOURCE");
#endif

   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    char    period[] = ".";
    char    *cpAddr = strtok_s(parms, period, &next_token);

    cpAddr = strtok_s(token, period, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

     idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_SRC_IP_ADDRESS;

// Should the IP version be checked?
//  CString csIPVer;
//  csIPVer.Format("%u", idlSettingsPacket.streamSet[iStrmNum].ipVersion);
//  m_pScpiProxyServer->scpiResults(csIPVer);


    // loop to get all 4 address elements - should be separated by '.'
        do
        {
                if (cpAddr == NULL)
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }


            // convert the second parameter to integer
            addr = atoi(cpAddr);

            // check if value is in a valid range
            if (addr < STRMSETSRCIP_LOWERLIMIT || addr > STRMSETSRCIP_UPPERLIMIT)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 4);

        idlSettingsPacket.reference = iStreamRef;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// STRM:IPSOURCE ?
//***************************
void ScpiPacket::getIpsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPSOURCE?");
#endif

   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 4; i++)
    {
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[i]);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 3)
            csAddress += '.';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}

//***************************
// STRM:IPDEST
//***************************
void ScpiPacket::setIpdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPDEST");
#endif

   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    char    period[] = ".";
    char    *cpAddr = strtok_s(parms, period, &next_token);

    cpAddr = strtok_s(token, period, &next_token);

    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

     idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_DST_IP_ADDRESS;

// Should the IP version be checked?
//  CString csIPVer;
//  csIPVer.Format("%u", idlSettingsPacket.streamSet[iStrmNum].ipVersion);
//  m_pScpiProxyServer->scpiResults(csIPVer);


    // loop to get all 4 address elements - should be separated by '.'
        do
        {
                if (cpAddr == NULL)
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }


            // convert the second parameter to integer
            addr = atoi(cpAddr);

            // check if value is in a valid range
            if (addr < STRMSETDESTIP_LOWERLIMIT || addr > STRMSETDESTIP_UPPERLIMIT)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 4);

        idlSettingsPacket.reference = iStreamRef;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// STRM:IPDEST ?
//***************************
void ScpiPacket::getIpdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:IPDEST?");
#endif
   //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 4; i++)
    {
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[i]);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 3)
            csAddress += '.';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}


//***************************
// STRM:PORTSOURCE
//***************************
void ScpiPacket::setPortsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:PORTSOURCE");
#endif
   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int portVal;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    portVal = atoi(token);

    if (portVal < STRMSETSRCPORT_LOWERLIMIT || portVal > STRMSETSRCPORT_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_SRC_UDP_PORT;

    idlSettingsPacket.streamSet[iStrmNum].srcUdpPort = portVal;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// STRM:PORTSOURCE ?
//***************************
void ScpiPacket::getPortsource (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:PORTSOURCE?");
#endif
    //validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
       return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

   // check the parameter
   // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].srcUdpPort);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:PORTDEST
//***************************
void ScpiPacket::setPortdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:PORTDEST");
#endif
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int portVal;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    portVal = atoi(token);

    if (portVal < STRMSETDESTPORT_LOWERLIMIT || portVal > STRMSETDESTPORT_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_DST_UDP_PORT;

    idlSettingsPacket.streamSet[iStrmNum].dstUdpPort = portVal;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// STRM:PORTDEST ?
//***************************
void ScpiPacket::getPortdest (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:PORTDEST?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].dstUdpPort);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// RX:FFCTOV?
//***************************
void ScpiPacket::getRxFcTov (CString& csScpiCmd)
{

    double temp;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();
    temp = (double)idlSettingsPacket.fcRxTimeout;

    // jkb - (VS2010) Change to double and removed fudge factor
    csVal.Format("%.2f", (temp/100.00));


    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// RX:FCTOV
//***************************
void ScpiPacket::setRxFcTov (CString& csScpiCmd)
{
    double fTov;
    int iTov;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parms;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    //IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());
    token = strtok_s( parms, seps , &next_token);


    // validate the string is digits only
    int i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {}else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
           return;
        }
        i++;
    }

    // Verify arg is with valid range
    fTov = atof(token);
    if (fTov < 0.01||fTov> 655.35)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iTov = static_cast<int>(fTov * 100);//to avoid decimal

    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_RX_TIMEOUT;

    // put the frame length into the structure
    idlSettingsPacket.fcRxTimeout = iTov;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

}



//***************************
// TX:FCPRIM
//***************************
void ScpiPacket::setTxFcPrim (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;



    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    //IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacket = *idlSettingsPacketPtr;
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());
    IdlFcPrimitive fcPrimitive;
    //int iTov;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    CString csTag;

    csTag = token;
    //unsigned long  value;
    if (!csTag.CollateNoCase("NOS"))
        fcPrimitive.value = 0x55BF45;
    else if (!csTag.CollateNoCase("LRR"))
        fcPrimitive.value = 0x35BF49;
    else if (!csTag.CollateNoCase("LR"))
        fcPrimitive.value = 0x49BF49;
    else if (!csTag.CollateNoCase("OLS"))
        fcPrimitive.value = 0x358A55;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);
    csTag = token;
    if (!csTag.CollateNoCase("CONT"))
        fcPrimitive.count = 255;
    else if (!csTag.CollateNoCase("OFF"))
        fcPrimitive.count = 0;
    else
    {
        fcPrimitive.count = atoi(token);
        if ((fcPrimitive.count < 1) || (fcPrimitive.count > 10))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_PRIMITIVE;

    // put the frame length into the structure
    idlSettingsPacket.fcPrimitive = fcPrimitive;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

}




//***************************
// STRM:FRAMESIZE
//***************************
void ScpiPacket::setFramesize (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:FRAMESIZE");
#endif
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Can't set packet size in ID337 mode.
    if (idlSettingsPacketOnly->emixMode == IDL_PACKET2_EMIX_ID337)
    {
        if (iStrmNum > 15)
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        else
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    iStreamRef = iStrmNum;

    int     frameLen      = 0;
    int     frameLenMax   = 0;
    UCHAR   frameSizeType     = IDL_PACKET2_FIXED;
    UINT16  frameSizeTypeMask = IDL_PACKET2_FIXED_MASK;
    CString csFrameSizeType;
    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }
    if (!isdigit(token[0]))
    {
        csFrameSizeType.Format("%s", token);
        if (!csFrameSizeType.CollateNoCase("FIXED"))
        {
            frameSizeType     = IDL_PACKET2_FIXED;
            frameSizeTypeMask = IDL_PACKET2_FIXED_MASK;
        }
        else if (!csFrameSizeType.CollateNoCase("DECR"))
        {
            frameSizeType     = IDL_PACKET2_DECREMENT;
            frameSizeTypeMask = IDL_PACKET2_DECREMENT_MASK;
        }
        else if (!csFrameSizeType.CollateNoCase("INCR"))
        {
            frameSizeType     = IDL_PACKET2_INCREMENT;
            frameSizeTypeMask = IDL_PACKET2_INCREMENT_MASK;
        }
        else if (!csFrameSizeType.CollateNoCase("RAND"))
        {
            frameSizeType     = IDL_PACKET2_RANDOM;
            frameSizeTypeMask = IDL_PACKET2_RANDOM_MASK;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::ILLEGAL_PARAM_VALUE);
            return;
        }
        if ((frameSizeType == IDL_PACKET2_DECREMENT) ||
            (frameSizeType == IDL_PACKET2_INCREMENT) ||
            (frameSizeType == IDL_PACKET2_RANDOM))
        {
            if ((currentPacketAllowedSettings->streamAllowed[iStrmNum].frameSizeTypesMask & frameSizeTypeMask) == 0)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        // get the second parameter
        token = strtok_s( NULL, seps , &next_token);

        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // validate the string is digits only
        len = strlen(token);

        for (i = 0; i < len; i++)
        {
            if (!isdigit(token[i]))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
        }
        // convert and check the frame length value
        frameLen = atoi(token);
        if ((frameSizeType == IDL_PACKET2_FIXED) &&
            ((frameLen < currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthLo) ||
             (frameLen > currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthHi)))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
        else if (((frameSizeType == IDL_PACKET2_DECREMENT) ||
                  (frameSizeType == IDL_PACKET2_INCREMENT) ||
                  (frameSizeType == IDL_PACKET2_RANDOM))      &&
                 ((frameLen < currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthLo) ||
                  (frameLen > (currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthHi - 1))))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
        
        if ((frameSizeType == IDL_PACKET2_DECREMENT) ||
            (frameSizeType == IDL_PACKET2_INCREMENT) ||
            (frameSizeType == IDL_PACKET2_RANDOM))
        {
            // get the third parameter
            token = strtok_s( NULL, seps , &next_token);

            if (token == NULL)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }

            // validate the string is digits only
            len = strlen(token);

            for (i = 0; i < len; i++)
            {
                if (!isdigit(token[i]))
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                    return;
                }
            }
            // convert and check the frame length value
            frameLenMax = atoi(token);
            if (((frameSizeType == IDL_PACKET2_DECREMENT) ||
                 (frameSizeType == IDL_PACKET2_INCREMENT) ||
                 (frameSizeType == IDL_PACKET2_RANDOM))      &&
                ((frameLenMax <= frameLen) ||
                 (frameLenMax > (currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthHi))))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                return;
            }
        }
    }
    else
    {
        // validate the string is digits only
        len = strlen(token);

        for (i = 0; i < len; i++)
        {
            if (!isdigit(token[i]))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
        }

        // convert and check the frame length value
        frameLen = atoi(token);

        if (frameLen < currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthLo ||
            frameLen > currentPacketAllowedSettings->streamAllowed[iStrmNum].packetLengthHi)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_LENGTH;

    // put the frame length into the structure
    idlSettingsPacket.streamSet[iStrmNum].length        = frameLen;
    // put the max frame length into the structure
    idlSettingsPacket.streamSet[iStrmNum].lengthMax     = frameLenMax;
    // put the frame size type into the structure
    idlSettingsPacket.streamSet[iStrmNum].frameSizeType = frameSizeType;


    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// STRM:FRAMESIZE?
//***************************
void ScpiPacket::getFramesize (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:FRAMESIZE?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parameter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    CString csValFrameSizeType;
    csVal.Empty();
    csValFrameSizeType.Empty();

    // Can't set packet size in ID337 mode.
    if (idlSettingsPacketOnly->emixMode == IDL_PACKET2_EMIX_ID337)
    {
        if (iStrmNum > 15)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
        csVal = "ID337";
    }
    else
    {
        if ((idlSettingsPacket.streamSet[iStrmNum].frameSizeType == IDL_PACKET2_DECREMENT) ||
            (idlSettingsPacket.streamSet[iStrmNum].frameSizeType == IDL_PACKET2_INCREMENT) ||
            (idlSettingsPacket.streamSet[iStrmNum].frameSizeType == IDL_PACKET2_RANDOM))
        {
            switch(idlSettingsPacket.streamSet[iStrmNum].frameSizeType)
            {
            case IDL_PACKET2_DECREMENT:
                csValFrameSizeType = "DECR";
                break;
            case IDL_PACKET2_INCREMENT:
                csValFrameSizeType = "INCR";
                break;
            case IDL_PACKET2_RANDOM:
                csValFrameSizeType = "RAND";
                break;
            }
            csVal.Format("%s %d %d", csValFrameSizeType, idlSettingsPacket.streamSet[iStrmNum].length, idlSettingsPacket.streamSet[iStrmNum].lengthMax);
        }
        else
            csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].length);
    }

    m_pScpiProxyServer->scpiResults(csVal);

}

//***************************
// STRM:BW
//***************************
void ScpiPacket::setBandwidth (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;




    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int bWidth;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        i++;
    }

    bWidth = static_cast<int>((atof(token) * 100) + 0.5);//to avoid decimal and make sure it rounds up if needed + 0.5

    if (bWidth > (int)currentPacketAllowedSettings->bandwidthHi || bWidth < (int)currentPacketAllowedSettings->bandwidthLo)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RATE;

    idlSettingsPacket.streamSet[iStrmNum].traffic = bWidth;
    idlSettingsPacket.streamSet[iStrmNum].trafficType = IDL_PACKET2_BW;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}



//***************************
// STRM:BW ?
//***************************
void ScpiPacket::getBandwidth (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:BANDWIDTH?");
#endif
//validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if( idlSettingsPacket.streamSet[iStrmNum].trafficType != IDL_PACKET2_BW)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    CString csVal;
    csVal.Empty();
    float temp = static_cast<float>(idlSettingsPacket.streamSet[iStrmNum].traffic);
    temp = temp / 100;
    csVal.Format("%.2f%%", temp);

    m_pScpiProxyServer->scpiResults(csVal);

}

//***************************
// STRM:BURST
//***************************
void ScpiPacket::setBurst (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BURST");
#endif
   int iStreamRef = 0;
   double maxBurstSize;
   // currently PacketAllowed isn't available so quick add is to calculate the value here using stats and settings
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CORBA::Any_var anyStructure=new CORBA::Any;

   IdlPacket2AllStreamSettings idlSettingsPacket;

   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);


    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    csScpiCmd = token;
    int iBurst = static_cast<int>(atof(csScpiCmd));

    CORBA::Any_var anyInStructure=new CORBA::Any;

    //IdlPacket2AllStreamSettings idlSettingsPacketIn;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtrIn;

    TestCmdGetStatus(callGetAllSettings(anyInStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyInStructure >>= idlSettingsPacketPtrIn))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtrIn;

    // currently PacketAllowed isn't available so quick add is to calculate the value here using stats and settings
//    maxBurstSize = (double)(((UINT64)idlStatPacket.lineDataRate * 10) / ((UINT64)(idlSettingsPacket.streamSet[iStrmNum].length+20)*8));
//    maxBurstSize = 2.0e9;
    maxBurstSize = (double) packetAllowedSettings.streamAllowed[iStrmNum].burstSizeHi;
    if (iBurst < 1 || iBurst > maxBurstSize)
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ALL;

    idlSettingsPacket.streamSet[iStrmNum].burstSize = iBurst;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// RES:FCS:COUNT?
//***************************
void ScpiPacket::getResFcsCount (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCS:COUNT?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrCount(&idlStatPacket.fcs);
}

//***************************
// RES:FCS:ES?
//***************************
void ScpiPacket::getResFcsES (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCS:ES?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getES(&idlStatPacket.fcs);
}

//***************************
// RES:FCS:AVGRATE?
//***************************
void ScpiPacket::getResFcsAvgRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCS:AVGRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.fcs);
}

//***************************
// RES:FCS:CURRATE?
//***************************
void ScpiPacket::getResFcsCurRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nRES:FCS:CURRATE?");
#endif

   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   m_pScpiProxyServer->getErrRate(&idlStatPacket.fcs);
}


//***************************
// STRM:BURST?
//***************************
void ScpiPacket::getBurst (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BURST?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].burstSize);

    m_pScpiProxyServer->scpiResults(csVal);

}



void ScpiPacket::setSof(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csScpiCmd = token;
    if (!csScpiCmd.CollateNoCase("SOFc1"))
        iD = IDL_SOFc1;
    if (!csScpiCmd.CollateNoCase("SOFi1"))
        iD = IDL_SOFi1;
    if (!csScpiCmd.CollateNoCase("SOFn1"))
        iD = IDL_SOFn1;
    if (!csScpiCmd.CollateNoCase("SOFi2"))
        iD = IDL_SOFi2;
    if (!csScpiCmd.CollateNoCase("SOFn2"))
        iD = IDL_SOFn2;
    if (!csScpiCmd.CollateNoCase("SOFi3"))
        iD = IDL_SOFi3;
    if (!csScpiCmd.CollateNoCase("SOFn3"))
        iD = IDL_SOFn3;
    if (!csScpiCmd.CollateNoCase("SOFc4"))
        iD = IDL_SOFc4;
    if (!csScpiCmd.CollateNoCase("SOFi4"))
        iD = IDL_SOFi4;
    if (!csScpiCmd.CollateNoCase("SOFn4"))
        iD = IDL_SOFn4;
    if (!csScpiCmd.CollateNoCase("SOFf"))
        iD = IDL_SOFf;

    idlSettingsPacket.fcSof = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_SOF;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

}

void ScpiPacket::getSof(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    int value = idlSettingsPacket.fcSof;
    switch( value )
    {
    case IDL_SOFc1: csVal.Format("SOFc1"); break;
    case IDL_SOFi1: csVal.Format("SOFi1"); break;
    case IDL_SOFn1: csVal.Format("SOFn1"); break;
    case IDL_SOFi2: csVal.Format("SOFi2"); break;
    case IDL_SOFn2: csVal.Format("SOFn2"); break;
    case IDL_SOFi3: csVal.Format("SOFi3"); break;
    case IDL_SOFn3: csVal.Format("SOFn3"); break;
    case IDL_SOFc4: csVal.Format("SOFc4"); break;
    case IDL_SOFi4: csVal.Format("SOFi4"); break;
    case IDL_SOFn4: csVal.Format("SOFn4"); break;
    case IDL_SOFf:  csVal.Format("SOFf"); break;
    }

    m_pScpiProxyServer->scpiResults(csVal);

}

void ScpiPacket::setEof(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csScpiCmd = token;

    if (!csScpiCmd.CollateNoCase("EOFt"))
        iD = IDL_EOFt;
    if (!csScpiCmd.CollateNoCase("EOFdt"))
        iD = IDL_EOFdt;
    if (!csScpiCmd.CollateNoCase("EOFa"))
        iD = IDL_EOFa;
    if (!csScpiCmd.CollateNoCase("EOFn"))
        iD = IDL_EOFn;
    if (!csScpiCmd.CollateNoCase("EOFni"))
        iD = IDL_EOFni;
    if (!csScpiCmd.CollateNoCase("EOFdti"))
        iD = IDL_EOFdti;
    if (!csScpiCmd.CollateNoCase("EOFrt"))
        iD = IDL_EOFrt;
    if (!csScpiCmd.CollateNoCase("EOFrti"))
        iD = IDL_EOFrti;

    idlSettingsPacket.fcEof = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_EOF;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


void ScpiPacket::getEof(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    switch (idlSettingsPacket.fcEof)
    {
    case IDL_EOFt:   csVal.Format("EOFt"); break;
    case IDL_EOFdt:  csVal.Format("EOFdt"); break;
    case IDL_EOFa:   csVal.Format("EOFa"); break;
    case IDL_EOFn:   csVal.Format("EOFn"); break;
    case IDL_EOFni:  csVal.Format("EOFni"); break;
    case IDL_EOFdti: csVal.Format("EOFdti"); break;
    case IDL_EOFrt:  csVal.Format("EOFrt"); break;
    case IDL_EOFrti: csVal.Format("EOFrti"); break;
    }

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setRctl(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcRctl = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_RCTL;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


void ScpiPacket::getRctl(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%02X", idlSettingsPacket.fcRctl);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setDid(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcDid = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_DID;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getDid(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%06X", idlSettingsPacket.fcDid);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setCsctl(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcCsctl = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_CSCTL;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getCsctl(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%02X", idlSettingsPacket.fcCsctl);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setSid(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcSid = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_SID;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getSid(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%06X", idlSettingsPacket.fcSid);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setType(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcType = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_TYPE;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


void ScpiPacket::getType(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%02X", idlSettingsPacket.fcType);

    m_pScpiProxyServer->scpiResults(csVal);
}


/////////////////////////////////////////////////////////
void ScpiPacket::setB2BCredit(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = atoi(token);

    idlSettingsPacket.fcB2bCredits = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_B2B_CREDITS;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


void ScpiPacket::getB2BCredit(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%d", idlSettingsPacket.fcB2bCredits);

    m_pScpiProxyServer->scpiResults(csVal);
}


////////////////////////////////////////////////////////
void ScpiPacket::setFctl(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcFctl = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_FCTL;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


void ScpiPacket::getFctl(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%06X", idlSettingsPacket.fcFctl);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setSeqid(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcSeqId = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_SEQID;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


void ScpiPacket::getSeqid(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%02X", idlSettingsPacket.fcSeqId);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setDfctl(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcDfCtl = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_DFCTL;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getDfctl(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%02X", idlSettingsPacket.fcDfCtl);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setOxid(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcOxid = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_OXID;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getOxid(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%04X", idlSettingsPacket.fcOxid);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setRxid(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcRxid= iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_RXID;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getRxid(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%04X", idlSettingsPacket.fcRxid);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setParm(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // convert the second parameter to integer
    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    idlSettingsPacket.fcParm = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_PARM;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getParm(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%08X", idlSettingsPacket.fcParm);

    m_pScpiProxyServer->scpiResults(csVal);
}


void ScpiPacket::setClass(CString& csScpiCmd)
{
    //int len;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iD;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    iD = atoi(token);
    if ((iD != 1) && (iD != 2) && (iD != 3))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    idlSettingsPacket.fcClass = iD;
    idlSettingsPacket.reference = IDL_PACKET2_REF_FC_CLASS;

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getClass(CString& csScpiCmd)
{
//validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    csVal.Format("%X", idlSettingsPacket.fcClass);

    m_pScpiProxyServer->scpiResults(csVal);
}





//***************************
// RX:TPID:STATE?
//***************************
void ScpiPacket::setRxTpidState (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get filter from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iFilter;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    // validate Filter Id
    if ((!strcmp(token, "A")) || (!strcmp(token,"a")) )
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    else    if ((!strcmp(token,"B")) || ((!strcmp(token,"b")) ))
        iFilter = 2;
    else    if ((!strcmp(token,"C")) || ((!strcmp(token,"c")) ))
        iFilter = 3;
    else    if ((!strcmp(token,"D")) || ((!strcmp(token,"d")) ))
        iFilter = 4;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    bool state = false;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }
    else if (!strcmp(token,"ON") || !strcmp(token,"on") || !strcmp(token,"On"))
    {
        state = true;
    }
    else if (!strcmp(token,"OFF") || !strcmp(token,"off") || !strcmp(token,"Off"))
    {
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.reference  = IDL_PACKET2_REF_VLAN_RX_NUM_FILTERS;
    switch(iFilter)
    {
    default:
    case 2:
        if (state)
            idlSettingsPacket.vlanNumFilters |= IDL_PACKET2_RX_TPID_MASK2;
        else
            idlSettingsPacket.vlanNumFilters &= ~IDL_PACKET2_RX_TPID_MASK2;
        break;
    case 3:
        if (state)
            idlSettingsPacket.vlanNumFilters |= IDL_PACKET2_RX_TPID_MASK3;
        else
            idlSettingsPacket.vlanNumFilters &= ~IDL_PACKET2_RX_TPID_MASK3;
        break;
    case 4:
        if (state)
            idlSettingsPacket.vlanNumFilters |= IDL_PACKET2_RX_TPID_MASK4;
        else
            idlSettingsPacket.vlanNumFilters &= ~IDL_PACKET2_RX_TPID_MASK4;
        break;
    }

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

}

//***************************
// RX:TPID:STATE?
//***************************
void ScpiPacket::getRxTpidState(CString& csScpiCmd)
{

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get filter from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iFilter;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }



    // validate Filter Id
    if ((!strcmp(token, "A")) || (!strcmp(token,"a")) )
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    else    if ((!strcmp(token,"B")) || ((!strcmp(token,"b")) ))
        iFilter = 2;
    else    if ((!strcmp(token,"C")) || ((!strcmp(token,"c")) ))
        iFilter = 3;
    else    if ((!strcmp(token,"D")) || ((!strcmp(token,"d")) ))
        iFilter = 4;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }



    switch(iFilter)
    {
    default:
    case 2:
        if (idlSettingsPacket.vlanNumFilters & IDL_PACKET2_RX_TPID_MASK2)
               m_pScpiProxyServer->scpiResults("ON");

        else
               m_pScpiProxyServer->scpiResults("OFF");
        break;
    case 3:
        if (idlSettingsPacket.vlanNumFilters & IDL_PACKET2_RX_TPID_MASK3)
               m_pScpiProxyServer->scpiResults("ON");

        else
               m_pScpiProxyServer->scpiResults("OFF");
        break;
    case 4:
        if (idlSettingsPacket.vlanNumFilters & IDL_PACKET2_RX_TPID_MASK4)
               m_pScpiProxyServer->scpiResults("ON");

        else
               m_pScpiProxyServer->scpiResults("OFF");
        break;

    }
}

//***************************
// RX:TPID:VALUE?
//***************************
void ScpiPacket::getRxTpidValue (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get filter from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iFilter;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    // validate Filter Id
    if ((!strcmp(token, "A")) || (!strcmp(token,"a")) )
        iFilter = 1;
    else    if ((!strcmp(token,"B")) || ((!strcmp(token,"b")) ))
        iFilter = 2;
    else    if ((!strcmp(token,"C")) || ((!strcmp(token,"c")) ))
        iFilter = 3;
    else    if ((!strcmp(token,"D")) || ((!strcmp(token,"d")) ))
        iFilter = 4;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString results;
    switch(iFilter)
    {
    default:
    case 1:
        results.Format("%X", idlSettingsPacket.vlanTpidRx1);
        break;
    case 2:
        results.Format("%X", idlSettingsPacket.vlanTpidRx2);
        break;
    case 3:
        results.Format("%X", idlSettingsPacket.vlanTpidRx3);
        break;
    case 4:
        results.Format("%X", idlSettingsPacket.vlanTpidRx4);
        break;

    }

    m_pScpiProxyServer->scpiResults(results);

}

//***************************
// RX:TPID:VALUE
//***************************
void ScpiPacket::setRxTpidValue (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get filter from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iFilter;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Filter Id
    if ((!strcmp(token, "A")) || (!strcmp(token,"a")) )
        iFilter = 1;
    else    if ((!strcmp(token,"B")) || ((!strcmp(token,"b")) ))
        iFilter = 2;
    else    if ((!strcmp(token,"C")) || ((!strcmp(token,"c")) ))
        iFilter = 3;
    else    if ((!strcmp(token,"D")) || ((!strcmp(token,"d")) ))
        iFilter = 4;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }


    // convert the second parameter to integer
    int tpid = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    if ((tpid < 0) || (tpid > 0xFFFF))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(iFilter)
    {
    default:
    case 1:
        idlSettingsPacket.reference  = IDL_PACKET2_REF_VLAN1_RX_TPID;
        idlSettingsPacket.vlanTpidRx1 = tpid;
        break;

    case 2:
        idlSettingsPacket.reference  = IDL_PACKET2_REF_VLAN2_RX_TPID;
        idlSettingsPacket.vlanTpidRx2 = tpid;
        break;

    case 3:
        idlSettingsPacket.reference  = IDL_PACKET2_REF_VLAN3_RX_TPID;
        idlSettingsPacket.vlanTpidRx3 = tpid;
        break;

    case 4:
        idlSettingsPacket.reference  = IDL_PACKET2_REF_VLAN4_RX_TPID;
        idlSettingsPacket.vlanTpidRx4 = tpid;
        break;

    }

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// STRM:VLANID
//***************************
void ScpiPacket::setVlanIdByLevel (CString& csScpiCmd, int Tagging, int Level)
{
#ifdef _MYDEBUG
    printf("\nSTRM:VLANDID");
#endif

    int len;
    int i;
    int iD;

    int iStrmNum = 0;
    int iStreamRef = 0;
    char seps[]   = " ";
    char *next_token;
    char *token;

    int lower_limits = STRMSETVLANID_LOWERLIMIT;
    int upper_limits = STRMSETVLANID_UPPERLIMIT;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    CORBA::Any_var anyStructure=new CORBA::Any;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parms, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    // get the id parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // MPLS ??
    if (Tagging == IDL_PACKET2_TAGGING_MASK_MPLS)
    {
        // the data must be converted from ascii to unsigned long value
        iD = atoi(token);

        lower_limits = 0;
        upper_limits = 255;
    }
    else
    {
        iD = atoi(token);

        // validate the string is digits only
        len = strlen(token);
        for (i = 0; i < len; i++)
        {
            if (!isdigit(token[i]))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
        }

    }

    // Check limits
    if (iD < lower_limits || iD > upper_limits)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch (Level)
    {
    case 1:
        idlSettingsPacket.streamSet[iStrmNum].vlanId = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN_ID;
        break;

    case 2:
        idlSettingsPacket.streamSet[iStrmNum].vlan2Id = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN2_ID;
        break;

    case 3:
        idlSettingsPacket.streamSet[iStrmNum].vlan3Id = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN3_ID;
        break;

    case 4:
        idlSettingsPacket.streamSet[iStrmNum].vlan4Id = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN4_ID;
        break;

    default:
        break;;
    }

//    idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:VLANID ?
//***************************
void ScpiPacket::getVlanIdByLevel (CString& csScpiCmd, int Tagging, int Level)
{
#ifdef _MYDEBUG
    printf("\nSTRM:VLANDID?");
#endif

    int iStrmNum;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    CString csVal;
    csVal.Empty();


    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    switch(Level)
    {
    case 1:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlanId);
        break;

    case 2:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan2Id);
        break;

    case 3:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan3Id);
        break;

    case 4:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan4Id);
        break;

    default:
        break;
    }

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:VLANQOS
//***************************
void ScpiPacket::setVlanQosByLevel (CString& csScpiCmd, int Tagging, int Level)
{
#ifdef _MYDEBUG
    printf("\nSTRM:VLANQOS");
#endif

    int len;
    int i;

    int iStreamRef = 0;
    int iStrmNum;
    int qos;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parms;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parms, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    // get next parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    qos = atoi(token);
    if (qos < STRMSETVLANQOS_LOWERLIMIT || qos > STRMSETVLANQOS_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(Level)
    {
    case 1:
        idlSettingsPacket.streamSet[iStrmNum].vlanQos = qos;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN_QOS;
        break;

    case 2:
        idlSettingsPacket.streamSet[iStrmNum].vlan2Qos = qos;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN2_QOS;
        break;

    case 3:
        idlSettingsPacket.streamSet[iStrmNum].vlan3Qos = qos;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN3_QOS;
        break;
    case 4:
        idlSettingsPacket.streamSet[iStrmNum].vlan4Qos = qos;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN4_QOS;
        break;

    default:
        return;

    }

//    idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:VLANQOS ?
//***************************
void ScpiPacket::getVlanQosByLevel (CString& csScpiCmd, int Tagging, int Level)
{
#ifdef _MYDEBUG
    printf("\nSTRM:VLANQOS?");
#endif

    int iStrmNum;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    CString csVal;
    csVal.Empty();


    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    switch(Level)
    {
    case 1:
        csVal.Format("%u", idlSettingsPacket.streamSet[iStrmNum].vlanQos);
        break;

    case 2:
        csVal.Format("%u", idlSettingsPacket.streamSet[iStrmNum].vlan2Qos);
        break;

    case 3:
        csVal.Format("%u", idlSettingsPacket.streamSet[iStrmNum].vlan3Qos);
        break;

    case 4:
        csVal.Format("%u", idlSettingsPacket.streamSet[iStrmNum].vlan4Qos);
        break;

    default:
        break;
    }

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:VLANCFI
//***************************
void ScpiPacket::setVlanCfiByLevel (CString& csScpiCmd, int Tagging, int Level)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    UCHAR cfi = atoi(token);

    if (cfi < 0 || cfi > 1)
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(Level)
    {
    case 1:
        idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi = cfi;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN1_CFI;
        break;

    case 2:
        idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi = cfi;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN2_CFI;
        break;

    case 3:
        idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi = cfi;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN3_CFI;
        break;

    case 4:
        idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi = cfi;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN4_CFI;
        break;

    default:
        return;

    }

//    idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:VLANCFI ?
//***************************
void ScpiPacket::getVlanCfiByLevel (CString& csScpiCmd, int Tagging, int Level)
{
    int iStrmNum;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    CString csVal;
    csVal.Empty();

    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    switch(Level)
    {
    case 1:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi);
        break;

    case 2:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi);
        break;

    case 3:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi);
        break;

    case 4:
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi);
        break;

    default:
        break;
    }
    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:VLANTPID
//***************************
void ScpiPacket::setVlanTpidByLevel (CString& csScpiCmd, int Tagging, int Level)
{
    int iStreamRef = 0;
    int tpid;
    int limit = 0xffff;

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for Stream
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parms, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    // get next parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // If MPLS then can limit for Label
    if (Tagging == IDL_PACKET2_TAGGING_MASK_MPLS)
    {
        limit = 0xfffff;
    }

    // convert the third parameter to integer
    tpid = static_cast<int>(CUtils::hexAsciiIntoInt(token));
    if (tpid < 0 || tpid > limit)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(Level)
    {
    case 1:
        idlSettingsPacket.streamSet[iStrmNum].vlan1Tpid = tpid;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN1_TPID;
        break;

    case 2:
        idlSettingsPacket.streamSet[iStrmNum].vlan2Tpid = tpid;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN2_TPID;
        break;

    case 3:
        idlSettingsPacket.streamSet[iStrmNum].vlan3Tpid = tpid;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN3_TPID;
        break;

    case 4:
        idlSettingsPacket.streamSet[iStrmNum].vlan4Tpid = tpid;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_VLAN4_TPID;
        break;

    default:
        return;

    }

    //idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:VLANTPID ?
//***************************
void ScpiPacket::getVlanTpidByLevel (CString& csScpiCmd, int Tagging, int Level)
{
    int iStrmNum;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parm;

    CString csVal;
    csVal.Empty();

    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Checking Tagging is enabled and current mode matches current command supplied mode
    if ((idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE) ||
    (idlSettingsPacket.streamSet[iStrmNum].taggingMode != Tagging))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // If Level if -1 then not Legacy VLAN command get level from command line
    if (Level == -1)
    {
        Level = 0;

        // get the second parameter - Level
        token = strtok_s( NULL, seps , &next_token);
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        Level = atoi (token);

        // Verify Level range
        if ((Level < 1) || (Level > 4))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }

    switch(Level)
    {
    case 1:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].vlan1Tpid);
        break;

    case 2:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].vlan2Tpid);
        break;

    case 3:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].vlan3Tpid);
        break;

    case 4:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].vlan4Tpid);
        break;

    default:
        break;
    }

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:TXENABLE
//***************************
void ScpiPacket::setTxEnable (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TXENABLE");
#endif
    int i;
    int iStreamRef = 0;
    int txEnable = IDL_ON_STATE;
    CString csTemp;
    int iStrmNum;
    int iNumStrms = 0;
    char seps[]   = " ,\t\n";
    char *token;
    char *next_token;

    UCHAR txEnableArr[32];
    bool strmChange[32];
    LPTSTR pScpiCmd;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    pScpiCmd = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    for (i = 0; i < 32; i++)
        strmChange[i] = false;

    // Fill an array with existing values
    for ( i = 0; i < 32; i++)
        txEnableArr[i] = idlSettingsPacket.streamSet[i].txRxEnable;

    token = strtok_s(pScpiCmd, seps, &next_token);
    while ( token != NULL )
    {
        csTemp.Format("%s",token);
        if (!csTemp.CollateNoCase("ALL") )
        {
            for (int i = 0; i < 32; i++)
                strmChange[i] = true;

            token = strtok_s(NULL, seps, &next_token);
            csTemp.Format("%s",token);
            iNumStrms = 32;
        }
        else
        {
            if (!csTemp.CollateNoCase("ON") )
            {
                token = NULL;
                txEnable = IDL_ON_STATE;
                break;
            }
            else
            {
                if  (!csTemp.CollateNoCase("OFF") )
                {
                    token = NULL;
                    txEnable = IDL_OFF_STATE;
                    break;
                }
                else
                {
                    iStrmNum = atoi(token) - 1;
                    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                        return;
                    }

                    strmChange[iStrmNum] = true;
                    token = strtok_s(NULL, seps, &next_token);
                    iNumStrms++;
                }
            }
        }
    }

    if ((txEnable != IDL_ON_STATE) && (txEnable != IDL_OFF_STATE))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    for (i = 0; i < 32; i++)
    {
         if (strmChange[i])
            txEnableArr[i] = txEnable;
         idlSettingsPacket.streamSet[i].txRxEnable = txEnableArr[i];
         idlSettingsPacket.streamSet[i].reference = IDL_PACKET2_STREAM_REF_TX_RX_ENABLE;
    }

    if (iNumStrms > 1)
        idlSettingsPacket.reference = 0xFF;
    else
        idlSettingsPacket.reference = iStrmNum;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:TXENABLE ?
//***************************
void ScpiPacket::getTxEnable (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TXENABLE?");
#endif
    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(idlSettingsPacket.streamSet[iStrmNum].txRxEnable == IDL_ON_STATE)
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
    }
    else
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
    }
}

//***************************
// STRM:IPMODE
//***************************
void ScpiPacket::setIpMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPMODE");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int ipMode;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    CString csToken;
    csToken = token;
    if (!csToken.CollateNoCase("IPV6"))
        ipMode = 0x86DD;
    else if (!csToken.CollateNoCase("IPV4"))
        ipMode = 0x800;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    if (currentPacketAllowedSettings->ipv6Valid == 0)
    {
        if (!csToken.CollateNoCase("IPV4"))
        {
            // Just fake it so Automation works
            m_pScpiProxyServer->ReportCmdSetStatus(IDL_SUCCESS);
            return;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ETHER_TYPE;

    if (idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_2)
        idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8000;
    else if (idlSettingsPacketPtr->streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_MPLS)
        idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8847;
    else
        idlSettingsPacket.streamSet[iStrmNum].etherType = ipMode;

    idlSettingsPacket.reference = iStreamRef;

    anyStructure<<=idlSettingsPacket;
    callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);

    idlSettingsPacket.streamSet[iStrmNum].ipType = ipMode;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IPTYPE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// STRM:IPMODE ?
//***************************
void ScpiPacket::getIpMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPMODE?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    if (idlSettingsPacket.streamSet[iStrmNum].ipType == 0x86DD)
        csVal.Format("%s", "IPV6");
    else
        csVal.Format("%s", "IPV4");
    m_pScpiProxyServer->scpiResults(csVal);
}


///////////////////////////////////////////////////////


//***************************
// STRM:ETYPE
//***************************
void ScpiPacket::setEtherType (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTOS");
#endif
    int iStreamRef = 0;
    /*
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;
*/

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    if (packetAllowedSettings.streamAllowed[0].etherTypeHi == 0)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int etherType;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // convert the second parameter to integer
    etherType = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    if ((etherType < 0) || (etherType > 0xFFFF))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    else if ((idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_4) &&
             (etherType != 0x0800)                                            &&
             (etherType != 0x86DD))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else if ((idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_2) &&
             ((etherType == 0x0800) ||
              (etherType == 0x86DD)))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].etherType = etherType;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ETHER_TYPE;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:ETYPE ?
//***************************
void ScpiPacket::getEtherType (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTOS?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%04X", idlSettingsPacket.streamSet[iStrmNum].etherType);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:IPTOS
//***************************
void ScpiPacket::setIpTos (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTOS");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    if (idlSettingsPacket.streamSet[iStrmNum].ipType == 0x86DD)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int tos;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // convert the second parameter to integer
    tos = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    if ((tos < STRMSETIPTOS_LOWERLIMIT) || (tos > STRMSETIPTOS_UPPERLIMIT))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].ipTos = tos;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IP_TOS;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPTOS ?
//***************************
void ScpiPacket::getIpTos (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTOS?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%02X", idlSettingsPacket.streamSet[iStrmNum].ipTos);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:IPTTL
//***************************
void ScpiPacket::setIpTtl (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTTL");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;


    if (idlSettingsPacket.streamSet[iStrmNum].ipType == 0x86DD)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int ttl;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only
    len = strlen(token);

    for (i = 0; i < len; i++)
    {
        if (!isdigit(token[i]))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
    }

    ttl = atoi(token);
    if ((ttl < STRMSETIPTTL_LOWERLIMIT) || (ttl > STRMSETIPTTL_UPPERLIMIT))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].ipTtl = ttl;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IP_TTL;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPTTL ?
//***************************
void ScpiPacket::getIpTtl (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPTTL?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].ipTtl);

    m_pScpiProxyServer->scpiResults(csVal);
}

//***************************
// STRM:IPFRAG
//***************************
void ScpiPacket::setIpFrag (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPFRAG");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    CString param;
    int frag;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    if (idlSettingsPacket.streamSet[iStrmNum].ipType == 0x86DD)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // convert the second parameter to integer
    param = token;
    if(!param.CollateNoCase("DISALLOW"))
        frag = 1;
    else if(!param.CollateNoCase("ALLOW"))
        frag = 0;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].ipDontFragmentFlag = frag;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_IP_DONT_FRAGMENT;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:IPFRAG ?
//***************************
void ScpiPacket::getIpFrag (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPFRAG?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    if (idlSettingsPacket.streamSet[iStrmNum].ipDontFragmentFlag)
        csVal = "DISALLOW";
    else
        csVal = "ALLOW";

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:TRAFFICLAYER
//***************************
void ScpiPacket::setTrafficLayer (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TRAFFICLAYER");
#endif
    int iStreamRef = 0;
    bool protocolChanged  = false;
    bool etherTypeChanged = false;
    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    UCHAR trafficLayer;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    CString csToken;
    csToken = token;
    if (!csToken.CollateNoCase("4"))
    {
        trafficLayer = IDL_PACKET2_TRAFFIC_LAYER_4;
        if ((idlSettingsPacketPtr->streamSet[iStrmNum].etherType != 0x0800) && //IPv4
            (idlSettingsPacketPtr->streamSet[iStrmNum].etherType != 0x86DD))   //IPv6
        {
            idlSettingsPacket.streamSet[iStrmNum].etherType = 0x0800;
            etherTypeChanged = true;
        }
    }
    else if (!csToken.CollateNoCase("3"))
    {
        trafficLayer = IDL_PACKET2_TRAFFIC_LAYER_3;
        if ((idlSettingsPacketPtr->streamSet[iStrmNum].protocol == IDL_PACKET2_PROTOCOL_TCP) ||
            (idlSettingsPacketPtr->streamSet[iStrmNum].protocol == IDL_PACKET2_PROTOCOL_UDP))
        {
            idlSettingsPacket.streamSet[iStrmNum].protocol = IDL_PACKET2_PROTOCOL_LAYER_3;
            protocolChanged = true;
        }
        if ((idlSettingsPacketPtr->streamSet[iStrmNum].etherType != 0x0800) && //IPv4
            (idlSettingsPacketPtr->streamSet[iStrmNum].etherType != 0x86DD))   //IPv6
        {
            idlSettingsPacket.streamSet[iStrmNum].etherType = 0x0800;
            etherTypeChanged = true;
        }
    }
    else if (!csToken.CollateNoCase("2"))
    {
        trafficLayer = IDL_PACKET2_TRAFFIC_LAYER_2;
        // IPv4/IPv6 not allowed when layer 2 for etherType within FPGA
        if ((idlSettingsPacketPtr->streamSet[iStrmNum].etherType == 0x0800) || //IPv4, required
            (idlSettingsPacketPtr->streamSet[iStrmNum].etherType == 0x86DD) || //IPv6, required
            (idlSettingsPacketPtr->streamSet[iStrmNum].etherType == 0x8847))   //MPLS, recommended
        {
            idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8000;
            etherTypeChanged = true;
        }
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    if ((trafficLayer != IDL_PACKET2_TRAFFIC_LAYER_3) &&
        (idlSettingsPacketPtr->streamSet[iStrmNum].protocol == IDL_PACKET2_PROTOCOL_LAYER_3))
    {
        idlSettingsPacket.streamSet[iStrmNum].protocol = IDL_PACKET2_PROTOCOL_UDP;
        protocolChanged = true;
    }

    // Set Stream Number
    idlSettingsPacket.reference = iStreamRef;

    if (protocolChanged)
    {
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PROTOCOL;
        anyStructure<<=idlSettingsPacket;
        callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);
    }
    if (etherTypeChanged)
    {
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ETHER_TYPE;
        anyStructure<<=idlSettingsPacket;
        callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);
    }

    idlSettingsPacket.streamSet[iStrmNum].reference    = IDL_PACKET2_STREAM_REF_TRAFFIC_LAYER;
    idlSettingsPacket.streamSet[iStrmNum].trafficLayer = trafficLayer;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// STRM:TRAFFICLAYER?
//***************************
void ScpiPacket::getTrafficLayer (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TRAFFICLAYER?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal = "4";
    if (idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_4)
        csVal.Format("%s", "4");
    else if (idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_3)
        csVal.Format("%s", "3");
    else if (idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_2)
        csVal.Format("%s", "2");
    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:PROTOCOL
//***************************
void ScpiPacket::setProtocol (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:PROTOCOL");
#endif
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    if (packetAllowedSettings.streamAllowed[0].etherTypeHi == 0)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    UCHAR protocol;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // convert the second parameter to integer
    protocol = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    if ((protocol < 0) || (protocol > 0xFF))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    else if (((protocol == IDL_PACKET2_PROTOCOL_UDP) &&
              ((packetAllowedSettings.streamAllowed[iStrmNum].protocolMask & IDL_PACKET2_PROTOCOL_UDP_MASK) != 0)) ||
             ((protocol == IDL_PACKET2_PROTOCOL_TCP) &&
              ((packetAllowedSettings.streamAllowed[iStrmNum].protocolMask & IDL_PACKET2_PROTOCOL_TCP_MASK) != 0)) ||
             ((protocol == IDL_PACKET2_PROTOCOL_ICMP) &&
              ((packetAllowedSettings.streamAllowed[iStrmNum].protocolMask & IDL_PACKET2_PROTOCOL_ICMP_MASK) != 0)) //||
             /*((protocol == IDL_PACKET2_PROTOCOL_LAYER_3) && // layer 3 uses this internally only, not selectable option
              ((packetAllowedSettings.streamAllowed[iStrmNum].protocolMask & IDL_PACKET2_PROTOCOL_LAYER_3_MASK) != 0))*/)
    {
        idlSettingsPacket.reference                     = iStreamRef;
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_PROTOCOL;
        idlSettingsPacket.streamSet[iStrmNum].protocol  = protocol;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
}


//***************************
// STRM:PROTOCOL?
//***************************
void ScpiPacket::getProtocol (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:PROTOCOL?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    csVal.Format("%02X", idlSettingsPacket.streamSet[iStrmNum].protocol);

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:DURATION
//***************************
void ScpiPacket::setTrafficDuration (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:PORTDEST");
#endif
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    CString param;
    int duration;
    int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    param = token;
    if(!param.CollateNoCase("CONTINUOUS"))
        duration = 0;
    else
    {
        // validate the string is digits only
        len = strlen(token);

        for (i = 0; i < len; i++)
        {
            if (!isdigit(token[i]))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
        }

        duration = atoi(token);
    }

    if (duration > packetAllowedSettings.streamAllowed[iStrmNum].trafficDurationHi)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_TRAFFIC_DURATION;
    idlSettingsPacket.streamSet[iStrmNum].trafficDuration = duration;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// STRM:DURATION?
//***************************
void ScpiPacket::getTrafficDuration (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:PORTDEST?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csVal;
    csVal.Empty();

    if (idlSettingsPacket.streamSet[iStrmNum].trafficDuration == 0)
        csVal = "Continuous";
    else
        csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].trafficDuration);

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:ARP
//***************************
void ScpiPacket::setArpEnable (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:IPFRAG");
#endif
    int iStreamRef = 0;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    CString param;
    int arpEnable;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // convert the second parameter to integer
    param = token;
    if(!param.CollateNoCase("ON"))
        arpEnable = 1;
    else if(!param.CollateNoCase("OFF"))
        arpEnable = 0;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].arpEnable = arpEnable;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ARP_ENABLE;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}

//***************************
// STRM:ARP ?
//***************************
void ScpiPacket::getArpEnable (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:ARP?");
#endif
    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CString csVal;
    if (idlSettingsPacket.streamSet[iStrmNum].arpEnable)
        csVal = "ON";
    else
        csVal = "OFF";

    m_pScpiProxyServer->scpiResults(csVal);
}




//***************************
// STRM:IPGM
//***************************
void ScpiPacket::setIpcgM (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;




    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    unsigned long bWidth;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        i++;
    }

    bWidth = (unsigned long) atoi(token);//to avoid decimal

    if ((bWidth > currentPacketAllowedSettings->ipgCodeHi) ||
        (bWidth < currentPacketAllowedSettings->ipgCodeLo))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RATE;

    idlSettingsPacket.streamSet[iStrmNum].traffic = bWidth;
    idlSettingsPacket.streamSet[iStrmNum].trafficType = IDL_PACKET2_IPG_MS;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}



//***************************
// STRM:IPGM ?
//***************************
void ScpiPacket::getIpcgM(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if( idlSettingsPacket.streamSet[iStrmNum].trafficType != IDL_PACKET2_IPG_MS)
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      return;
   }


    CString csVal;
    csVal.Empty();
    int temp = idlSettingsPacket.streamSet[iStrmNum].traffic;
    csVal.Format("%u", temp);

    m_pScpiProxyServer->scpiResults(csVal);

}



//***************************
// STRM:IPGB
//***************************
void ScpiPacket::setIpcgC (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;



    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    unsigned long bWidth;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        i++;
    }

    bWidth = (unsigned long) atoi(token);//to avoid decimal

    if ((bWidth > currentPacketAllowedSettings->ipgCodeHi) ||
        (bWidth < currentPacketAllowedSettings->ipgCodeLo))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RATE;

    idlSettingsPacket.streamSet[iStrmNum].traffic = bWidth;
    idlSettingsPacket.streamSet[iStrmNum].trafficType = IDL_PACKET2_IPG_CODE;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}



//***************************
// STRM:IPCG ?
//***************************
void ScpiPacket::getIpcgC(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if( idlSettingsPacket.streamSet[iStrmNum].trafficType != IDL_PACKET2_IPG_CODE)
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      return;
   }


    CString csVal;
    csVal.Empty();
    int temp = idlSettingsPacket.streamSet[iStrmNum].traffic;
    csVal.Format("%u", temp);

    m_pScpiProxyServer->scpiResults(csVal);

}



//////////////////////////////////////////////////////

//***************************
// STRM:MBPS
//***************************
void ScpiPacket::setMbps (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;



    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    unsigned long bWidth = 0;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        i++;
    }

    bWidth = static_cast<unsigned long>((double)atof(token) * 1000.0 + 0.5);//to avoid decimal

    if (bWidth > (int)currentPacketAllowedSettings->mbpsHi || bWidth < (int)currentPacketAllowedSettings->mbpsLo)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RATE;

    idlSettingsPacket.streamSet[iStrmNum].traffic = bWidth;
    idlSettingsPacket.streamSet[iStrmNum].trafficType = IDL_PACKET2_MBPS;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}



//***************************
// STRM:MBPS ?
//***************************
void ScpiPacket::getMbps(CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if( idlSettingsPacket.streamSet[iStrmNum].trafficType != IDL_PACKET2_MBPS)
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      return;
   }


    CString csVal;
    csVal.Empty();
   // float temp = idlSettingsPacket.streamSet[iStrmNum].traffic / 1000;

    csVal.Format("%.3fMb/s", (double)idlSettingsPacket.streamSet[iStrmNum].traffic / 1000);

    m_pScpiProxyServer->scpiResults(csVal);

}


//***************************
// STRM:RAMP:CEILMBPS
//***************************
void ScpiPacket::setRampMbps (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    unsigned long bWidth;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        i++;
    }

    bWidth = (unsigned long)(atof(token) * 1000.0 + 0.5);

    if ((bWidth > currentPacketAllowedSettings->bandwidthHi) ||
        (bWidth < currentPacketAllowedSettings->bandwidthLo))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RATE;
    idlSettingsPacket.streamSet[iStrmNum].traffic = bWidth;
    idlSettingsPacket.streamSet[iStrmNum].trafficType = IDL_PACKET2_RAMP_MBPS;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}



//***************************
// STRM:RAMP:PEAKMBPS?
//***************************
void ScpiPacket::getRampMbps (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if( idlSettingsPacket.streamSet[iStrmNum].trafficType != IDL_PACKET2_RAMP_MBPS)
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      return;
   }


    CString csVal;
    csVal.Empty();
    double temp;
    switch (idlSettingsPacket.streamSet[iStrmNum].trafficType)
    {
    case IDL_PACKET2_RAMP_BW:
        temp = ((double)idlSettingsPacket.streamSet[iStrmNum].traffic)/100.0;
        csVal.Format("%.2f%%", temp);
        break;
    case IDL_PACKET2_RAMP_MBPS:
        temp = ((double)idlSettingsPacket.streamSet[iStrmNum].traffic)/1000.0;
        csVal.Format("%.3f", temp);
        break;
    default:
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
       return;
        break;
    }

    m_pScpiProxyServer->scpiResults(csVal);

}



//***************************
// STRM:RAMP:PEAK
//***************************
void ScpiPacket::setRampBw (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;



    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int bWidth;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }
        i++;
    }

    bWidth = static_cast<int>(atof(token) * 100 + 0.5);//to avoid decimal

    if (bWidth > (int)currentPacketAllowedSettings->bandwidthHi || bWidth < (int)currentPacketAllowedSettings->bandwidthLo)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RATE;

    idlSettingsPacket.streamSet[iStrmNum].traffic = bWidth;
    idlSettingsPacket.streamSet[iStrmNum].trafficType = IDL_PACKET2_RAMP_BW;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}



//***************************
// STRM:RAMP:PEAK?
//***************************
void ScpiPacket::getRampBw (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if( idlSettingsPacket.streamSet[iStrmNum].trafficType != IDL_PACKET2_RAMP_BW)
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
      return;
   }


    CString csVal;
    csVal.Empty();
    double temp;
    switch (idlSettingsPacket.streamSet[iStrmNum].trafficType)
    {
    case IDL_PACKET2_RAMP_BW:
        temp = ((double)idlSettingsPacket.streamSet[iStrmNum].traffic)/100.0;
        csVal.Format("%.2f%%", temp);
        break;
    case IDL_PACKET2_RAMP_MBPS:
        temp = ((double)idlSettingsPacket.streamSet[iStrmNum].traffic)/1000.0;
        csVal.Format("%.3f", temp);
        break;
    default:
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
       return;
        break;
    }


    m_pScpiProxyServer->scpiResults(csVal);

}



//***************************
// STRM:RAMP:STOP
//***************************
void ScpiPacket::setRampStop (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int bWidth;
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        i++;
    }

    //bWidth = atof(token);//to avoid decimal
    switch (idlSettingsPacket.streamSet[iStrmNum].trafficType)
    {
    case IDL_PACKET2_RAMP_BW:
        bWidth = (unsigned long)(atof(token) * 100.0 + 0.5);
        break;

    case IDL_PACKET2_RAMP_MBPS:
        bWidth = (unsigned long)(atof(token) * 1000.0 + 0.5);
        break;

    default:
        break;
    }

    if (bWidth > (idlSettingsPacket.streamSet[iStrmNum].traffic - .01) ||
        bWidth < (currentPacketAllowedSettings->streamAllowed[iStrmNum].rampLowRateLo ))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RAMP;

    idlSettingsPacket.streamSet[iStrmNum].rampStartRate = bWidth;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}



//***************************
// STRM:RAMP:STOP?
//***************************
void ScpiPacket::getRampStop (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;



    CString csVal;
    csVal.Empty();
    double temp;
    switch (idlSettingsPacket.streamSet[iStrmNum].trafficType)
    {
    case IDL_PACKET2_RAMP_BW:
        temp = ((double)idlSettingsPacket.streamSet[iStrmNum].rampStartRate)/100.0;
        csVal.Format("%.2f%%", temp);
        break;
    case IDL_PACKET2_RAMP_MBPS:
        temp = ((double)idlSettingsPacket.streamSet[iStrmNum].rampStartRate)/1000.0;
        csVal.Format("%.3f", temp);
        break;
    default:
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
       return;
        break;
    }


    m_pScpiProxyServer->scpiResults(csVal);

}





//***************************
// STRM:RAMP:STEP
//***************************
void ScpiPacket::setRampStep (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    unsigned long bWidth = 0;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    // validate the string is digits only

    i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {}else
          {
              m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
              return;
          }
        i++;
    }

    //bWidth = (unsigned long)(atof(token));
    switch (idlSettingsPacket.streamSet[iStrmNum].trafficType)
    {
    case IDL_PACKET2_RAMP_BW:
        bWidth = (unsigned long)(atof(token) * 100.0 + 0.5);
        break;
    case IDL_PACKET2_RAMP_MBPS:
        bWidth = (unsigned long)(atof(token) * 1000.0 + 0.5);
        break;
    default:
        break;
    }

    double temp;
    temp = (double)     (idlSettingsPacket.streamSet[iStrmNum].traffic -
                         idlSettingsPacket.streamSet[iStrmNum].rampStartRate);


    if (bWidth > ((double)  (idlSettingsPacket.streamSet[iStrmNum].traffic -
                             idlSettingsPacket.streamSet[iStrmNum].rampStartRate))||
        bWidth < ((double) currentPacketAllowedSettings->streamAllowed[iStrmNum].rampStepRateLo ))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RAMP;



    idlSettingsPacket.streamSet[iStrmNum].rampStepSize = bWidth;


    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}



//***************************
// STRM:RAMP:STEP?
//***************************
void ScpiPacket::getRampStep (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:BANDWIDTH?");
#endif
//validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    CString csVal;
    csVal.Empty();
    float temp;
    switch (idlSettingsPacket.streamSet[iStrmNum].trafficType)
    {
    case IDL_PACKET2_RAMP_BW:
        temp = static_cast<float>(((double)idlSettingsPacket.streamSet[iStrmNum].rampStepSize)/100.0);
        csVal.Format("%.2f%%", temp);
        break;

    case IDL_PACKET2_RAMP_MBPS:
        temp = static_cast<float>(((double)idlSettingsPacket.streamSet[iStrmNum].rampStepSize)/1000.0);
        csVal.Format("%.3f", temp);
        break;

    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
        break;
    }
    m_pScpiProxyServer->scpiResults(csVal);

}





//***************************
// STRM:RAMP:DUR
//***************************
void ScpiPacket::setRampDur (CString& csScpiCmd)
{
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;



    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings  packetAllowedSettings;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    else
        packetAllowedSettings = *currentPacketAllowedSettings;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, idlSettingsPacketTmp, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    int bWidth;
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // validate the string is digits only

        i = 0;
        while (token[i] != NULL)
        {
            if (isdigit(token[i]) || (token[i] == '.'))
            {}else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
               return;
            }
            i++;
        }

        bWidth = atoi(token);//to avoid decimal

        if (bWidth > currentPacketAllowedSettings->streamAllowed[iStrmNum].rampStepTimeHi ||
            bWidth < currentPacketAllowedSettings->streamAllowed[iStrmNum].rampStepTimeLo)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }

        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_RAMP;

        idlSettingsPacket.streamSet[iStrmNum].rampStepDuration = bWidth;


        idlSettingsPacket.reference = iStreamRef;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));


}



//***************************
// STRM:RAMP:DUR?
//***************************
void ScpiPacket::getRampDur (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:BANDWIDTH?");
#endif
//validation
   if(csScpiCmd.IsEmpty() || csScpiCmd == "")
   {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
   }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

      // check the parameter
    // remove spaces on ends of command string
   csScpiCmd.TrimLeft(" ");
   csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;



    CString csVal;
    csVal.Empty();
    int temp = idlSettingsPacket.streamSet[iStrmNum].rampStepDuration;
    csVal.Format("%d", temp);

    m_pScpiProxyServer->scpiResults(csVal);

}



void ScpiPacket::setRampUom (CString& csScpiCmd) {;}
void ScpiPacket::getRampUom (CString& csScpiCmd) {;}


//*****************************************
// STRM:SET?
//*****************************************
void ScpiPacket::getStrmSet (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:SET?");
#endif

    int i;
    CString csTemp = "";
    CString csBuf = "";
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    for (int iStrmNum = 0; iStrmNum < packetAllowedSettings.numStreams; iStrmNum++)
    {
        // STRM:PATTERN?
        switch(idlSettingsPacket.streamSet[iStrmNum].pattern)
        {
        case IDL_PACKET2_PATTERN_PRBS_31:
            csTemp = "PRBS31";
            break;
        case IDL_PACKET2_PATTERN_PRBS_31_INV:
            csTemp = "PRBS31INV";
            break;
        case IDL_PACKET2_PATTERN_PRBS_23:
            csTemp = "PRBS23";
            break;
        case IDL_PACKET2_PATTERN_PRBS_23_INV:
            csTemp = "PRBS23INV";
            break;
        case IDL_PACKET2_PATTERN_PRBS_20:
            csTemp = "PRBS20";
            break;
        case IDL_PACKET2_PATTERN_PRBS_20_INV:
            csTemp = "PRBS20INV";
            break;
        case IDL_PACKET2_PATTERN_PRBS_15:
            csTemp = "PRBS15";
            break;
        case IDL_PACKET2_PATTERN_PRBS_15_INV:
            csTemp = "PRBS15INV";
            break;
        case IDL_PACKET2_PATTERN_PRBS_11:
            csTemp = "PRBS11";
            break;
        case IDL_PACKET2_PATTERN_PRBS_11_INV:
            csTemp = "PRBS11INV";
            break;
        case IDL_PACKET2_PATTERN_PRBS_9:
            csTemp = "PRBS9";
            break;
        case IDL_PACKET2_PATTERN_PRBS_9_INV:
            csTemp = "PRBS9INV";
            break;
        case IDL_PACKET2_PATTERN_USER:
            csTemp.Format("#H%08x", idlSettingsPacket.streamSet[iStrmNum].userPattern);
            break;
        default:
            csTemp = "UNKNOWN";
            break;
        }
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:MACSOURCE?
        CString csAddress;
        CString csVal;
        csAddress.Empty();
        // get the next 5 bytes and concatenate into a string delimited by a '-'
        for (i = 0; i < 6; i++)
        {
            csVal.Format("%x", idlSettingsPacket.streamSet[iStrmNum].srcMacAddress[i] & 0xff);
            csAddress += csVal;

            // add delimiter between bytes but not at the end.
            if (i < 5)
                csAddress += '-';
        }

        csTemp = csAddress;
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:MACDEST?
        csAddress.Empty();
        // get the next 5 bytes and concatenate into a string delimited by a '-'
        for (i = 0; i < 6; i++)
        {
            csVal.Format("%x", idlSettingsPacket.streamSet[iStrmNum].dstMacAddress[i] & 0xff);
            csAddress += csVal;
            // add delimiter between bytes but not at the end.
            if (i < 5)
                csAddress += '-';
        }

        csTemp = csAddress;
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:IPSOURCE ?
        csAddress.Empty();
        // get the next 5 bytes and concatenate into a string delimited by a '.'
        for (i = 0; i < 4; i++)
        {
            csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].srcIpAddress[i]);
            csAddress += csVal;
            // add delimiter between bytes but not at the end.
            if (i < 3)
                csAddress += '.';
        }

        csTemp = csAddress;
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:IPDEST ?
        csAddress.Empty();
        // get the next 5 bytes and concatenate into a string delimited by a '.'
        for (i = 0; i < 4; i++)
        {
            csVal.Format("%d", idlSettingsPacket.streamSet[iStrmNum].dstIpAddress[i]);
            csAddress += csVal;
            // add delimiter between bytes but not at the end.
            if (i < 3)
                csAddress += '.';
        }

        csTemp = csAddress;
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:PORTSOURCE ?
        csTemp.Format("%d", idlSettingsPacket.streamSet[iStrmNum].srcUdpPort);
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:PORTDEST ?
        csTemp.Format("%d", idlSettingsPacket.streamSet[iStrmNum].dstUdpPort);
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:FRAMESIZE ?
        csTemp.Format("%d", idlSettingsPacket.streamSet[iStrmNum].length);
        csBuf += "\"" + csTemp + "\"" + ",";

        // STRM:BW ?
        float temp = static_cast<float>((idlSettingsPacket.streamSet[iStrmNum].traffic) / 100);
        csTemp.Format("%.2f%%", temp);
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:BURST ?
        csTemp.Format("%d", idlSettingsPacket.streamSet[iStrmNum].traffic);
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:VLAN:TAG?
        if(idlSettingsPacket.streamSet[iStrmNum].vlanEnable == IDL_ON_STATE)
            csTemp = csOnOFF[IDL_ON_STATE];
        else
            csTemp = csOnOFF[IDL_OFF_STATE];
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:VLANID ?
        csTemp.Format("%d", idlSettingsPacket.streamSet[iStrmNum].vlanId);
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:VLANQOS ?
        csTemp.Format("%u", idlSettingsPacket.streamSet[iStrmNum].vlanQos);
        csBuf += "\"" + csTemp + "\"" + ",";


        // STRM:TXENABLE ?
        if(idlSettingsPacket.streamSet[iStrmNum].txRxEnable == IDL_ON_STATE)
            csTemp = csOnOFF[IDL_ON_STATE];
        else
            csTemp = csOnOFF[IDL_OFF_STATE];
        csBuf += "\"" + csTemp + "\"" + ",";
    }

    //csBuf.Delete(csBuf.ReverseFind(','));  //Remove last comma and add a single pipe.
    csBuf += " |";
    m_pScpiProxyServer->m_queryFlag = true;
    m_pScpiProxyServer->scpiResults(csBuf);
}


//*****************************************
// STRM:TAG LEVEL PROCESSING
//*****************************************
void ScpiPacket::doTagLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, streamTagLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// STRM:TAG:VLAN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doTagMpls (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, streamMplsLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// STRM:TAG:VLAN LEVEL PROCESSING
//*****************************************
void ScpiPacket::doTagVlan (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, streamVlanLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
// STRM:TAG:CUSTOM LEVEL PROCESSING
//*****************************************
void ScpiPacket::doTagCustom (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, streamCustomLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// STRM:VLANTAG
//***************************
void ScpiPacket::setVlanTag (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:VLANTAG <strm> <tag>");
#endif
   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char *next_token;
    char seps[]   = " ";
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if(token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csScpiCmd = token;
    if (!csScpiCmd.CollateNoCase("ON"))
    {
        idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_VLAN;
        idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    }
    else if (!csScpiCmd.CollateNoCase("OFF"))
    {
        idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 0;
        idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_NONE;
    }
    else if ((atoi(token) > 0) && (atoi(token) <= 4))
    {
        idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_VLAN;
        idlSettingsPacket.streamSet[iStrmNum].vlanEnable = atoi(token);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ALL;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:VLAN:TAG?
//***************************
void ScpiPacket::getVlanTag (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:VLAN:TAG? <strm>");
#endif
    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char *next_token;
    char seps[]   = " ";
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   CString csTag;
   csTag.Format("Tag_Level%d",idlSettingsPacket.streamSet[iStrmNum].vlanEnable);
   if(idlSettingsPacket.streamSet[iStrmNum].vlanEnable == IDL_OFF_STATE)
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csTag);
   }

}

//***************************
// STRM:TAG:MODE?
//***************************
void ScpiPacket::getTagMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAG:MODE <strm> <mode>");
#endif
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    CString csTag;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
       m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   csTag = "";

   switch (idlSettingsPacket.streamSet[iStrmNum].taggingMode)
   {
   case IDL_PACKET2_TAGGING_MASK_MPLS:
   {
       csTag = "MPLS";
       break;
   }

   case IDL_PACKET2_TAGGING_MASK_VLAN:
   {
       csTag = "VLAN";
       break;
   }

   // IDL_PACKET2_TAGGING_MASK_NONE:
   default:
   {
       csTag = "NONE";
       break;
   }

   }

   m_pScpiProxyServer->scpiResults(csTag);

}

//***************************
// STRM:TAG:MODE
//***************************
void ScpiPacket::setTagMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:TAG:MODE <strm> <mode>");
#endif

    int iStreamRef = 0;
    int iStrmNum;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parms;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if(token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    //if (idlSettingsPacketPtr->streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_MPLS)
    //    idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8847;
    //else
    //    idlSettingsPacket.streamSet[iStrmNum].etherType = ipMode;

    //anyStructure<<=idlSettingsPacket;
    //callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);


    csScpiCmd = token;
    if (!csScpiCmd.CollateNoCase("NONE"))
    {
        idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_NONE;
        idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 0;
        if (idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_2)
            idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8000;
        else
            idlSettingsPacket.streamSet[iStrmNum].etherType = idlSettingsPacket.streamSet[iStrmNum].ipType;
    }
    else
    {
        if (!csScpiCmd.CollateNoCase("MPLS"))
        {
            if (IsMplsLicensed())
            {
    //            bool bIpV6 = (idlSettingsPacket.streamSet[iStrmNum].ipType == 0x86DD);

                idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_MPLS;
                idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8847;
                //idlSettingsPacket.streamSet[iStrmNum].etherType = 0x86DD;
                // Set defaults just in case we are switching mode
                idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi = 1;
                idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi = 0;
                idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi = 0;
                idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi = 0;
    //            if (bIpV6)
    //                idlSettingsPacket.streamSet[iStrmNum].vlan1Tpid = 0x2;
    //            else
                    idlSettingsPacket.streamSet[iStrmNum].vlan1Tpid = 0x1234;
                idlSettingsPacket.streamSet[iStrmNum].vlan2Tpid = 0x1234;
                idlSettingsPacket.streamSet[iStrmNum].vlan3Tpid = 0x1234;
                idlSettingsPacket.streamSet[iStrmNum].vlan4Tpid = 0x1234;

                idlSettingsPacket.streamSet[iStrmNum].vlanId  = 0xFF;
                idlSettingsPacket.streamSet[iStrmNum].vlan2Id = 0xFF;
                idlSettingsPacket.streamSet[iStrmNum].vlan3Id = 0xFF;
                idlSettingsPacket.streamSet[iStrmNum].vlan4Id = 0xFF;
            }
            else
                return;
        }
        else if (!csScpiCmd.CollateNoCase("VLAN"))
        {
            idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_VLAN;
//            idlSettingsPacket.streamSet[iStrmNum].etherType = idlSettingsPacket.streamSet[iStrmNum].ipType;

            idlSettingsPacket.streamSet[iStrmNum].vlan1Tpid = 0x8100;
            idlSettingsPacket.streamSet[iStrmNum].vlan2Tpid = 0x8100;
            idlSettingsPacket.streamSet[iStrmNum].vlan3Tpid = 0x8100;
            idlSettingsPacket.streamSet[iStrmNum].vlan4Tpid = 0x8100;

            idlSettingsPacket.streamSet[iStrmNum].vlanId  = 0;
            idlSettingsPacket.streamSet[iStrmNum].vlan2Id = 0;
            idlSettingsPacket.streamSet[iStrmNum].vlan3Id = 0;
            idlSettingsPacket.streamSet[iStrmNum].vlan4Id = 0;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }

        idlSettingsPacket.streamSet[iStrmNum].vlanQos = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan2Qos = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan3Qos = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan4Qos = 0;


        idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    //    idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 0;

    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ALL;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// STRM:TAG:LEVEL
//***************************
void ScpiPacket::setTagLevel (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAG:LEVEL <strm> <tag>");
#endif
    int iStreamRef = 0;
    int iStrmNum = 0;
    int Level = 0;

    char seps[]   = " ";
    char *next_token;
    char *token;

    LPTSTR parms;

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if(token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // Checking Tagging has been set to either MPLS or VLAN
    //if (idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_NONE)
    //{
    //    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
    //    return;
    //}

    csScpiCmd = token;

    Level = atoi(token);
    // Verify Level range
    if ((Level < 0) || (Level > 4))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Reset Bottom of Stack and set it for the specified level
    switch(Level)
    {
    case 0:
        idlSettingsPacket.streamSet[iStrmNum].taggingMode = IDL_PACKET2_TAGGING_MASK_NONE;
//        idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 0;
        break;
    case 1:
        idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi = 1;
        idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi = 0;
        break;

    case 2:
        idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi = 1;
        idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi = 0;
        break;

    case 3:
        idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi = 1;
        idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi = 0;
        break;

    case 4:
        idlSettingsPacket.streamSet[iStrmNum].vlan1Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan2Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan3Cfi = 0;
        idlSettingsPacket.streamSet[iStrmNum].vlan4Cfi = 1;
        break;
    }


    idlSettingsPacket.reference = iStreamRef;

    // default etherType to MPLS
    if (Level && (idlSettingsPacket.streamSet[iStrmNum].taggingMode == IDL_PACKET2_TAGGING_MASK_MPLS))
    {
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ETHER_TYPE;
        idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8847;
        anyStructure<<=idlSettingsPacket;
        callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);
    }
    else
    {
        idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ETHER_TYPE;
        if (idlSettingsPacket.streamSet[iStrmNum].trafficLayer == IDL_PACKET2_TRAFFIC_LAYER_2)
            idlSettingsPacket.streamSet[iStrmNum].etherType = 0x8000;
        else
            idlSettingsPacket.streamSet[iStrmNum].etherType = idlSettingsPacket.streamSet[iStrmNum].ipType;
        anyStructure<<=idlSettingsPacket;
        callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);
    }


    // Set Tag level
    idlSettingsPacket.streamSet[iStrmNum].vlanEnable = Level;
    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_ALL;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}

//***************************
// STRM:TAG:LEVEL?
//***************************
void ScpiPacket::getTagLevel (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAG:LEVEL? <strm>");
#endif
    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csTag;
    csTag.Format("Tag_Level%d",idlSettingsPacket.streamSet[iStrmNum].vlanEnable);
    if(idlSettingsPacket.streamSet[iStrmNum].vlanEnable == IDL_OFF_STATE)
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
    }
    else
    {
        m_pScpiProxyServer->scpiResults(csTag);
    }

}


//***************************
// STRM:TAG:CUSTOM:LEVEL?
//***************************
void ScpiPacket::getCustomTagLevel (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAG:CUSTOM:LEVEL? <strm>");
#endif
    //validation
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    LPTSTR parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char *next_token;
    char seps[]   = " ";
    char *token = strtok_s( parm, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   CString csTag;
   csTag.Format("%d",idlSettingsPacket.streamSet[iStrmNum].customTagLevels);
   if(idlSettingsPacket.streamSet[iStrmNum].customTagLevels == IDL_OFF_STATE)
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csTag);
   }

}


//***************************
// STRM:TAG:CUSTOM:LEVEL
//***************************
void ScpiPacket::setCustomTagLevel (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSTRM:TAG:CUSTOM:LEVEL <strm> <tag>");
#endif
   int iStreamRef = 0;

   CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    //memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllStreamSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    int iStrmNum;
    char *next_token;
    char seps[]   = " ";
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);

    if(token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csScpiCmd = token;
    if (!csScpiCmd.CollateNoCase("ON"))
    {
        idlSettingsPacket.streamSet[iStrmNum].customTagLevels = 1;
    }
    else if (!csScpiCmd.CollateNoCase("OFF"))
    {
        idlSettingsPacket.streamSet[iStrmNum].customTagLevels = 0;
    }
    else if ((atoi(token) > 0) && (atoi(token) <= 5))
    {
        idlSettingsPacket.streamSet[iStrmNum].customTagLevels = atoi(token);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.streamSet[iStrmNum].reference = IDL_PACKET2_STREAM_REF_CUSTOM_TAG_LEVELS;

    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

}


//***************************
// STRM:TAG:CUSTOM:DATA?
//***************************
void ScpiPacket::getCustomTag (CString& csScpiCmd)
{
    int iStrmNum;

    char seps[]   = " ";
    char *next_token;
    char *token;
    int level;

    LPTSTR parm;

    CString csVal;
    csVal.Empty();

    //validation
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check the parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get traffic generator number from the command string
    parm = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parm, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate traffic generator number parmaeter
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    level = 0;

    // get the second parameter - level
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }
    level = atoi (token);

    // Verify level range
    if ((level < 1) || (level > 5))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(level)
    {
    case 1:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].customTag1);
        break;

    case 2:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].customTag2);
        break;

    case 3:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].customTag3);
        break;

    case 4:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].customTag4);
        break;

    case 5:
        csVal.Format("%X", idlSettingsPacket.streamSet[iStrmNum].customTag5);
        break;

    default:
        break;
    }

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// STRM:TAG:CUSTOM:DATA
//***************************
void ScpiPacket::setCustomTag (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:TAG:CUSTOM:DATA");
#endif

//    int len;
//    int i;
    int iD;
    int level;

    int iStrmNum = 0;
    int iStreamRef = 0;
    char seps[]   = " ";
    char *next_token;
    char *token;

    int lower_limits = 0;
    int upper_limits = 0xFFFF;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;

    CORBA::Any_var anyStructure=new CORBA::Any;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    token = strtok_s( parms, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // validate Stream Id and set the reference
    iStrmNum = atoi(token) - 1;
    if (IsStreamNumberInvalid(iStrmNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }
    iStreamRef = iStrmNum;

    level = 0;

    // get the second parameter - level
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }
    level = atoi (token);

    // Verify level range
    if ((level < 1) || (level > 5))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // get the id parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }

    iD = static_cast<int>(CUtils::hexAsciiIntoInt(token));

    // Check limits
    if (iD < lower_limits || iD > upper_limits)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch (level)
    {
    case 1:
        idlSettingsPacket.streamSet[iStrmNum].customTag1 = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference  = IDL_PACKET2_STREAM_REF_CUSTOM_TAG1;
        break;

    case 2:
        idlSettingsPacket.streamSet[iStrmNum].customTag2 = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference  = IDL_PACKET2_STREAM_REF_CUSTOM_TAG2;
        break;

    case 3:
        idlSettingsPacket.streamSet[iStrmNum].customTag3 = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference  = IDL_PACKET2_STREAM_REF_CUSTOM_TAG3;
        break;

    case 4:
        idlSettingsPacket.streamSet[iStrmNum].customTag4 = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference  = IDL_PACKET2_STREAM_REF_CUSTOM_TAG4;
        break;

    case 5:
        idlSettingsPacket.streamSet[iStrmNum].customTag5 = iD;
        idlSettingsPacket.streamSet[iStrmNum].reference  = IDL_PACKET2_STREAM_REF_CUSTOM_TAG5;
        break;

    default:
        break;
    }

//    idlSettingsPacket.streamSet[iStrmNum].vlanEnable = 1;
    idlSettingsPacket.reference = iStreamRef;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//*****************************************
// STRM:MPLS:LABEL# SET LABEL 1-4
//*****************************************
void ScpiPacket::setMplsLabel(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:LABEL<Label> <offset>");
#endif

    if (IsMplsLicensed())
        setVlanTpidByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;
}

//*****************************************
// STRM:MPLS:LABEL#? - GET LABEL 1-4
//*****************************************
void ScpiPacket::getMplsLabel(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:LABEL<Label>?");
#endif

    if (IsMplsLicensed())
        getVlanTpidByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;
}

//*****************************************
// STRM:MPLS:TC# - SET TC
//    Traffic Class Level 1-4
//*****************************************
void ScpiPacket::setMplsTC(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:TC<id> <Traffic Class>");
#endif

    if (IsMplsLicensed())
        setVlanQosByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;

}

//*****************************************
// STRM:MPLS:TC#? - GET TC
//    Traffic Class Level 1-4
//*****************************************
void ScpiPacket::getMplsTC(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:TC<id>?");
#endif

    if (IsMplsLicensed())
        getVlanQosByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;
}


//*****************************************
// STRM:MPLS:S# - SET BOS
//     Bottom of Stack Indication 1-4
//*****************************************
void ScpiPacket::setMplsBos(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:S<id> <???>");
#endif

    if (IsMplsLicensed())
        setVlanCfiByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;
}

//*****************************************
// STRM:MPLS:S#? - GET BOS
//     Bottom of Stack Indication 1-4
//*****************************************
void ScpiPacket::getMplsBos(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:S<id>?");
#endif

    if (IsMplsLicensed())
        getVlanCfiByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;
}

//*****************************************
// STRM:MPLS:TTL# - Set TTL
//      Time to Live Levels 1-4
//*****************************************
void ScpiPacket::setMplsTtl(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:TTL<id> <Timeout>");
#endif

    if (IsMplsLicensed())
        setVlanIdByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;

}

//*****************************************
// STRM:MPLS:TTL#? - Get TTL
//      Time to Live Levels 1-4
//*****************************************
void ScpiPacket::getMplsTtl(CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MPLS:TTL<id>?");
#endif

    if (IsMplsLicensed())
        getVlanIdByLevel(csScpiCmd, IDL_PACKET2_TAGGING_MASK_MPLS, -1);
    else
        return;
}

//*****************************************
// SEEDAB LEVEL PROCESSING
//*****************************************

void ScpiPacket::doSeedABLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, seedABLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// SEEDAB:ABPAT
//***************************
void ScpiPacket::setSeedABPat (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSEEDAB:ABPAT");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {

        if (!csScpiCmd.CollateNoCase("ALL_ZEROS"))
        {
         idlSettingsPacket.seedAbPatternType = IDL_PACKET2_SEED_AB_PATTERN_TYPE_ALL_ZEROS;
        }
        else if (!csScpiCmd.CollateNoCase("LOCAL_FAULT"))
        {
         idlSettingsPacket.seedAbPatternType = IDL_PACKET2_SEED_AB_PATTERN_TYPE_LOCAL_FAULT;
        }
        else
        {
         m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }

    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
    }


    idlSettingsPacket.reference = IDL_PACKET2_REF_SEED_AB_PATTERN_TYPE;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// SEEDAB:ABPAT?
//***************************
void  ScpiPacket::getSeedABPat (CString&)
{
#ifdef _MYDEBUG
   printf("SEEDAB:ABPAT?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csResult;


    switch(idlSettingsPacket.seedAbPatternType)
    {
    case IDL_PACKET2_SEED_AB_PATTERN_TYPE_ALL_ZEROS:
        csResult = "ALL_ZEROS";
        break;
    case IDL_PACKET2_SEED_AB_PATTERN_TYPE_LOCAL_FAULT:
        csResult = "LOCAL_FAULT";
        break;
    }
    m_pScpiProxyServer->scpiResults(csResult);
}



//***************************
// SEEDA:APAT
//***************************
void ScpiPacket::setSeedAPat (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSEEDAB:APAT");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    //IdlPacket2AllSettings idlSettingsPacket;
    //IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    // TBD
    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
}

//***************************
// SEEDA:APAT?
//***************************
void  ScpiPacket::getSeedAPat (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:MAP?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    CString csResult;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%I64X", idlSettingsPacket.seedAPattern);
    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// SEEDA:BPAT
//***************************
void ScpiPacket::setSeedBPat (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSEEDAB:BPAT");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    //IdlPacket2AllSettings idlSettingsPacket;
    //IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    // TBD
    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
}

//***************************
// SEEDA:BPAT?
//***************************
void  ScpiPacket::getSeedBPat (CString&)
{
#ifdef _MYDEBUG
    printf("\nSEEDA:BPAT?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    CString csResult;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%I64X", idlSettingsPacket.seedBPattern);
    m_pScpiProxyServer->scpiResults(csResult);
}



//***************************
// SEEDAB:COUNT?
//***************************
void ScpiPacket::getSeedABCount (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSEEDAB:COUNT?");
#endif

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    m_pScpiProxyServer->getErrCount(&idlStatPacket.seedAB);
}

//***************************
// SEEDAB:ES?
//***************************
void ScpiPacket::getSeedABES (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSEEDAB:ES?");
#endif

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    m_pScpiProxyServer->getES(&idlStatPacket.seedAB);
}

//***************************
// SEEDAB:AVGRATE?
//***************************
void ScpiPacket::getSeedABAvgRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSEEDAB:AVGRATE?");
#endif

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    m_pScpiProxyServer->getAvgErrRate(&idlStatPacket.seedAB);
}

//***************************
// SEEDAB:CURRATE?
//***************************
void ScpiPacket::getSeedABCurRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSEEDAB:CURRATE?");
#endif

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    m_pScpiProxyServer->getErrRate(&idlStatPacket.seedAB);
}



//*****************************************
// PING LEVEL PROCESSING
//*****************************************

void ScpiPacket::doPingLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, pingLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}
void ScpiPacket::doArpLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, arpLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//PING:MACSRC
void ScpiPacket::setMACSrc (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char *token = parms;
    int    index = 1;
    int    count = 0;
    int     addr;
    char    dash[] = "-";
    char    period[] = ".";
    char *next_token;
    char    *cpAddr = strtok_s(parms, period, &next_token);

    cpAddr = strtok_s(token, dash, &next_token);

    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    // loop to get all 6 address elements - should be separated by '-'
    do
    {
        if (cpAddr == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // convert the second parameter to integer
        addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));

        // check if value is in a valid range
        if (addr < STRMSETDESTMAC_LOWERLIMIT || addr > STRMSETDESTMAC_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

        // set the structure with the proper value and increment the count
        idlSettingsPacket.pingMacSrcAddress[count++] = addr;

        //get the next byte
        cpAddr = strtok_s(NULL, dash, &next_token);

    }while (count < 6);

    idlSettingsPacket.reference = IDL_PACKET2_REF_PING_MAC_SRC_ADDRESS;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:MACSRC?
void ScpiPacket::getMACSrc (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 6; i++)
    {
        csVal.Format("%x", idlSettingsPacket.pingMacSrcAddress[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 5)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}

//PING:IPSRC
void ScpiPacket::setIPSrc (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

   CORBA::Any_var anyStructure=new CORBA::Any;

   IdlPacket2AllSettings idlSettingsPacket;

   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char *token = parms;
    int    index = 1;
    int    count = 0;
    int     addr;
    char    period[] = ".";
    char *next_token;
    char    *cpAddr = strtok_s(parms, period, &next_token);

    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // loop to get all 4 address elements - should be separated by '.'
        do
        {
                if (cpAddr == NULL)
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

            // convert the second parameter to integer
            addr = atoi(cpAddr);

            // check if value is in a valid range
            if (addr < STRMSETSRCIP_LOWERLIMIT || addr > STRMSETSRCIP_UPPERLIMIT)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.pingIpSrcAddress[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 4);

        idlSettingsPacket.reference = IDL_PACKET2_REF_PING_IP_SRC_ADDRESS;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure <<= idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:IPSRC?
void ScpiPacket::getIPSrc (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 4; i++)
    {
        csVal.Format("%d", idlSettingsPacket.pingIpSrcAddress[i]);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 3)
            csAddress += '.';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}

//PING:IPDEST
void ScpiPacket::setIPDest (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());


    char *token = parms;
    int    index = 1;
    int    count = 0;
    int     addr;
    char    period[] = ".";
    char *next_token;
    char    *cpAddr = strtok_s(parms, period, &next_token);

    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // loop to get all 4 address elements - should be separated by '.'
        do
        {
                if (cpAddr == NULL)
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

            // convert the second parameter to integer
            addr = atoi(cpAddr);

            // check if value is in a valid range
            if (addr < STRMSETSRCIP_LOWERLIMIT || addr > STRMSETSRCIP_UPPERLIMIT)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.pingIpDestAddress[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 4);

        idlSettingsPacket.reference = IDL_PACKET2_REF_PING_IP_DEST_ADDRESS;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure <<= idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:IPDEST?
void ScpiPacket::getIPDest (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 4; i++)
    {
        csVal.Format("%d", idlSettingsPacket.pingIpDestAddress[i]);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 3)
            csAddress += '.';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}

//PING:PKTLEN
void ScpiPacket::setPktLen (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    iValue = atoi(csScpiCmd);

    if (iValue < currentPacketAllowedSettings->pingPacketLengthLo || iValue > currentPacketAllowedSettings->pingPacketLengthHi)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.reference = IDL_PACKET2_REF_PING_PACKET_LENGTH;
    idlSettingsPacket.pingPacketLength = iValue;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:PKTLEN?
void ScpiPacket::getPktLen (CString& csScpiCmd)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%d", idlSettingsPacket.pingPacketLength);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:NUMPINGS
void ScpiPacket::setNumPings (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    iValue = atoi(csScpiCmd);

    if (iValue < currentPacketAllowedSettings->pingNumPingsLo || iValue > currentPacketAllowedSettings->pingNumPingsHi)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.reference = IDL_PACKET2_REF_PING_NUM_PINGS;
    idlSettingsPacket.pingNumPings = iValue;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:NUMPINGS?
void ScpiPacket::getNumPings (CString& csScpiCmd)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%d", idlSettingsPacket.pingNumPings);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:TTL
void ScpiPacket::setTTL (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    iValue = atoi(csScpiCmd);

    if (iValue < currentPacketAllowedSettings->pingTTLLo || iValue > currentPacketAllowedSettings->pingTTLHi)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.reference = IDL_PACKET2_REF_PING_TTL;
    idlSettingsPacket.pingTTL = iValue;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:TTL?
void ScpiPacket::getTTL (CString& csScpiCmd)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%d", idlSettingsPacket.pingTTL);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:TIMEOUT
void ScpiPacket::setTimeOut (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    iValue = atoi(csScpiCmd);

    if (iValue < currentPacketAllowedSettings->pingTimeoutLo || iValue > currentPacketAllowedSettings->pingTimeoutHi)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.reference = IDL_PACKET2_REF_PING_TIMEOUT;
    idlSettingsPacket.pingTimeout = iValue;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:TIMEOUT?
void ScpiPacket::getTimeOut (CString& csScpiCmd)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;

    csResult.Format("%d", idlSettingsPacket.pingTimeout);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:START
void ScpiPacket::setStart (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlOp1Struct idlOp1Settings;

//    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    idlOp1Settings.value = IDL_PACKET2_PING_START;

    anyStructure <<= idlOp1Settings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_SET_PING, m_globs));
}

//PING:STOP
void ScpiPacket::setStop (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlOp1Struct idlOp1Settings;

//    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    idlOp1Settings.value = IDL_PACKET2_PING_STOP;

    anyStructure <<= idlOp1Settings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_SET_PING, m_globs));

}

//PING:REPLY?
void ScpiPacket::getReply (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    iValue = atoi(csScpiCmd);

    if (iValue < 1 || iValue > IDL_PACKET2_MAX_PING_REPLIES)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(idlStatPacket.pingResponse[iValue - 1])
    {
        case IDL_PACKET2_PING_REPLY_NONE:
            csResult = "No Response";
            break;
        case IDL_PACKET2_PING_REPLY_SUCCESS:
            csResult = "Success";
            break;
        case IDL_PACKET2_PING_REPLY_TIMEOUT:
            csResult = "Timeout";
            break;
        case IDL_PACKET2_PING_REPLY_UNREACHABLE:
            csResult = "Unreachable";
            break;
        case IDL_PACKET2_PING_REPLY_QUENCH:
            csResult = "Source quench (destination is too busy)";
            break;
        case IDL_PACKET2_PING_REPLY_NOFRAG:
            csResult = "Could not fragment";
            break;
        case IDL_PACKET2_PING_REPLY_UNKNOWN:
            csResult = "Unknown Reply";
            break;
        case IDL_PACKET2_PING_REPLY_LIFETIME:
            csResult = "Lifetime Exceeded";
            break;
        default:
            csResult = "Invalid Case";
            break;
    }

    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:BYTESRX?
void ScpiPacket::getBytesRx (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    iValue = atoi(csScpiCmd);

    if (iValue < 1 || iValue > IDL_PACKET2_MAX_PING_REPLIES)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%d", idlStatPacket.pingBytesReceived[iValue - 1]);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:SEQNO?
void ScpiPacket::getSeqNo (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    iValue = atoi(csScpiCmd);

    if (iValue < 1 || iValue > IDL_PACKET2_MAX_PING_REPLIES)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%d", idlStatPacket.pingSeqNumber[iValue - 1]);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:PKTTTL?
void ScpiPacket::getPktTTL (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    iValue = atoi(csScpiCmd);

    if (iValue < 1 || iValue > IDL_PACKET2_MAX_PING_REPLIES)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%d", idlStatPacket.pingTTL[iValue - 1]);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:PKTTIME?
void ScpiPacket::getPktTime (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csResult;
    int iValue;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    iValue = atoi(csScpiCmd);

    if (iValue < 1 || iValue > IDL_PACKET2_MAX_PING_REPLIES)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%d", idlStatPacket.pingResponseTime[iValue - 1]);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:TX?
void ScpiPacket::getTx (CString& csScpiCmd)
{
    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%d", idlStatPacket.pingNumberPacketsTransmitted);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:RX?
void ScpiPacket::getRx (CString& csScpiCmd)
{
    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%d", idlStatPacket.pingNumberPacketsReceived);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:LOSS?
void ScpiPacket::getLoss (CString& csScpiCmd)
{
    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%.2f", (float) idlStatPacket.pingPercentPacketLoss / 100);
    //unsigned short tempLoss = m_pModel->getPingPercentPacketLoss();
    //m_csLossRate.Format("%.2f", (float) (((float) tempLoss) / 100));
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:RTDMIN?
void ScpiPacket::getRTDMin (CString& csScpiCmd)
{
    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%ld ms", idlStatPacket.pingRoundTripDelayMin);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:RTDMAX?
void ScpiPacket::getRTDMax (CString& csScpiCmd)
{
    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%ld ms", idlStatPacket.pingRoundTripDelayMax);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:RTDAVG?
void ScpiPacket::getRTDAvg (CString& csScpiCmd)
{
    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    csResult.Format("%ld ms", idlStatPacket.pingRoundTripDelayAvg);
    m_pScpiProxyServer->scpiResults(csResult);
}

//PING:DESTMAC?
void ScpiPacket::getDestMAC (CString& csScpiCmd)
{
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 6; i++)
    {
        csVal.Format("%x", idlStatPacket.pingDstMacAddress[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 5)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}


//*****************************************
// SD LEVEL PROCESSING
//*****************************************

void ScpiPacket::dosdLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, sdLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// SD:CURTIME?
//***************************
void ScpiPacket::getSDCurTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:CURTIME?");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;
    int iFactor = 1;
    switch(idlSettingsPacket.apsResolution)
    {
        case IDL_PACKET2_APS_RESOLUTION_HIGH:
        default:
            iFactor = 1;
            break;
        case IDL_PACKET2_APS_RESOLUTION_MED:
            iFactor = 10;
            break;
        case IDL_PACKET2_APS_RESOLUTION_LOW:
            iFactor = 100;
            break;
    }

    double dSeconds = idlStatPacket.apsSwitchTime * 0.100 * iFactor;

    if (dSeconds > 1000.0)
        csResult.Format("%.1f ms", dSeconds);
    else
        csResult.Format("%.1f ms", dSeconds);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// SD:CURFRAME?
//***************************
void ScpiPacket::getSDCurFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:MINTIME?
//***************************
void ScpiPacket::getSDMinTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:MINTIME?");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;
    int iFactor = 1;
    switch(idlSettingsPacket.apsResolution)
    {
        case IDL_PACKET2_APS_RESOLUTION_HIGH:
        default:
            iFactor = 1;
            break;
        case IDL_PACKET2_APS_RESOLUTION_MED:
            iFactor = 10;
            break;
        case IDL_PACKET2_APS_RESOLUTION_LOW:
            iFactor = 100;
            break;
    }

    double dSeconds = idlStatPacket.minApsSwitchTime * 0.100 * iFactor;

    if (dSeconds > 1000.0)
        csResult.Format("%.1f ms", dSeconds);
    else
        csResult.Format("%.1f ms", dSeconds);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// SD:MINFRAME?
//***************************
void ScpiPacket::getSDMinFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:MAXTIME?
//***************************
void ScpiPacket::getSDMaxTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:MAXTIME?");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;
    int iFactor = 1;
    switch(idlSettingsPacket.apsResolution)
    {
        case IDL_PACKET2_APS_RESOLUTION_HIGH:
        default:
            iFactor = 1;
            break;
        case IDL_PACKET2_APS_RESOLUTION_MED:
            iFactor = 10;
            break;
        case IDL_PACKET2_APS_RESOLUTION_LOW:
            iFactor = 100;
            break;
    }


    double dSeconds = idlStatPacket.maxApsSwitchTime * 0.100 * iFactor;

    if (dSeconds > 1000.0)
        csResult.Format("%.1f ms", dSeconds);
    else
        csResult.Format("%.1f ms", dSeconds);


    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// SD:MAXFRAME?
//***************************
void ScpiPacket::getSDMaxFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:AVGTIME?
//***************************
void ScpiPacket::getSDAvgTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:AVGTIME?");
#endif

    CString csResult;

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;
    int iFactor = 1;
    switch(idlSettingsPacket.apsResolution)
    {
        case IDL_PACKET2_APS_RESOLUTION_HIGH:
        default:
            iFactor = 1;
            break;
        case IDL_PACKET2_APS_RESOLUTION_MED:
            iFactor = 10;
            break;
        case IDL_PACKET2_APS_RESOLUTION_LOW:
            iFactor = 100;
            break;
    }

    double dSeconds = idlStatPacket.avgApsSwitchTime * 0.100 * iFactor;

    if (dSeconds > 1000.0)
        csResult.Format("%.1f ms", dSeconds);
    else
        csResult.Format("%.1f ms", dSeconds);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// SD:AVGFRAME?
//***************************
void ScpiPacket::getSDAvgFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:GOODTIME
//***************************
void ScpiPacket::setSDGoodTime (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSD:GOODTIME");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csBuf;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    float fVal = static_cast<float>(atof(csScpiCmd));

    if (fVal < (TXSETAPSGOOD_LOWERLIMIT - .09) || fVal > TXSETAPSGOOD_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.apsSwitchStopCount = static_cast<CORBA::UShort>(fVal *10);


    idlSettingsPacket.reference = IDL_PACKET2_REF_APS_STOP_COUNT ;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// SD:GOODFRAME
//***************************
void ScpiPacket::setSDGoodFrame (CString& csScpiCmd)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:GOODTIME?
//***************************
void ScpiPacket::getSDGoodTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:GOODTIME?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csBuf;

    csBuf.Format("%.1f ms",idlSettingsPacket.apsSwitchStopCount * .1);

    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// SD:GOODFRAME?
//***************************
void ScpiPacket::getSDGoodFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:BADTIME
//***************************
void ScpiPacket::setSDBadTime (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSD:BADTIME");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csBuf;

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    float fVal = static_cast<float>(atof(csScpiCmd));

    if (fVal < (TXSETAPSBAD_LOWERLIMIT  - .09) || fVal > TXSETAPSBAD_UPPERLIMIT)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.apsSwitchStartCount = static_cast<CORBA::UShort>(fVal * 10);


    idlSettingsPacket.reference = IDL_PACKET2_REF_APS_START_COUNT ;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// SD:BADFRAME
//***************************
void ScpiPacket::setSDBadFrame (CString& csScpiCmd)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//***************************
// SD:BADTIME?
//***************************
void ScpiPacket::getSDBadTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:BADTIME?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csBuf;

    csBuf.Format("%.1f ms",idlSettingsPacket.apsSwitchStartCount * 0.1);

    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// SD:BADFRAME?
//***************************
void ScpiPacket::getSDBadFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}


//***************************
// SD:ACTION
//***************************
void ScpiPacket::setSDAction (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nSD:ACTION");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlOp1Struct idlOp1Setting;

    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csBuf;

    csBuf = csScpiCmd.Left(4);

    if (!csBuf.CollateNoCase("NONE"))
    {
        idlOp1Setting.value = IDL_PACKET2_APS_STOP;
    }
    else if (!csBuf.CollateNoCase("STOP"))
    {
        idlOp1Setting.value = IDL_PACKET2_APS_STOP;
    }
    else if (!csBuf.CollateNoCase("SING"))
    {
        idlOp1Setting.value = IDL_PACKET2_APS_ARM_SINGLE;
    }
    else if (!csBuf.CollateNoCase("CONT"))
    {
        idlOp1Setting.value = IDL_PACKET2_APS_ARM_CONTINUOUS;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllSettings  idlSettingsPacket;
    idlSettingsPacket.reference  = IDL_PACKET2_REF_APS_CRITERIA_MASK;
    idlSettingsPacket.apsCriteriaMask   = IDL_PACKET2_APS_SWITCH_TRIGGER_MASK_FCS;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

    IdlOp1Struct_var op1StructVar = new IdlOp1Struct(idlOp1Setting);

    anyStructure<<=op1StructVar;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_ARM_APS_SWITCH, m_globs));
}

//***************************
// SD:ACTION?
//***************************
void ScpiPacket::getSDState (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:ACTION?");
#endif

    CString csResult;

   IdlPacket2Stats idlStatPacket;

   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (idlStatPacket.apsSwitchState)
    {
    case IDL_PACKET2_APS_ST_STOPPED:
        csResult = "INACTIVE";
        break;
    case IDL_PACKET2_APS_ST_ARMED:
        csResult = "ARMED SINGLE";
        break;
    case IDL_PACKET2_APS_ST_RUNNING:
        csResult = "MEASURING SINGLE";
        break;
    case IDL_PACKET2_APS_ST_CONT_ARM:
        csResult = "ARMED CONTINUOUS";
        break;
    case IDL_PACKET2_APS_ST_CONT_RUN:
        csResult = "MEASURING CONTINUOUS";
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
        return;
    }

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// SD:RECTIME?
//***************************
void ScpiPacket::getSDRecentTime (CString&)
{
#ifdef _MYDEBUG
   printf("\nSD:RECTIME?");
#endif

    IdlPacket2Stats idlPacketStats;

    TestCmdGetStatus(callGetPacketStatistics(idlPacketStats));
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket = *idlSettingsPacketPtr;
    int iFactor = 1;
    switch(idlSettingsPacket.apsResolution)
    {
        case IDL_PACKET2_APS_RESOLUTION_HIGH:
        default:
            iFactor = 1;
            break;
        case IDL_PACKET2_APS_RESOLUTION_MED:
            iFactor = 10;
            break;
        case IDL_PACKET2_APS_RESOLUTION_LOW:
            iFactor = 100;
            break;
    }
    CString csBuf;
    CString csTemp;
    for(int i = 0; i < 10; i++)
    {
        /* Bug # 3257 - SCPI:  The SD:RECTIME? command sometimes unexpectedly rounds some of the results.
        if (idlPacketStats.recentApsSwitchTimes[i] >= 1000000.0)
            csTemp.Format("%0.0f ms", idlPacketStats.recentApsSwitchTimes[i] * 0.100);
        else
        */
        csTemp.Format("%0.3f ms", idlPacketStats.recentApsSwitchTimes[i] * 0.100 * iFactor);

        if (i == 0)
            csBuf += csTemp;
        else
            csBuf += ", " + csTemp;
    }
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// SD:RECFRAME?
//***************************
void ScpiPacket::getSDRecentFrame (CString&)
{
/////////////UNSUPPORTED COMMAND FOR HDENET///////////////////////
}

//*****************************************
//       RX LEVEL PROCESSING
//*****************************************

void ScpiPacket::doRxLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, rxLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
//       TPID LEVEL PROCESSING
//*****************************************

void ScpiPacket::doTpidLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, tpidLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RX:OPP?
//***************************
void ScpiPacket::rxGetOpticalPower (CString&)
{
#ifdef _MYDEBUG
   printf("\nRX:OPP?");
#endif

    CString csResults = "Err";

    IdlPacket2Stats idlStatPacket;

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


//    if (!(( idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_1000T_ENET_FULL) ||
//        (idlSettingsPacket.portInterface  == IDL_PACKET2_PORT_INTERFACE_1G_ENET_FULL)))
//    {
//        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
//        return;
//    }


    if ((m_globs->g_ppType == IDL_PP_HD_ENET_OPTICAL) ||
        (m_globs->g_ppType == IDL_PP_HD_ENET_10G) ||
        (m_globs->g_ppType == IDL_PP_CSA_DUAL_ENET) ||
        (m_globs->g_ppType == IDL_PP_NG2_1G_ENET) ||
        (idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP))
    {
        double fOpticalPower = ((double) idlStatPacket.signalStrength) / 100.0;
        if ((fOpticalPower < -99.6999) && (fOpticalPower > -99.7001))
        {
            csResults = "No Measurement";
        }
        else if ((fOpticalPower < -99.7999) && (fOpticalPower > -99.8001))
        {
#if 1
            csResults = "No Module";
#else
            if (idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP)
            {
                switch (idlStatPacket.portInterfaceState)
                {
                case IDL_PACKET2_PORT_INTERFACE_STATE_1G_ENET_FULL:
                case IDL_PACKET2_PORT_INTERFACE_STATE_1G_ENET_HALF:
                    csResults = "Missing SFP";
                    break;
                case IDL_PACKET2_PORT_INTERFACE_STATE_10G_ENET_FULL:
                case IDL_PACKET2_PORT_INTERFACE_STATE_10G_ENET_HALF:
                case IDL_PACKET2_PORT_INTERFACE_STATE_10G_ENET_WAN:
                case IDL_PACKET2_PORT_INTERFACE_STATE_1G_FIBERCHAN:
                case IDL_PACKET2_PORT_INTERFACE_STATE_2G_FIBERCHAN:
                case IDL_PACKET2_PORT_INTERFACE_STATE_4G_FIBERCHAN:
                case IDL_PACKET2_PORT_INTERFACE_STATE_8G_FIBERCHAN:
                case IDL_PACKET2_PORT_INTERFACE_STATE_10G_FIBERCHAN:
                default:
                    csResults = "Missing XFP";
                    break;
                case IDL_PACKET2_PORT_INTERFACE_STATE_41G_ENET_FULL:
                case IDL_PACKET2_PORT_INTERFACE_STATE_103G_ENET_FULL:
                    csResults = "Missing CFP";
                    break;
                }
            }
            else
            {
                if (m_globs->g_ppType == IDL_PP_HD_ENET_10G)
                    csResults = "Missing XFP";
                else
                    csResults = "Missing SFP";
            }
#endif
        }
        else if ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10T_ENET_FULL) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_100T_ENET_FULL) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_1000T_ENET_FULL) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_2500T_ENET) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_5000T_ENET) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10000T_ENET))
            csResults = "Electrical";
        else if (fOpticalPower < -50)
            csResults = "Loss of Power";
        else
            csResults.Format("%.2f dBm", fOpticalPower);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    m_pScpiProxyServer->scpiResults(csResults);
}

//*****************************************
//       TX LEVEL PROCESSING
//*****************************************

void ScpiPacket::doTxLevel (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, txLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// TX:REPLY
//***************************
void ScpiPacket::txSetReply (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:REPLY");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {

        if(!csScpiCmd.CollateNoCase("ON"))
            idlSettingsPacket.replyLinkFault = IDL_ON_STATE;
        else if(!csScpiCmd.CollateNoCase("OFF"))
            idlSettingsPacket.replyLinkFault = IDL_OFF_STATE;
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }
        idlSettingsPacket.reference = IDL_PACKET2_REF_REPLY_LINK_FAULT;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }

}

//***************************
// TX:REPLY?
//***************************
void ScpiPacket::txGetReply (CString&)
{
#ifdef _MYDEBUG
    printf("\nTX:REPLY?");
#endif

    CString csResults = "Err";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (idlSettingsPacket.replyLinkFault == IDL_ON_STATE)
        csResults = "ON";
    else
        csResults = "OFF";

    m_pScpiProxyServer->scpiResults(csResults);
}

//***************************
// TX:LINECONTROL
//***************************
void ScpiPacket::txSetLineControl (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:LINECONTROL");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        if(!csScpiCmd.CollateNoCase("Auto"))
            idlSettingsPacket.lineControl = 0;
        else if(!csScpiCmd.CollateNoCase("Master"))
            idlSettingsPacket.lineControl = 1;
        else if(!csScpiCmd.CollateNoCase("Slave"))
            idlSettingsPacket.lineControl = 2;
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_LINE_CONTROL;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }

}

//***************************
// TX:LINECONTROL?
//***************************
void ScpiPacket::txGetLineControl (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:LINECONTROL?");
#endif

   CString csResults = "Err";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.lineControl == 0)
       csResults = "Auto";
   else if(idlSettingsPacket.lineControl == 1)
       csResults = "Master";
   else if(idlSettingsPacket.lineControl == 2)
       csResults = "Slave";


   m_pScpiProxyServer->scpiResults(csResults);
}


//***************************
// TX:FLOWCONTROL
//***************************
void ScpiPacket::txSetFlowControl (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:FLOWCONTROL");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        if(!csScpiCmd.CollateNoCase("ON"))
            idlSettingsPacket.flowControl = 1;
        else if(!csScpiCmd.CollateNoCase("OFF"))
            idlSettingsPacket.flowControl = 0;
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_FLOW_CONTROL;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }

}

//***************************
// TX:FLOWCONTROL?
//***************************
void ScpiPacket::txGetFlowControl (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:FLOWCONTROL?");
#endif

   CString csResults = "Err";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.flowControl == 1)
       csResults = "ON";
   else if(idlSettingsPacket.flowControl == 0)
       csResults = "OFF";


   m_pScpiProxyServer->scpiResults(csResults);
}

//***************************
// TX:LASER // Method to set laser(ON or OFF), TX:LASER <ON|OFF>
//***************************
void  ScpiPacket::txSetLaserMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:LASER");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
       if (!csScpiCmd.CollateNoCase("ON"))
        {
         idlSettingsPacket.txLaserState = IDL_LASER_STATE_ON;
        }
        else if (!csScpiCmd.CollateNoCase("OFF"))
        {
         idlSettingsPacket.txLaserState = IDL_LASER_STATE_OFF;
        }
        else
        {
         m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_LASER_STATE;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// TX:LASER? // Method to get laser mode (ON or OFF),  TX:LASER?
//***************************
void  ScpiPacket::txGetLaserMode (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:LASER?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.txLaserState == IDL_LASER_STATE_ON)
   {
      m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
}

//***************************
// TX:LASERTYPE // Method to set laser(wavelength), TX:LASERTYPE <1310|1550>
//***************************
void  ScpiPacket::txSetLaserType (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:LASERTYPE");
#endif
///////////////////NOT SUPPORTED/////////////////////
    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    return;
}

//***************************
// TX:LASERTYPE? // Method to get laser type,  TX:LASERTYPE?
//***************************
void  ScpiPacket::txGetLaserType (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:LASERTYPE?");
#endif
    CString csResult;

    //IdlPacket2Stats_var idlPacketStatistics_var = new IdlPacket2Stats;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    //divide by 1000 to convert from pico to nano
    double freqWave = (double) idlStatPacket.txWavelength / 1000.0;
    if ((freqWave > -0.0001 ) && (freqWave < 0.0001))
    {
        switch (idlSettingsPacket.portInterface)
        {
        case IDL_PACKET2_PORT_INTERFACE_10T_ENET_HALF:
        case IDL_PACKET2_PORT_INTERFACE_10T_ENET_FULL:
        case IDL_PACKET2_PORT_INTERFACE_100T_ENET_HALF:
        case IDL_PACKET2_PORT_INTERFACE_100T_ENET_FULL:
        case IDL_PACKET2_PORT_INTERFACE_1000T_ENET_HALF:
        case IDL_PACKET2_PORT_INTERFACE_1000T_ENET_FULL:
        case IDL_PACKET2_PORT_INTERFACE_2500T_ENET:
        case IDL_PACKET2_PORT_INTERFACE_5000T_ENET:
        case IDL_PACKET2_PORT_INTERFACE_10000T_ENET:
        case IDL_PACKET2_PORT_INTERFACE_AUTO_NEG:
            csResult = "Electrical";
            break;
        case IDL_PACKET2_PORT_INTERFACE_GFP:
            if ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10T_ENET_FULL) ||
                (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_100T_ENET_FULL) ||
                (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_1000T_ENET_FULL) ||
                (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_2500T_ENET) ||
                (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_5000T_ENET) ||
                (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10000T_ENET))
                csResult = "Electrical";
            else
                csResult = "Unknown nm";
            break;
        default:
            csResult = "Unknown nm";
            break;
        }
    }
    else if ((freqWave > 0.0009 ) && (freqWave < 0.0011))
        csResult = "No Module";
    else if ((freqWave > 0.0019) && (freqWave < 0.0021))
        csResult = "MLD";
    else
        csResult.Format("%3.3lf nm", freqWave);

    if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
        (idlStatPacket.portInterfaceState == IDL_PACKET2_PORT_INTERFACE_STATE_OFF))
        csResult = "Not Assigned";

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// TX:LASERPUP // Method to set laser power up mode (ON, OFF, or RESTORE)
//***************************
void  ScpiPacket::txSetLaserPwrUp (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:LASERPUP");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        if (!csScpiCmd.CollateNoCase("ON"))
        {
            idlSettingsPacket.powerUpLaserState = IDL_LASER_POWERS_UP_ON;
        }
        else if (!csScpiCmd.CollateNoCase("OFF"))
        {
            idlSettingsPacket.powerUpLaserState = IDL_LASER_POWERS_UP_OFF;
        }
        else if (!csScpiCmd.CollateNoCase("RESTORE"))
        {
            idlSettingsPacket.powerUpLaserState = IDL_LASER_POWERS_UP_LAST_SAVED_STATE;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_POWER_UP_LASER_STATE;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// TX:LASERPUP? // Method to get laser power up mode (ON, OFF, or RESTORE)
//***************************
void  ScpiPacket::txGetLaserPwrUp (CString&)
{
#ifdef _MYDEBUG
    printf("\nTX:LASERPUP?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (idlSettingsPacket.powerUpLaserState == IDL_LASER_POWERS_UP_LAST_SAVED_STATE)
    {
        m_pScpiProxyServer->scpiResults("RESTORE");
    }
    else if (idlSettingsPacket.powerUpLaserState == IDL_LASER_POWERS_UP_ON)
    {
        m_pScpiProxyServer->scpiResults("ON");
    }
    else
    {
        m_pScpiProxyServer->scpiResults("OFF");
    }
}



//***************************
// TX:PREAMBLE
//***************************
void  ScpiPacket::setPreamble (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    //IdlOp1Struct idlOp1Settings;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    if (!currentPacketAllowedSettings->etherPreambleValid)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    //int len;
    //int i;
    char *next_token;

    //char *token;
    // get the second parameter
    //token = strtok_s( NULL, seps , &next_token);

    int    index = 1;
    int    count = 0;
    int     addr;
    char    dash[] = "-";
    char    *cpAddr = strtok_s(parms, dash, &next_token);


    // check second parameter exists
    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // loop to get all 8  elements - should be separated by '-'
        do
        {
            if (cpAddr == NULL)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }

            // convert the second parameter to integer
            addr = static_cast<int>(CUtils::hexAsciiIntoInt(cpAddr));

            // check if value is in a valid range
            if (addr < 0 || addr > 0xFF)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.etherPreamble[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, dash, &next_token);
        }
        while (count < 8);

        idlSettingsPacket.reference = IDL_PACKET2_REF_ETHER_PREAMBLE;
        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));




}

//***************************
// TX:PREAMBLE?
//***************************
void  ScpiPacket::getPreamble (CString&)
{
/*
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.ppPauseState == IDL_ON_STATE)
   {
      m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
*/
/////////////////////////////////////////////////////////////////////




    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 7 bytes and concatenate into a string delimited by a '-'
    for (i = 0; i < 8; i++)
    {
        csVal.Format("%x", idlSettingsPacket.etherPreamble[i] & 0xff);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 7)
            csAddress += '-';
    }
    m_pScpiProxyServer->scpiResults(csAddress);

}

//***************************
// TX:PAUSE
//***************************
void  ScpiPacket::txSetPause (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:PAUSE");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlOp1Struct pauseDuration;
    int duration = 0;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        duration = atoi(csScpiCmd);

        if (duration <= 65535)
            pauseDuration.value = duration;
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
    }else
    {    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
         return;
    }

    anyStructure<<=pauseDuration;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_PAUSE_FRAME, m_globs));


}

//***************************
// TX:PAUSE?
//***************************
void  ScpiPacket::txGetPause (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:PAUSE?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.ppPauseState == IDL_ON_STATE)
   {
      m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
}


//***************************
// TX:ALARM
//***************************
void  ScpiPacket::txSetAlarmType (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:ALarm:TYPE");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings  idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;
    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        if (!csScpiCmd.CollateNoCase("OFF"))
        {
            idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_OFF;
        }
        else if (!csScpiCmd.CollateNoCase("LOS"))
        {
            if (m_globs->g_ppType == IDL_PP_HD_ENET_OPTICAL || m_globs->g_ppType == IDL_PP_NG2_1G_ENET ||
                m_globs->g_ppType == IDL_PP_HD_ENET_10G) // this checks if the port can be set
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_LOS;
            }
            else if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                     (idlSettingsPacket.portMapping != IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET) &&
                     (idlSettingsPacket.portMapping != IDL_PACKET2_PORT_MAP_GFP_PRBS) &&
                     (idlSettingsPacket.portMapping != IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_LOS;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("LINK"))
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_50G_LAN)                    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_25G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_LINK;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("LFD") )
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_GFP_LFD;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("LF"))
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_50G_LAN)                          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_50G_FEC_LAN)                  ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_25G_LAN)                          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_10G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_41G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_103G_LAN)                     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN)                ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN_FLEXE)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_103G_FEC_LAN)                 ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_FEC_LAN)            ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_106G_FEC_LAN)            ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_106G_FEC_LAN)       ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_106G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_212G_FEC_LAN)                 ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_425G_FEC_LAN)                 ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_41G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_103G_LAN)                     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN)      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN_P1P2) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_425G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_212G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_212G_FEC_LAN)       ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_212G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_212G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_212G_FEC_LAN)            ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_103G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_FEC_LAN)       ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_103G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_LAN)               ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_LAN_FLEXE         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC_P1P2)||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_LAN)              ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP_103G_LAN_FLEXE)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_106G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_106G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN_P1P2)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP_103G_LAN_FLEXE           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC_P1P2)))))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_LOCAL_LINK_FAULT;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("RF") )
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_50G_LAN)                          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_50G_FEC_LAN)                  ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_25G_LAN)                          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_10G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_41G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_103G_LAN)                     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN)                ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN_FLEXE)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_103G_FEC_LAN)                 ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_FEC_LAN)            ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_212G_FEC_LAN)                 ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_425G_FEC_LAN)                 ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_41G_LAN)                      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_103G_LAN)                     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN)      ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN_P1P2) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_425G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_212G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_212G_FEC_LAN)       ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_212G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_212G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_212G_FEC_LAN)            ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_103G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_FEC_LAN)       ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_103G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_FEC_LAN)           ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_LAN)               ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_LAN_FLEXE)        ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC_P1P2)||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_LAN)              ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP_103G_LAN_FLEXE)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN_P1P2)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP_103G_LAN_FLEXE)          ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_P1P2)    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC_P1P2)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_REMOTE_LINK_FAULT;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("LOCS") )
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_GFP_LOCS;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("LOCCS") )
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_PRBS) ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_GFP_LOCCS;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("BLKLOC"))
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_50G_LAN)                    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_25G_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_SEED_AB)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_25G_SEED_AB)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_BLOCK_LOCK_LOSS;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (!csScpiCmd.CollateNoCase("HIBER"))
        {
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_50G_LAN)                    ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_25G_LAN)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_SEED_AB)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_25G_SEED_AB)))
            {
                idlSettingsPacket.alarmGen.alarmType = IDL_PACKET2_ALARM_HI_BER;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }

        idlSettingsPacket.reference = IDL_PACKET2_REF_ALARM_GEN;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}


//***************************
// TX:ALARM?
//***************************
void  ScpiPacket::txGetAlarmType (CString&)
{
#ifdef _MYDEBUG
    printf("\nTX:ALarm:TYPE?");
#endif

    CString csResult = "OFF";

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings  idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, IDL_SETTINGS, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    switch (idlSettingsPacket.alarmGen.alarmType)
    {
    case IDL_PACKET2_ALARM_OFF:
        csResult = "OFF";
        break;
    case IDL_PACKET2_ALARM_CP_POWER_LOSS:
        csResult = "CPP";
        break;
    case IDL_PACKET2_ALARM_LOS:
        csResult = "LOS";
        break;
    case IDL_PACKET2_ALARM_LINK:
        csResult = "LINK";
        break;
    case IDL_PACKET2_ALARM_LOCAL_LINK_FAULT:
        csResult = "LF";
        break;
    case IDL_PACKET2_ALARM_REMOTE_LINK_FAULT:
        csResult = "RF";
        break;
    case IDL_PACKET2_ALARM_JABBER:
        csResult = "JABBER";
        break;
    case IDL_PACKET2_ALARM_GFP_LFD:
        csResult = "LFD";
        break;
    case IDL_PACKET2_ALARM_GFP_LOCS:
        csResult = "LOCS";
        break;
    case IDL_PACKET2_ALARM_GFP_LOCCS:
        csResult = "LOCCS";
        break;
    case IDL_PACKET2_ALARM_GFP_HDR_MISMMATCH:
    case IDL_PACKET2_ALARM_GFP_HDR_MISMATCH:
        csResult = "HDRMM";
        break;
    case IDL_PACKET2_ALARM_BLOCK_LOCK_LOSS:
        csResult = "BLKLOC";
        break;
    case IDL_PACKET2_ALARM_HI_BER:
        csResult = "HIBER";
        break;
    default:
        csResult = "None";
        break;
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


// ------------------------------ GFP

//***************************
// SET GFP PFCS
//***************************
void  ScpiPacket::setGfpPfcs (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:PFCS");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {

        if (!csScpiCmd.CollateNoCase("ON"))
        {
         idlSettingsPacket.gfpTxFcs = 1;
        }
        else if (!csScpiCmd.CollateNoCase("OFF"))
        {
         idlSettingsPacket.gfpTxFcs = 0;
        }
        else
        {
         m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }

    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
    }


    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_FCS;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:PFCS?
//***************************
void  ScpiPacket::getGfpPfcs (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:PFCS?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csResult;


   switch(idlSettingsPacket.gfpTxFcs)
   {
    case 1:
        csResult = "ON";
        break;
    case 0:
        csResult = "OFF";
        break;
        break;
    }
 m_pScpiProxyServer->scpiResults(csResult);
}



//***************************
// SET GFP EXI
//***************************
void  ScpiPacket::setGfpExi (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:Exi");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {

        if (!csScpiCmd.CollateNoCase("NULL"))
        {
         idlSettingsPacket.gfpTxExi = IDL_PACKET2_GFP_TX_EXI_NULL;
        }
        else if (!csScpiCmd.CollateNoCase("LINEAR"))
        {
         idlSettingsPacket.gfpTxExi = IDL_PACKET2_GFP_TX_EXI_LINEAR;
        }
        else if (!csScpiCmd.CollateNoCase("RING"))
        {
         idlSettingsPacket.gfpTxExi = IDL_PACKET2_GFP_TX_EXI_RING;
        }

        else
        {
         m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }

    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
    }


    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_EXI;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:EXI?
//***************************
void  ScpiPacket::getGfpExi (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:EXI?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    CString csResult;


   switch(idlSettingsPacket.gfpTxExi)
   {
    case IDL_PACKET2_GFP_TX_EXI_NULL:
        csResult = "NULL";
        break;
    case IDL_PACKET2_GFP_TX_EXI_LINEAR:
        csResult = "LINEAR";
        break;
    case IDL_PACKET2_GFP_TX_EXI_RING:
        csResult = "RING";
        break;
    }
 m_pScpiProxyServer->scpiResults(csResult);
}




//***************************
// SET GFP UPI
//***************************
void  ScpiPacket::setGfpUpi (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:UPI");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    //int uval;
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    DLI_UINT32 ulval = 0;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    //int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    // check second parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csNewString;
    CString csToken = token;


    // check if the parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csToken = token;
    if (csToken.Find('#') == 0)
    {
        if (csToken.Find("#h") == 0 || csToken.Find("#H") == 0)
        {
            csToken.TrimLeft("#");
            csToken.TrimLeft("h");
            csToken.TrimLeft("H");
            // check if the parameter still exists
            if (csToken.IsEmpty() || csToken == "")
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
            token = (char *)(LPCTSTR) csToken;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // the data must be converted from ascii to unsigned long value
        ulval = static_cast<DLI_UINT32>(CUtils::hexAsciiIntoInt(token));

    }
    else
        ulval = atoi(token);

    if (ulval < 0 || ulval > 255)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    idlSettingsPacket.gfpTxUpi = static_cast<CORBA::Octet>(ulval);

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_UPI;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:UPI?
//***************************
void  ScpiPacket::getGfpUpi (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:UPI?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csResult;

    csResult.Format("%d", idlSettingsPacket.gfpTxUpi);
    m_pScpiProxyServer->scpiResults(csResult);
}



//***************************
// SET GFP LEN
//***************************
void  ScpiPacket::setGfpLen (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:LEN");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    int length;
    // validate the string is digits only

    int i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {}else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
           return;
        }
        i++;
    }

    length = atoi(token);//to avoid decimal

    idlSettingsPacket.gfpTxLength = length;

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_LENGTH;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:LEN?
//***************************
void  ScpiPacket::getGfpLen (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:LEN?");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;



    CString csVal;
    csVal.Empty();
    int temp = idlSettingsPacket.gfpTxLength;
    csVal.Format("%d", temp);

    m_pScpiProxyServer->scpiResults(csVal);
}

///////////////////   SUPER BLOCK /////////////////////////////////////


//***************************
// TX:SUPERBLK
//***************************
void  ScpiPacket::setSuperBlock (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:SUPERBLK");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;
   int length;

    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");
    if (!csScpiCmd.CollateNoCase("AUTO"))
        length = 0;
    else
    {
        // Get Stream Id from the command string
        LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

        char seps[]   = " ";
        char *next_token;
        char *token = strtok_s( parms, seps , &next_token);

        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }



        // validate the string is digits only

        int i = 0;
        while (token[i] != NULL)
        {
            if (isdigit(token[i]) )
            {
                length = atoi(token);//to avoid decimal
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
               return;
            }
            i++;
        }


    }
    if ((length == 1)|| (length < 0 ) || (length > 0xFFFF))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }
    idlSettingsPacket.superBlocksPerFrame = length;

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_SUPER_BLOCK_PER;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:SUPERBLK?
//***************************
void  ScpiPacket::getSuperBlock (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:LENSUPERBLK
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;



    CString csVal;
    csVal.Empty();
    int temp = idlSettingsPacket.superBlocksPerFrame;
    if (temp == 0)
        csVal.Format("AUTO");
    else
        csVal.Format("%d", temp);

    m_pScpiProxyServer->scpiResults(csVal);
}



////////////    END SUPER BLOCK //////////////////////////////////////////
//***************************
// SET GFP RATE
//***************************
void  ScpiPacket::setGfpRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:RATE");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    int bWidth;
    // validate the string is digits only

    int i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {}else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
           return;
        }
        i++;
    }

    bWidth = static_cast<int>(atof(token) * 100);//to avoid decimal

    idlSettingsPacket.gfpTxRate = bWidth;

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_RATE;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:RATE?
//***************************
void  ScpiPacket::getGfpRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:RATE?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;



    CString csVal;
    csVal.Empty();
    float temp = idlSettingsPacket.gfpTxRate;
    temp = temp / 100;
    csVal.Format("%.2f%%", temp);

    m_pScpiProxyServer->scpiResults(csVal);
}



//***************************
// SET GFP CID
//***************************
void  ScpiPacket::setGfpCid (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:CID");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


    int cid;
    // validate the string is digits only

    int i = 0;
    while (token[i] != NULL)
    {
        if (isdigit(token[i]) || (token[i] == '.'))
        {}else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
           return;
        }
        i++;
    }

    cid = atoi(token);//to avoid decimal

    if (cid < 0 || cid > 255)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
        return;
    }
    idlSettingsPacket.gfpTxCid = cid;

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_CID;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// TX:CID?
//***************************
void  ScpiPacket::getGfpCid (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:CID?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;



    CString csVal;
    csVal.Empty();
    int temp = idlSettingsPacket.gfpTxCid;
    csVal.Format("%d", temp);

    m_pScpiProxyServer->scpiResults(csVal);
}


//***************************
// SET PORT MAP
//***************************
void  ScpiPacket::setPortMap (CString& csScpiCmd)
{
    txSetMode(csScpiCmd);
}

//***************************
// TX:MAP?
//***************************
void  ScpiPacket::getPortMap (CString& csScpiCmd)
{
    txGetMode(csScpiCmd);
}


//***************************
// RX:PAT
//***************************
void  ScpiPacket::setRxGfpPat (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nRX:PAT");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int userFlag = 0;


    DLI_UINT32 ulval = 0;


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    //int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


//    // get the second parameter
//    token = strtok_s( NULL, seps , &next_token);

    // check second parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csNewString;
    CString csToken = token;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {

        if (!csScpiCmd.CollateNoCase("PRBS9"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_9;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS9INV"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_9_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS11"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_11;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS11INV"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_11_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS15"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_15;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS15INV"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_15_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS20"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_20;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS20INV"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_20_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS23"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_23;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS23INV"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_23_INV;
        }
        else if ((!csScpiCmd.CollateNoCase("PRBS31")) || (!csScpiCmd.CollateNoCase("PRBS")))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_31;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS31INV"))
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_PRBS_31_INV;
        }
        else
        {
            idlSettingsPacket.gfpRxPattern = IDL_PACKET2_PATTERN_USER;
            userFlag = 1;
        }
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
    }

    // check if USER payload was selected
    if (userFlag)
    {

        // check if the parameter exists
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        csToken = token;
        if (csToken.Find('#') == 0)
        {
            if (csToken.Find("#b") == 0 || csToken.Find("#B") == 0)
            {
                csToken.TrimLeft("#");
                csToken.TrimLeft("#b");
                csToken.TrimLeft("#B");
                // check if the parameter still exists
                if (csToken.IsEmpty() || csToken == "")
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

                int bits = 0, tempInt = 0;
                CString csInt, csTempInt;

                bits = strlen(csToken);
                //looking for the string to be 32 bits long
                while (bits < 32)//if not 32 bits make it a little longer
                {
                    csToken += csToken;
                    bits = strlen(csToken);
                }

                token = (char *)(LPCTSTR) csToken;
                for (int index = 0; index < 8; index++)
                {
                    csInt = "";
                    for (int count4 = 0; count4 < 4; count4++)
                    {
                        csTempInt = token[(count4 + (index * 4))];
                        if (csTempInt == "1" || csTempInt == "0")
                            csInt += csTempInt;
                        else
                        {
                            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                            return;
                        }
                    }

                    if (csInt == "0000")//had to do if else vs switch case to preserve 4 char comparison.
                        csNewString += "0";
                    else if (csInt == "0001")
                        csNewString += "1";
                    else if (csInt == "0010")
                        csNewString += "2";
                    else if (csInt == "0011")
                        csNewString += "3";
                    else if (csInt == "0100")
                        csNewString += "4";
                    else if (csInt == "0101")
                        csNewString += "5";
                    else if (csInt == "0110")
                        csNewString += "6";
                    else if (csInt == "0111")
                        csNewString += "7";
                    else if (csInt == "1000")
                        csNewString += "8";
                    else if (csInt == "1001")
                        csNewString += "9";
                    else if (csInt == "1010")
                        csNewString += "a";
                    else if (csInt == "1011")
                        csNewString += "b";
                    else if (csInt == "1100")
                        csNewString += "c";
                    else if (csInt == "1101")
                        csNewString += "d";
                    else if (csInt == "1110")
                        csNewString += "e";
                    else if (csInt == "1111")
                        csNewString += "f";

                }//for index loop
                token = (char *)(LPCTSTR) csNewString;
            }else if (csToken.Find("#h") == 0 || csToken.Find("#H") == 0)
            {
                csToken.TrimLeft("#");
                csToken.TrimLeft("h");
                csToken.TrimLeft("H");
                // check if the parameter still exists
                if (csToken.IsEmpty() || csToken == "")
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }
                token = (char *)(LPCTSTR) csToken;
            }else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
        }
        // the data must be converted from ascii to unsigned long value
        ulval = static_cast<DLI_UINT32>(CUtils::hexAsciiIntoInt(token));

        // check the value to be within the limits
        if (ulval < STRMSETPAYLOAD_LOWERLIMIT || ulval > STRMSETPAYLOAD_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

    }
    // put in the structure
    idlSettingsPacket.gfpRxUserPattern = ulval;

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_RX_PATTERN;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// RX:PAT?
//***************************
void  ScpiPacket::getRxGfpPat (CString&)
{
#ifdef _MYDEBUG
    printf("\nRX:PAT?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csResult;

    switch(idlSettingsPacket.gfpRxPattern)
    {
    case IDL_PACKET2_PATTERN_USER:
        csResult.Format("#H%08x", idlSettingsPacket.gfpRxUserPattern);
        m_pScpiProxyServer->scpiResults(csResult);
        break;
    default:
        m_pScpiProxyServer->scpiResults("UNKNOWN");
        break;
    case IDL_PACKET2_PATTERN_PRBS_9:
        m_pScpiProxyServer->scpiResults("PRBS9");
        break;
    case IDL_PACKET2_PATTERN_PRBS_9_INV:
        m_pScpiProxyServer->scpiResults("PRBS9INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_11:
        m_pScpiProxyServer->scpiResults("PRBS11");
        break;
    case IDL_PACKET2_PATTERN_PRBS_11_INV:
        m_pScpiProxyServer->scpiResults("PRBS11INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_15:
        m_pScpiProxyServer->scpiResults("PRBS15");
        break;
    case IDL_PACKET2_PATTERN_PRBS_15_INV:
        m_pScpiProxyServer->scpiResults("PRBS15INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_20:
        m_pScpiProxyServer->scpiResults("PRBS20");
        break;
    case IDL_PACKET2_PATTERN_PRBS_20_INV:
        m_pScpiProxyServer->scpiResults("PRBS20INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_23:
        m_pScpiProxyServer->scpiResults("PRBS23");
        break;
    case IDL_PACKET2_PATTERN_PRBS_23_INV:
        m_pScpiProxyServer->scpiResults("PRBS23INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_31:
        m_pScpiProxyServer->scpiResults("PRBS31");
        break;
    case IDL_PACKET2_PATTERN_PRBS_31_INV:
        m_pScpiProxyServer->scpiResults("PRBS31INV");
        break;
    }
}




//------------------------------------------

//***************************
// TX:PAT
//***************************
void  ScpiPacket::setGfpPat (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:PAT");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int userFlag = 0;


    DLI_UINT32 ulval = 0;

    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    //int iStrmNum;
    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    //int len;
    //int i;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }


//    // get the second parameter
//  token = strtok_s( NULL, seps , &next_token);

    // check second parameter exists
    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csNewString;
    CString csToken = token;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {

        if (!csScpiCmd.CollateNoCase("PRBS9"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_9;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS9INV"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_9_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS11"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_11;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS11INV"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_11_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS15"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_15;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS15INV"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_15_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS20"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_20;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS20INV"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_20_INV;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS23"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_23;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS23INV"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_23_INV;
        }
        else if ((!csScpiCmd.CollateNoCase("PRBS31")) || (!csScpiCmd.CollateNoCase("PRBS")))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_31;
        }
        else if (!csScpiCmd.CollateNoCase("PRBS31INV"))
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_PRBS_31_INV;
        }
        else
        {
            idlSettingsPacket.gfpTxPattern = IDL_PACKET2_PATTERN_USER;
            userFlag = 1;
        }
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
    }

    // check if USER payload was selected
    if (userFlag)
    {

        // check if the parameter exists
        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        csToken = token;
        if (csToken.Find('#') == 0)
        {
            if (csToken.Find("#b") == 0 || csToken.Find("#B") == 0)
            {
                csToken.TrimLeft("#");
                csToken.TrimLeft("#b");
                csToken.TrimLeft("#B");
                // check if the parameter still exists
                if (csToken.IsEmpty() || csToken == "")
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

                int bits = 0, tempInt = 0;
                CString csInt, csTempInt;

                bits = strlen(csToken);
                //looking for the string to be 32 bits long
                while (bits < 32)//if not 32 bits make it a little longer
                {
                    csToken += csToken;
                    bits = strlen(csToken);
                }

                token = (char *)(LPCTSTR) csToken;
                for (int index = 0; index < 8; index++)
                {
                    csInt = "";
                    for (int count4 = 0; count4 < 4; count4++)
                    {
                        csTempInt = token[(count4 + (index * 4))];
                        if (csTempInt == "1" || csTempInt == "0")
                            csInt += csTempInt;
                        else
                        {
                            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                            return;
                        }
                    }

                    if (csInt == "0000")//had to do if else vs switch case to preserve 4 char comparison.
                        csNewString += "0";
                    else if (csInt == "0001")
                        csNewString += "1";
                    else if (csInt == "0010")
                        csNewString += "2";
                    else if (csInt == "0011")
                        csNewString += "3";
                    else if (csInt == "0100")
                        csNewString += "4";
                    else if (csInt == "0101")
                        csNewString += "5";
                    else if (csInt == "0110")
                        csNewString += "6";
                    else if (csInt == "0111")
                        csNewString += "7";
                    else if (csInt == "1000")
                        csNewString += "8";
                    else if (csInt == "1001")
                        csNewString += "9";
                    else if (csInt == "1010")
                        csNewString += "a";
                    else if (csInt == "1011")
                        csNewString += "b";
                    else if (csInt == "1100")
                        csNewString += "c";
                    else if (csInt == "1101")
                        csNewString += "d";
                    else if (csInt == "1110")
                        csNewString += "e";
                    else if (csInt == "1111")
                        csNewString += "f";

                }//for index loop
                token = (char *)(LPCTSTR) csNewString;
            }else if (csToken.Find("#h") == 0 || csToken.Find("#H") == 0)
            {
                csToken.TrimLeft("#");
                csToken.TrimLeft("h");
                csToken.TrimLeft("H");
                // check if the parameter still exists
                if (csToken.IsEmpty() || csToken == "")
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }
                token = (char *)(LPCTSTR) csToken;
            }else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }
        }
        // the data must be converted from ascii to unsigned long value
        ulval = static_cast<DLI_UINT32>(CUtils::hexAsciiIntoInt(token));

        // check the value to be within the limits
        if (ulval < STRMSETPAYLOAD_LOWERLIMIT || ulval > STRMSETPAYLOAD_UPPERLIMIT)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
            return;
        }

    }
    // put in the structure
    idlSettingsPacket.gfpTxUserPattern = ulval;

    idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_PATTERN;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// TX:PAT?
//***************************
void  ScpiPacket::getGfpPat (CString&)
{
#ifdef _MYDEBUG
    printf("\nTX:PAT?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csResult;

    switch(idlSettingsPacket.gfpTxPattern)
    {
    case IDL_PACKET2_PATTERN_USER:
        csResult.Format("#H%08x", idlSettingsPacket.gfpTxUserPattern);
        m_pScpiProxyServer->scpiResults(csResult);
        break;
    default:
        m_pScpiProxyServer->scpiResults("UNKNOWN");
        break;
    case IDL_PACKET2_PATTERN_PRBS_9:
        m_pScpiProxyServer->scpiResults("PRBS9");
        break;
    case IDL_PACKET2_PATTERN_PRBS_9_INV:
        m_pScpiProxyServer->scpiResults("PRBS9INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_11:
        m_pScpiProxyServer->scpiResults("PRBS11");
        break;
    case IDL_PACKET2_PATTERN_PRBS_11_INV:
        m_pScpiProxyServer->scpiResults("PRBS11INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_15:
        m_pScpiProxyServer->scpiResults("PRBS15");
        break;
    case IDL_PACKET2_PATTERN_PRBS_15_INV:
        m_pScpiProxyServer->scpiResults("PRBS15INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_20:
        m_pScpiProxyServer->scpiResults("PRBS20");
        break;
    case IDL_PACKET2_PATTERN_PRBS_20_INV:
        m_pScpiProxyServer->scpiResults("PRBS20INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_23:
        m_pScpiProxyServer->scpiResults("PRBS23");
        break;
    case IDL_PACKET2_PATTERN_PRBS_23_INV:
        m_pScpiProxyServer->scpiResults("PRBS23INV");
        break;
    case IDL_PACKET2_PATTERN_PRBS_31:
        m_pScpiProxyServer->scpiResults("PRBS31");
        break;
    case IDL_PACKET2_PATTERN_PRBS_31_INV:
        m_pScpiProxyServer->scpiResults("PRBS31INV");
        break;
   }
 //m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// TX:MODE
//***************************
void  ScpiPacket::txSetMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:MODE");
#endif
    bool setInterface = false;
    bool setMapping = false;
    CORBA::Any_var anyStructureVar=new CORBA::Any;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* idlPacket2AllowedSettings;
    IdlPacket2AllowedSettings  idlAllow;

//portInterfaceMask

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    idlSettingsPacket = *idlSettingsPacketPtr;
    anyStructureVar <<= idlSettingsPacket;

    // Get Allowed settings
    TestCmdGetStatus(callGetAllowedSettings(anyStructureVar, m_globs));
    if( !(anyStructureVar >>= idlPacket2AllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    idlAllow = *idlPacket2AllowedSettings;

    // Default to off and fill in below
    // if , else if's got so large we need to break it into
    // two if else if groups.
    // This will be used to continue or skip the second if set
    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OFF;

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        //if (dualt or mpm100)
        if ((m_boardRevision != IDL_DLI_CARD_PC) &&
            (m_boardRevision != IDL_DLI_ETX_NT)  &&
            (m_boardRevision != IDL_DLI_ETX_XP)  &&
            (m_boardRevision != IDL_DLI_Q7_XP)   &&
            (m_boardRevision != IDL_DLI_Q7_WIN7) &&
            (m_boardRevision != IDL_SHOWROOM))
        {
            if (idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP)
            {
                setInterface = false;
                setMapping   = true;
                if (!csScpiCmd.CollateNoCase("FRAMED"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_GFP_FRAMED_ENET))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET;
                }
                else if (!csScpiCmd.CollateNoCase("BULK"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_GFP_PRBS))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_GFP_PRBS;
                }
                else if (!csScpiCmd.CollateNoCase("TRANSPARENT"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_GFP_TRANSPARENT_GBE))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE;
                }
                else if (!csScpiCmd.CollateNoCase("10M@FULL") ||
                         !csScpiCmd.CollateNoCase("10T_LAN_FULL"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_10T_ENET_FULL))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_10T_ENET_FULL;
                }
                else if (!csScpiCmd.CollateNoCase("100M@FULL") ||
                         !csScpiCmd.CollateNoCase("100T_LAN_FULL"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_100T_ENET_FULL))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_100T_ENET_FULL;
                }
                else if (!csScpiCmd.CollateNoCase("1G@FULL") ||
                         !csScpiCmd.CollateNoCase("1000T_LAN_FULL"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_1000T_ENET_FULL))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_1000T_ENET_FULL;
                }
                else if (!csScpiCmd.CollateNoCase("2.5G@FULL"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_2500T_ENET))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_2500T_ENET;
                }
                else if (!csScpiCmd.CollateNoCase("10G@FULL") ||
                         !csScpiCmd.CollateNoCase("10000T_LAN_FULL"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_10000T_ENET))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_10000T_ENET;
                }
                else if (!csScpiCmd.CollateNoCase("100M@OPTICAL") ||
                         !csScpiCmd.CollateNoCase("100M_LAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_100M_ENET_FULL))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_100M_ENET_FULL;
                }
                else if (!csScpiCmd.CollateNoCase("1G@OPTICAL") ||
                         !csScpiCmd.CollateNoCase("1G_LAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_1G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_1G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2.5G@OPTICAL") ||
                         !csScpiCmd.CollateNoCase("2_5G_LAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_2_5G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_2_5G_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("10G@OPTICAL")) || (!csScpiCmd.CollateNoCase("LAN")))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_10G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_10G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("SEED_AB_25G"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_25G_SEED_AB))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_25G_SEED_AB;
                }
                else if (!csScpiCmd.CollateNoCase("SEED_AB"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_SEED_AB))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_SEED_AB;
                }
                else if (!csScpiCmd.CollateNoCase("10_312GE_XAUI_SFP") ||
                         !csScpiCmd.CollateNoCase("10G_LAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_OMR_10G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_10G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_10_312GE_XAUI_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD10_QUAD_10G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD10_QUAD_10G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_10_312GE_XAUI_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP10_QUAD_10G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP10_QUAD_10G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_10_312GE_XAUI_QSFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP10_QUAD_10G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP10_QUAD_10G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("25_781GE_25GAUI_SFP") ||
                         !csScpiCmd.CollateNoCase("25G_LAN"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_25G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_25G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_25GAUI_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD28_QUAD_25G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_QUAD_25G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_25GAUI_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_QUAD_25G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_QUAD_25G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_25GAUI_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_QUAD_25G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_QUAD_25G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_25GAUI_QSFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP28_QUAD_25G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP28_QUAD_25G_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("25_781GE_KR_25GAUI_SFP")) ||
                         (!csScpiCmd.CollateNoCase("25G_FEC_LAN"))            ||
                         (!csScpiCmd.CollateNoCase("25G_LAN_FEC")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_25G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_25G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_KR_25GAUI_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD28_QUAD_25G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_QUAD_25G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_KR_25GAUI_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_QUAD_25G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_QUAD_25G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_KR_25GAUI_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_QUAD_25G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_QUAD_25G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_25_781GE_KR_25GAUI_QSFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP28_QUAD_25G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP28_QUAD_25G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("50G_LAN"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_50G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_50G_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI1_SFP")) ||
                         (!csScpiCmd.CollateNoCase("50G_LAN_FEC")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI2_QSFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD28_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI2_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("8X_53_125G_KP4_50GAUI1_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD_OCTAL_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("8X_53_125G_KP4_50GAUI1_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_OCTAL_50G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_OCTAL_50G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("41_25G_XLAUI_QSFP") ||
                         !csScpiCmd.CollateNoCase("41G_LAN_QSFP")      ||
                         !csScpiCmd.CollateNoCase("41G_LAN_CFP")       ||
                         !csScpiCmd.CollateNoCase("41G_LAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_MLD_41G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_41G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_CAUI4_CFP") ||
                         !csScpiCmd.CollateNoCase("103G_LAN_CFP28") ||
                         !csScpiCmd.CollateNoCase("103G_LAN_CFP") ||
                         !csScpiCmd.CollateNoCase("103G_LAN"))
                {
                    if ((!(idlAllow.portMappingMask  & IDL_PACKET2_PORT_MAPPING_MASK_MLD_103G_LAN)) &&
                        (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_103G_LAN)))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    if (idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_MLD_103G_LAN)
                        idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_103G_LAN;
                    else
                        idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_KR4_CAUI4_CFP") ||
                         !csScpiCmd.CollateNoCase("103G_LAN_FEC_CFP28") ||
                         !csScpiCmd.CollateNoCase("103G_LAN_FEC_CFP")        ||
                         !csScpiCmd.CollateNoCase("103G_LAN_FEC"))
                {
                    if ((!(idlAllow.portMappingMask  & IDL_PACKET2_PORT_MAPPING_MASK_MLD_103G_FEC_LAN)) &&
                        (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_103G_FEC_LAN)))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    if (idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_MLD_103G_FEC_LAN)
                        idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_103G_FEC_LAN;
                    else
                        idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("103_125GE_CAUI4_QSFP")) ||
                         (!csScpiCmd.CollateNoCase("103G_LAN_QSFP")))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_MLD_QSFP_103G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_CAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD28_103G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_CAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_103G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_CAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD28_103G_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_CAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_103G_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("103_125GE_KR4_CAUI4_QSFP")) ||
                         (!csScpiCmd.CollateNoCase("103G_LAN_FEC_QSFP")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103G_LAN_QSFP56"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP56_103G_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("103G_LAN_FEC_QSFP56")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_QSFP")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP56_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("103G_LAN_FEC_QSFP_DD")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_QSFPDD")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_103G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("103G_LAN_FEC_OSFP")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_OSFP")))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD56_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD56_103G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_103G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_103G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN_P1P2;
                }

                else if ((!csScpiCmd.CollateNoCase("103G_LAN_FEC_CFP")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_CFP")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP56_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP56_103G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("103_125GE_KR4_CAUI4_QSFPDD")) ||
                         (!csScpiCmd.CollateNoCase("103G_LAN_FEC_QSFP_DD28")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD28_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("103_125GE_KR4_CAUI4_OSFP")) ||
                         (!csScpiCmd.CollateNoCase("103G_LAN_FEC_OSFP28")))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_KR4_CAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD28_103G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_KR4_CAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_103G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("103G_LAN_FLEXE_QSFP"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_103G_LAN_FLEXE))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN_FLEXE;
                }
                else if (!csScpiCmd.CollateNoCase("103G_LAN_FLEXE_QSFP56"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP56_103G_LAN_FLEXE))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_LAN_FLEXE;
                }
                else if (!csScpiCmd.CollateNoCase("8X_106_25GE_KP4_100GAUI1_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_OCTAL_106G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_106G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("8X_106_25GE_KP4_100GAUI1_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_OCTAL_106G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_OCTAL_106G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("8X_106_25GE_KP4_100GAUI1_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_QSFP_DD_OCTAL_106G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_106G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("8X_106_25GE_KP4_100GAUI1_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_OCTAL_106G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_OCTAL_106G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI1_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_QUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_QUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI1_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_QUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI1_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_DQUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_DQUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI1_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_DQUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_DQUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD_QUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_QUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_QUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_QUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI2_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD_DQUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DQUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI2_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_DQUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_DQUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_106_25GE_KP4_100GAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD28_DUAL_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_DUAL_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_106_25GE_KP4_100GAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_DUAL_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_DUAL_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI2_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP56_QUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP56_QUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_106_25GE_KP4_100GAUI2_P1P2_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP56_DQUAD_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP56_DQUAD_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_106_25GE_KP4_100GAUI4_CFP"))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_DUAL_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_DUAL_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI1_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI1_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_103G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_103G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI1_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_103G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_103G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI1_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_103G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_103G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("106G_LAN_FEC_QSFP")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI4_QSFP")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_106G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_106G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("106G_LAN_FEC_QSFP_DD28")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI4_QSFPDD")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_QSFP_DD28_106G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_106G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("106G_LAN_FEC_OSFP")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI4_OSFP")))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_106G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_106G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD28_106G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_106G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_106G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_106G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("106G_LAN_FEC_CFP28")) ||
                         (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI4_CFP")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_106G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_106G_FEC_LAN;
                }

// if on purpose, if else if's got too large "C1061: compiler limit : blocks nested too deeply"
                if (idlSettingsPacket.portMapping != IDL_PACKET2_PORT_MAP_OFF)
                {
                    // Found already skip the rest below
                }
                else if (!csScpiCmd.CollateNoCase("212G_LAN_FEC_CFP") ||
                         !csScpiCmd.CollateNoCase("212G_LAN_FEC"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212G_LAN_FEC_QSFP"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI2_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI2_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_DUAL_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_DUAL_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_DUAL_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI2_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_DUAL_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_DUAL_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI2_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_DUAL_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("4X_212_5GE_KP4_200GAUI2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_QUAD_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_QUAD_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_212_5GE_KP4_200GAUI2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_QUAD_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("4X_212_5GE_KP4_200GAUI2_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_QUAD_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_QUAD_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("4X_212_5GE_KP4_200GAUI2_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_QUAD_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_212G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("212G_LAN_FEC_QSFP_DD")) ||
                         (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_QSFPDD")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_212G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("212G_LAN_FEC_OSFP")) ||
                         (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_OSFP")))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD56_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP56_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("212G_LAN_FEC_QSFP_DD28")) ||
                         (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI8_QSFPDD")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD28_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_212G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("212G_LAN_FEC_OSFP28")) ||
                         (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI8_OSFP")))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP28_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI8_P1P2_QSFPDD")))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD28_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_212G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI8_P1P2_OSFP")))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP28_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("212G_LAN_FEC_CFP56")) ||
                         (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI4_CFP")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP56_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP56_212G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("212G_LAN_FEC_CFP28")) ||
                         (!csScpiCmd.CollateNoCase("212_5GE_KP4_200GAUI8_CFP")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP28_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP28_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD56_DUAL_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_DUAL_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_DUAL_212G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_DUAL_212G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD56_DUAL_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_DUAL_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("2X_212_5GE_KP4_200GAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP56_DUAL_212G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_DUAL_212G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI16_CFP") ||
                         !csScpiCmd.CollateNoCase("425G_LAN_FEC_CFP") ||
                         !csScpiCmd.CollateNoCase("425G_LAN_FEC"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_425G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("425G_LAN_FEC_QSFP_DD")) ||
                         (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI8_QSFPDD")))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN;
                }
                else if ((!csScpiCmd.CollateNoCase("425G_LAN_FEC_OSFP")) ||
                         (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI8_OSFP")))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI8_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_425G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI8_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP56_425G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD112_425G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_425G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("2X_425GE_KP4_400GAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_DUAL_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DUAL_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_425GE_KP4_400GAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_DUAL_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_425GE_KP4_400GAUI4_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_DUAL_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DUAL_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_425GE_KP4_400GAUI4_OSFP"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_DUAL_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("2X_425GE_KP4_400GAUI4_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_DUAL_425G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DUAL_425G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("2X_425GE_KP4_400GAUI4_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask6 & IDL_PACKET2_PORT_MAPPING_MASK6_MLD_OSFP112_DUAL_425G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_425G_FEC_LAN_P1P2;
                }
                else if ((!csScpiCmd.CollateNoCase("425G_LAN_FEC_CFP56")) ||
                         (!csScpiCmd.CollateNoCase("425GE_KP4_400GAUI8_CFP")))
                {
                    if (!(idlAllow.portMappingMask3 & IDL_PACKET2_PORT_MAPPING_MASK3_MLD_CFP56_425G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_CFP56_425G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_850G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_850G_FEC_LAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_850G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_850G_FEC_LAN_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_ETC_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_850G_FEC_LAN_ETC))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_ETC_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_850G_FEC_LAN_ETC))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_ETC_P1P2_QSFPDD"))
                {
                    if (!(idlAllow.portMappingMask4 & IDL_PACKET2_PORT_MAPPING_MASK4_MLD_QSFP_DD_850G_FEC_LAN_ETC_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("850GE_KP4_800GAUI8_ETC_P1P2_OSFP"))
                {
                    if (!(idlAllow.portMappingMask5 & IDL_PACKET2_PORT_MAPPING_MASK5_MLD_OSFP112_850G_FEC_LAN_ETC_P1P2))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC_P1P2;
                }
                else if (!csScpiCmd.CollateNoCase("1G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_1G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_1G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("2G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_2G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_2G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("4G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_4G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_4G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("8G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_8G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_8G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("10G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_10G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_10G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("16G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_16G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_16G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("16G_FEC_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_16G_FEC_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_16G_FEC_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("32G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_32G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_32G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("64G_FIBRECHAN"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_64G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_64G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("128G_FIBRECHAN_CFP"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_112G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_112G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("128G_FIBRECHAN_QSFP"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_112G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_112G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("128G_FIBRECHAN_QSFP56"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP56_112G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP56_112G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("256G_FIBRECHAN_CFP"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_231G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_231G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("256G_FIBRECHAN_QSFP"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_231G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_231G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("256G_FIBRECHAN_QSFP_DD"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD_231G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_231G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("256G_FIBRECHAN_QSFP_DD28"))
                {
                    if (!(idlAllow.portMappingMask2 & IDL_PACKET2_PORT_MAPPING_MASK2_MLD_QSFP_DD28_231G_FIBERCHAN))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_231G_FIBERCHAN;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI1_P1P8_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD112_106G_FEC_LAN_P1P8))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD112_106G_FEC_LAN_P1P8;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI1_P1P4_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD112_106G_FEC_LAN_P1P4))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD112_106G_FEC_LAN_P1P4;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_P1P8_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD56_106G_FEC_LAN_P1P8))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_106G_FEC_LAN_P1P8;
                }
                else if (!csScpiCmd.CollateNoCase("106_25GE_KP4_100GAUI2_P1P4_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD56_106G_FEC_LAN_P1P4))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_106G_FEC_LAN_P1P4;
                }
                else if (!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI1_P1P8_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD56_53G_FEC_LAN_P1P8))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_53G_FEC_LAN_P1P8;
                }
                else if (!csScpiCmd.CollateNoCase("53_125GE_KP4_50GAUI1_P1P4_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD56_53G_FEC_LAN_P1P4))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_53G_FEC_LAN_P1P4;
                }
                else if (!csScpiCmd.CollateNoCase("2X_53_125GE_KP4_50GAUI1_P1P8_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD56_DUAL_53G_FEC_LAN_P1P8))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_DUAL_53G_FEC_LAN_P1P8;
                }
                else if (!csScpiCmd.CollateNoCase("25_781GE_25GAUI_SFP_P1P8_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD28_25G_LAN_P1P8))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD28_25G_LAN_P1P8;
                }
                else if (!csScpiCmd.CollateNoCase("25_781GE_KR_25GAUI_SFP_P1P8_SFPDD"))
                {
                    if (!(idlAllow.portMappingMask7 & IDL_PACKET2_PORT_MAPPING_MASK7_MLD_SFP_DD28_25G_FEC_LAN_P1P8))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_SFP_DD28_25G_FEC_LAN_P1P8;
                }
                else if (!csScpiCmd.CollateNoCase("NOT_ASSIGNED"))
                {
                    // Currently there isn't an off mask so allow it all the time
                    //
                    //if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK))
                    //{
                    //    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                    //    return;
                    //}
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OFF;
                }
                else
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                    return;
                }
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (m_globs->g_ppType == IDL_PP_NG2_1G_ENET)// this checks if the port can be set
        {
            setInterface = true;
            setMapping   = false;
            if(!csScpiCmd.CollateNoCase("AUTO"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_AUTO_NEG;
                idlSettingsPacket.reference = IDL_PACKET2_REF_PORT_INTERFACE;
                idlSettingsPacket.restartInhibit = TRUE;

                anyStructure<<=idlSettingsPacket;
                m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
                return;
            }
            if (!csScpiCmd.CollateNoCase("10M@FULL") ||
                !csScpiCmd.CollateNoCase("10T_LAN_FULL"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_10T_ENET_FULL;
            }
            else if (!csScpiCmd.CollateNoCase("100M@FULL") ||
                     !csScpiCmd.CollateNoCase("100T_LAN_FULL"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_100T_ENET_FULL;
            }
            else if (!csScpiCmd.CollateNoCase("1G@FULL") ||
                     !csScpiCmd.CollateNoCase("1000T_LAN_FULL"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_1000T_ENET_FULL;
            }
            else if (!csScpiCmd.CollateNoCase("2.5G@FULL"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_2500T_ENET;
            }
            else if (!csScpiCmd.CollateNoCase("5G@FULL"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_5000T_ENET;
            }
            else if (!csScpiCmd.CollateNoCase("10G@FULL") ||
                     !csScpiCmd.CollateNoCase("10000T_LAN_FULL"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_10000T_ENET;
            }
            else if (!csScpiCmd.CollateNoCase("10M@HALF"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_10T_ENET_HALF;
            }
            else if (!csScpiCmd.CollateNoCase("100M@HALF"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_100T_ENET_HALF;
            }
            else if (!csScpiCmd.CollateNoCase("1G@HALF"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_1000T_ENET_HALF;
            }
            else if  (!csScpiCmd.CollateNoCase("2.5G@OPTICAL") ||
                      !csScpiCmd.CollateNoCase("2_5G_LAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_2_5G_ENET;
            }
            else if  (!csScpiCmd.CollateNoCase("1G@OPTICAL") ||
                      !csScpiCmd.CollateNoCase("1G_LAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_1G_ENET_FULL;
            }
            else if  (!csScpiCmd.CollateNoCase("100M@OPTICAL") ||
                      !csScpiCmd.CollateNoCase("100M_LAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_100M_ENET_FULL;
            }
            else if (!csScpiCmd.CollateNoCase("1G_FIBRECHAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_1G_FIBERCHAN;
            }

            else if (!csScpiCmd.CollateNoCase("2G_FIBRECHAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_2G_FIBERCHAN;
            }
            else if (!csScpiCmd.CollateNoCase("4G_FIBRECHAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_4G_FIBERCHAN;
            }
            else if (!csScpiCmd.CollateNoCase("8G_FIBRECHAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_8G_FIBERCHAN;
            }
            else if (!csScpiCmd.CollateNoCase("10G_FIBRECHAN"))
            {
                idlSettingsPacket.portInterface = IDL_PACKET2_PORT_INTERFACE_10G_FIBERCHAN;
            }
            else
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
            }
        }
        else if (idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP)
        {
            setInterface = false;
            setMapping   = true;
            switch (idlSettingsPacket.portMapping)
            {
            case IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET:
            case IDL_PACKET2_PORT_MAP_GFP_PRBS:
            case IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE:
                if (!csScpiCmd.CollateNoCase("FRAMED"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_GFP_FRAMED_ENET))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET;
                }
                else if (!csScpiCmd.CollateNoCase("BULK"))
                {
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_GFP_PRBS;
                }
                else if (!csScpiCmd.CollateNoCase("TRANSPARENT"))
                {
                    if (!(idlAllow.portMappingMask & IDL_PACKET2_PORT_MAPPING_MASK_GFP_TRANSPARENT_GBE))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                        return;
                    }
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE;
                }
                else
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                    return;
                }
                break;

            case IDL_PACKET2_PORT_MAP_OMR_10G_WAN:
                if (!csScpiCmd.CollateNoCase("WAN"))
                {
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_10G_WAN;
                }
                else
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                    return;
                }
                break;

            case IDL_PACKET2_PORT_MAP_OMR_10G_LAN:
            case IDL_PACKET2_PORT_MAP_SEED_AB:
                if (!csScpiCmd.CollateNoCase("LAN"))
                {
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_OMR_10G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("SEED_AB"))
                {
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_SEED_AB;
                }
                else
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                    return;
                }
                break;
            case IDL_PACKET2_PORT_MAP_MLD_41G_LAN:
            case IDL_PACKET2_PORT_MAP_MLD_103G_LAN:
            case IDL_PACKET2_PORT_MAP_OFF:
                if (!csScpiCmd.CollateNoCase("41G_LAN_CFP") ||
                    !csScpiCmd.CollateNoCase("41G_LAN"))
                {
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_41G_LAN;
                }
                else if (!csScpiCmd.CollateNoCase("103_125GE_CAUI4_CFP") ||
                         !csScpiCmd.CollateNoCase("103G_LAN_CFP") ||
                         !csScpiCmd.CollateNoCase("103G_LAN"))
                {
                    idlSettingsPacket.portMapping = IDL_PACKET2_PORT_MAP_MLD_103G_LAN;
                }
                else
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                    return;
                }
                break;
            default:
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
                return;
                break;
            }
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if (setMapping)
    {
        IdlReturnType status = (IdlReturnType) ScpiProxyServer::DLI_NO_ERROR;

        if (setInterface)
        {
            idlSettingsPacket.reference = IDL_PACKET2_REF_PORT_INTERFACE;
            idlSettingsPacket.restartInhibit = TRUE;

            anyStructure<<=idlSettingsPacket;
            status = (IdlReturnType) callSetAllSettings(anyStructure, m_globs);
        }

        if (status == ScpiProxyServer::DLI_NO_ERROR)
        {
            idlSettingsPacket.reference = IDL_PACKET2_REF_PORT_MAPPING;
            idlSettingsPacket.restartInhibit = TRUE;

            anyStructure<<=idlSettingsPacket;
            status = (IdlReturnType) callSetAllSettings(anyStructure, m_globs);
        }
        m_pScpiProxyServer->ReportCmdSetStatus(status);
    }
    else if (setInterface)
    {
        idlSettingsPacket.reference = IDL_PACKET2_REF_PORT_INTERFACE;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
    }
}


//***************************
// TX:MODE? also TX:STATUS?
//***************************
void  ScpiPacket::txGetMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:MODE?");
#endif


    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));


    CString m_csStatusMode;

    switch(idlStatPacket.portInterfaceState)
    {
    default:
    case   IDL_PACKET2_PORT_INTERFACE_STATE_OFF:
        m_csStatusMode = "Missing Module?";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10T_ENET_FULL:
        m_csStatusMode = "10 Mbps electrical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_100T_ENET_FULL:
        m_csStatusMode = "100 Mbps electrical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_1000T_ENET_FULL:
        m_csStatusMode = "1 Gbps electrical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_2500T_ENET:
        m_csStatusMode = "2.5 Gbps electrical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_5000T_ENET:
        m_csStatusMode = "5 Gbps electrical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10000T_ENET:
        m_csStatusMode = "10 Gbps electrical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10M_ENET_FULL:
        m_csStatusMode = "10 Mbps optical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_100M_ENET_FULL:
        m_csStatusMode = "100 Mbps optical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_1G_ENET_FULL:
        m_csStatusMode = "1 Gbps optical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_2_5G_ENET:
        m_csStatusMode = "2.5 Gbps optical, Full Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10G_ENET_FULL:
        switch(idlSettingsPacket.portMapping)
        {
        case IDL_PACKET2_PORT_MAP_FRAMED_STREAMS:
        default:
            m_csStatusMode = "10 Gbps LAN optical";
            break;
        case IDL_PACKET2_PORT_MAP_SEED_AB:
            m_csStatusMode = "SEED_AB";
            break;
        }
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_25G_LAN:
        m_csStatusMode = "25 Gbps LAN optical";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_50G_LAN:
        m_csStatusMode = "50 Gbps LAN optical";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_41G_ENET_FULL:
        m_csStatusMode = "40 Gbps LAN optical";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_103G_ENET_FULL:
        m_csStatusMode = "100 Gbps LAN optical";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_212G_ENET_FULL:
        m_csStatusMode = "200 Gbps LAN optical";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_425G_ENET_FULL:
        m_csStatusMode = "400 Gbps LAN optical";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10T_ENET_HALF:
        m_csStatusMode = "10 Mbps electrical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_100T_ENET_HALF:
        m_csStatusMode = "100 Mbps electrical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_1000T_ENET_HALF:
        m_csStatusMode = "1 Gbps electrical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10M_ENET_HALF:
        m_csStatusMode = "10 Mbps optical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_100M_ENET_HALF:
        m_csStatusMode = "100 Mbps optical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_1G_ENET_HALF:
        m_csStatusMode = "1 Gbps optical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10G_ENET_HALF:
        m_csStatusMode = "10 Gbps optical, Half Duplex";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_ADD_DROP:
        m_csStatusMode = "MultiRate add/drop";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_10G_ENET_WAN:
        m_csStatusMode = "9.953 Gbps WAN optical";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_AUTO_NEG_PEND:
        m_csStatusMode = "Auto negotiate pending";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_AUTO_NEG_NO_AUTO:
        m_csStatusMode = "Partner can't auto negotiate";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_AUTO_NEG_NO_RATE:
        m_csStatusMode = "Partner incompatible rate";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_PENDING_LINK:
        m_csStatusMode = "Pending link";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_STATE_GFP:
        switch(idlSettingsPacket.portMapping)
        {
        default:
            m_csStatusMode = "Unknown GFP";
            break;
        case IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET:
            m_csStatusMode = "FRAMED";
            break;
        case IDL_PACKET2_PORT_MAP_GFP_PRBS:
            m_csStatusMode = "BULK";
            break;
        case IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE:
            m_csStatusMode = "TRANSPARENT";
            break;
        case IDL_PACKET2_PORT_MAP_GFP_10G_LAN:
            m_csStatusMode = "64/66B GFP encode 10G LAN";
            break;
        }
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_1G_FIBERCHAN:
        m_csStatusMode = "1G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_2G_FIBERCHAN:
        m_csStatusMode = "2G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_4G_FIBERCHAN:
        m_csStatusMode = "4G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_8G_FIBERCHAN:
        m_csStatusMode = "8G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_10G_FIBERCHAN:
        m_csStatusMode = "10G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_16G_FIBERCHAN:
        m_csStatusMode = "16G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_32G_FIBERCHAN:
        m_csStatusMode = "32G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_64G_FIBERCHAN:
        m_csStatusMode = "64G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_112G_FIBERCHAN:
        m_csStatusMode = "128G_FIBRECHAN";
        break;
    case IDL_PACKET2_PORT_INTERFACE_STATE_256G_FIBERCHAN:
        m_csStatusMode = "256G_FIBRECHAN";
        break;
    }

    m_pScpiProxyServer->scpiResults(m_csStatusMode);
}

//***************************
// TX:IPREFLECTION
//***************************
void  ScpiPacket::txSetIPReflection (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:IPR");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        if (!csScpiCmd.CollateNoCase("IP"))
        {
         idlSettingsPacket.bounceModeEnable = IDL_PACKET2_BOUNCE_NON_DLI;
        }
        else if ((!csScpiCmd.CollateNoCase("ON")) || (!csScpiCmd.CollateNoCase("DLI")) )
        {
         idlSettingsPacket.bounceModeEnable = IDL_PACKET2_BOUNCE_DLI;
        }
        else if ((!csScpiCmd.CollateNoCase("ON")) || (!csScpiCmd.CollateNoCase("THRU")) )
        {
         idlSettingsPacket.bounceModeEnable = IDL_PACKET2_BOUNCE_THRUMODE;
        }
        else if (!csScpiCmd.CollateNoCase("OFF"))
        {
         idlSettingsPacket.bounceModeEnable = IDL_PACKET2_BOUNCE_OFF;
        }
        else
        {
         m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_BOUNCE_MODE_ENABLE;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// TX:IPREFLECTION?
//***************************
void  ScpiPacket::txGetIPReflection (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:IPR?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    switch(idlSettingsPacket.bounceModeEnable)
    {
    case IDL_PACKET2_BOUNCE_NON_DLI:
        m_pScpiProxyServer->scpiResults("IP");
        break;
    case IDL_PACKET2_BOUNCE_DLI:
        m_pScpiProxyServer->scpiResults("DLI");
        break;
    case IDL_PACKET2_BOUNCE_THRUMODE:
        m_pScpiProxyServer->scpiResults("THRU");
        break;
    default:
    case IDL_PACKET2_BOUNCE_OFF:
        m_pScpiProxyServer->scpiResults("OFF");
        break;
    }

}


//***************************
// TX:EMIXMODE
//***************************
void  ScpiPacket::txSetEmixMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:EMIXMODE");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    if (!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        if (!csScpiCmd.CollateNoCase("ID337"))
        {
            idlSettingsPacket.emixMode = IDL_PACKET2_EMIX_ID337;
        }
        else if (!csScpiCmd.CollateNoCase("VARIABLE"))
        {
            idlSettingsPacket.emixMode = IDL_PACKET2_EMIX_VARIABLE;
        }
        else if (!csScpiCmd.CollateNoCase("OFF"))
        {
            idlSettingsPacket.emixMode = IDL_PACKET2_EMIX_OFF;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }

        idlSettingsPacket.reference = IDL_PACKET2_REF_EMIX_MODE;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}


//***************************
// TX:EMIXMODE?
//***************************
void  ScpiPacket::txGetEmixMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:EMIXMODE?");
#endif
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    switch(idlSettingsPacket.emixMode)
    {
    case IDL_PACKET2_EMIX_ID337:
        m_pScpiProxyServer->scpiResults("ID337");
        break;
    case IDL_PACKET2_EMIX_VARIABLE:
        m_pScpiProxyServer->scpiResults("VARIABLE");
        break;
    default:
    case IDL_PACKET2_EMIX_OFF:
        m_pScpiProxyServer->scpiResults("OFF");
        break;
    }
}


//***************************
// TX:AUTO
//***************************
void  ScpiPacket::txSetAutoNeg (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:AUTO");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
       if (!csScpiCmd.CollateNoCase("ON"))
        {
         idlSettingsPacket.autoNegotiateEnable = IDL_ON_STATE;
        }
        else if (!csScpiCmd.CollateNoCase("OFF"))
        {
         idlSettingsPacket.autoNegotiateEnable = IDL_OFF_STATE;
        }
        else
        {
         m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_AUTO_NEG_ENABLE;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

//***************************
// TX:AUTO?
//***************************
void  ScpiPacket::txGetAutoNeg (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:AUTO?");
#endif

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if(idlSettingsPacket.autoNegotiateEnable == IDL_ON_STATE)
   {
      m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
   }
   else
   {
       m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
   }
}

//*****************************************
//       TX:ALarm LEVEL PROCESSING
//*****************************************
void ScpiPacket::doTxAlarmLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, txAlarmLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//*****************************************
//       TX:ERRor LEVEL PROCESSING
//*****************************************
void ScpiPacket::doTxErrLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, txErrLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// TX:ERRor:RATE
//***************************
void ScpiPacket::txSetErrRate (CString& csScpiCmd)
{
#ifdef _MYDEBUG
     printf("\nTX:ERRor:RATE");
#endif

   CORBA::Any_var anyStructure=new CORBA::Any;
   IdlPacket2AllSettings  idlSettingsPacket;
   IdlPacket2AllSettings* idlSettingsPacketPtr;
   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

   // Need to get the Type so not to change it when doing the setting.
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    // For Single type
    IdlOp1Struct    singleErr;

    // Flush any spaces
    csScpiCmd.TrimRight();
    csScpiCmd.TrimLeft();

    if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
          // Argument is SINGLE
        if (!csScpiCmd.CollateNoCase("SINGLE"))
        {
            singleErr.value = (DLI_INT32)idlSettingsPacket.errorGen.errorType;
            anyStructure<<=singleErr;
            m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure,IDL_SINGLE_ERR_GEN, m_globs));
        }

          // Argument is N.NNe-NN
        else if(m_pScpiProxyServer->isErrorRateFormat(csScpiCmd.GetBuffer(csScpiCmd.GetLength())))
        {
            char number[10];
            char expo  [3];
                char* pScpiCmd = csScpiCmd.GetBuffer(csScpiCmd.GetLength()+1);

            memset(number,0,sizeof(number));
            memset(expo,0,sizeof(expo));

            // copy N.NN to number
            strncpy_s(number, sizeof(number),pScpiCmd,4);

            // Convert to floating, multiply by 100 to avoid decimal point
            UINT32 errNum = (UINT32)(atof(number) * 100);

            // copy the exponent part
            strncpy_s(expo, sizeof(expo),&pScpiCmd[6],2);

            // Convert the string into integer.
            INT64 errDen = atoi(expo) + 2;

            idlSettingsPacket.reference        = IDL_PACKET2_REF_ERROR_GEN;
            idlSettingsPacket.errorGen.reference = REF_ERR_RATE_NUM;
            idlSettingsPacket.errorGen.errorNum  = errNum;
            idlSettingsPacket.errorGen.errorDen  = 1;
            for(int i = 0; i < errDen;i++)
            {
                idlSettingsPacket.errorGen.errorDen = idlSettingsPacket.errorGen.errorDen*10;
                // Bounds-check errorDen, all bets off if not conformant
                if((idlSettingsPacket.errorGen.errorDen > _I64_MAX) ||
                   (idlSettingsPacket.errorGen.errorDen < 0))
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                    return ;
                }
            }

            idlSettingsPacket.restartInhibit = TRUE;
            anyStructure<<=idlSettingsPacket;
            m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
        }
        else if(m_pScpiProxyServer->isInteger(csScpiCmd.GetBuffer(csScpiCmd.GetLength())) && (atoi(csScpiCmd.GetBuffer(csScpiCmd.GetLength())) == 0))
        {
            idlSettingsPacket.reference          = IDL_PACKET2_REF_ERROR_GEN;
            idlSettingsPacket.errorGen.reference = REF_ERR_RATE_NUM;
            idlSettingsPacket.errorGen.errorNum  = 0;
            idlSettingsPacket.errorGen.errorDen  = 1;

            idlSettingsPacket.restartInhibit = TRUE;
            anyStructure<<=idlSettingsPacket;

            m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
        }
    }
}


//***************************
// TX:ERRor:RATE?
//***************************
void ScpiPacket::txGetErrRate (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:ERRor:RATE?");
#endif

    DOUBLE ratNum  = 0.00;
    DOUBLE ratDen  = 0.00;
    DOUBLE errRate = 0.00;
    INT64 ratDen1  = 0;

   CString csResult;


   CORBA::Any_var anyStructure=new CORBA::Any;
   IdlPacket2AllSettings  idlSettingsPacket;
   IdlPacket2AllSettings* idlSettingsPacketPtr;
   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

   // Need to get the Type so not to change it when doing the setting.
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   if (idlSettingsPacket.errorGen.errorDen != 0)
   {
       ratNum  = (DOUBLE)(idlSettingsPacket.errorGen.errorNum);
       ratDen1 = (INT64)(idlSettingsPacket.errorGen.errorDen);
       ratDen  = (DOUBLE)ratDen1;
       errRate = ratNum/ratDen;
   }

   // convert in N.NNe-NN format
    csResult.GetBufferSetLength(20);
    csResult.Format("%.2e", errRate);
    m_pScpiProxyServer->formatRate(csResult.GetBuffer(csResult.GetLength()+1));
    csResult.ReleaseBuffer();
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// TX:ERRor:Type
//***************************
void ScpiPacket::txSetErrType (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:ERRor:TYPE");
#endif


   CORBA::Any_var anyStructure=new CORBA::Any;
   IdlPacket2AllSettings  idlSettingsPacket;
   IdlPacket2AllSettings* idlSettingsPacketPtr;
   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
    {
        if (!csScpiCmd.CollateNoCase("NONE") )
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_NOOP;
        }
        else if ((!csScpiCmd.CollateNoCase("FCS")) || (!csScpiCmd.CollateNoCase("CRC")))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_FCS;
        }
        else if (!csScpiCmd.CollateNoCase("IPCHECKSUM"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_IP_CHECKSUM;
        }
        else if (!csScpiCmd.CollateNoCase("UDPCHECKSUM"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_UDP_CHECKSUM;
        }
        else if (!csScpiCmd.Left(3).CollateNoCase("BIT"))
        {
            int bitErr = atoi(csScpiCmd.Mid(3));
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_STREAM_1_BIT + bitErr - 1;
        }
        else if (!csScpiCmd.Left(3).CollateNoCase("SEQ"))
        {
            int seqErr = atoi(csScpiCmd.Mid(3));
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_STREAM_1_SEQUENCE + seqErr - 1;
        }
        else if ((!csScpiCmd.CollateNoCase("LINE")) ||
                 (!csScpiCmd.CollateNoCase("LINECODE")) ||
                 (!csScpiCmd.CollateNoCase("BLOCK")))
        {
            if (m_globs->g_ppType == IDL_PP_HD_ENET_ELEC) // Not Available for electrical ports
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            else
                idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_LINE_CODE;
        }
        else if (!csScpiCmd.CollateNoCase("SYNCHDR"))
        {
            // 10G ethernet only
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_SEED_AB)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_25G_SEED_AB)))
            {
                idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_INVALID_SYNC_HEADER;
            }
            else
                m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        }
        else if (!csScpiCmd.CollateNoCase("DISPARITY"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_DISPARITY;
        }
        else if (!csScpiCmd.CollateNoCase("CHEC"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_CORRECTABLE_CHEC;
        }
        else if (!csScpiCmd.CollateNoCase("UCHEC"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_UNCORRECTABLE_CHEC;
        }
        else if (!csScpiCmd.CollateNoCase("THEC"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_CORRECTABLE_THEC;
        }
        else if (!csScpiCmd.CollateNoCase("UTHEC"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_UNCORRECTABLE_THEC;
        }
        else if (!csScpiCmd.CollateNoCase("EHEC"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_CORRECTABLE_EHEC;
        }
        else if (!csScpiCmd.CollateNoCase("UEHEC"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_UNCORRECTABLE_EHEC;
        }
        else if (!csScpiCmd.CollateNoCase("INVSUPER"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_INVALID_SUPER;
        }
        else if (!csScpiCmd.CollateNoCase("SFCS"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_SUPER_FCS;
        }
        else if (!csScpiCmd.CollateNoCase("PFCS"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_GFP_FCS;
        }
        else if (!csScpiCmd.CollateNoCase("RUNT"))
        {
            idlSettingsPacket.errorGen.errorType = IDL_PACKET2_ERR_RUNT;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
            return;
        }

        idlSettingsPacket.reference = IDL_PACKET2_REF_ERROR_GEN ;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));

     }
     else
     {
       m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
     }
}

//***************************
// TX:ERRor:TYPE?
//***************************
void ScpiPacket::txGetErrType (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:ERRor:TYPE?");
#endif

   CString csResult = "UNKNOWN";

   CORBA::Any_var anyStructure=new CORBA::Any;
   IdlPacket2AllSettings  idlSettingsPacket;
   IdlPacket2AllSettings* idlSettingsPacketPtr;

   TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;
    if ((idlSettingsPacket.errorGen.errorType >= IDL_PACKET2_ERR_STREAM_1_BIT)&&
        (idlSettingsPacket.errorGen.errorType <= IDL_PACKET2_ERR_STREAM_32_BIT))
    {
        for (int i = IDL_PACKET2_ERR_STREAM_1_BIT; i <= IDL_PACKET2_ERR_STREAM_32_BIT; i++)
        {
            if (idlSettingsPacket.errorGen.errorType == i)
                csResult.Format("BIT%d", i - IDL_PACKET2_ERR_STREAM_1_BIT + 1);
        }
    }
    else if ((idlSettingsPacket.errorGen.errorType >= IDL_PACKET2_ERR_STREAM_1_SEQUENCE)&&
        (idlSettingsPacket.errorGen.errorType <= IDL_PACKET2_ERR_STREAM_32_SEQUENCE))
    {
        for (int i = IDL_PACKET2_ERR_STREAM_1_SEQUENCE; i <= IDL_PACKET2_ERR_STREAM_32_SEQUENCE; i++)
        {
            if (idlSettingsPacket.errorGen.errorType == i)
                csResult.Format("SEQ%d", i - IDL_PACKET2_ERR_STREAM_1_SEQUENCE + 1);
        }
    }

    else
    {
        switch (idlSettingsPacket.errorGen.errorType)
        {
        case IDL_PACKET2_ERR_NOOP:
            csResult = "None";
            break;
        case IDL_PACKET2_ERR_FCS:
            csResult = "FCS/CRC";
            break;
        case IDL_PACKET2_ERR_IP_CHECKSUM:
            csResult = "IPCHECKSUM";
            break;
        case IDL_PACKET2_ERR_UDP_CHECKSUM:
            csResult = "UDPCHECKSUM";
            break;
        case IDL_PACKET2_ERR_LINE_CODE:
            if ((idlSettingsPacket.portInterface == IDL_PACKET2_PORT_INTERFACE_GFP) &&
                ((idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OMR_10G_WAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_OTN_10G_LAN)     ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_SEED_AB)         ||
                 (idlSettingsPacket.portMapping == IDL_PACKET2_PORT_MAP_MLD_25G_SEED_AB)))
            {
                csResult = "BLOCK";
            }
            else
                csResult = "LINECODE";
            break;
        case IDL_PACKET2_ERR_INVALID_SYNC_HEADER:
            csResult = "SYNCHDR";
            break;
        case IDL_PACKET2_ERR_DISPARITY:
            csResult = "DISPARITY";
            break;
        case IDL_PACKET2_ERR_CORRECTABLE_CHEC:
            csResult = "CHEC";
            break;
        case IDL_PACKET2_ERR_UNCORRECTABLE_CHEC:
            csResult = "UCHEC";
            break;
        case IDL_PACKET2_ERR_CORRECTABLE_THEC:
            csResult = "THEC";
            break;
        case IDL_PACKET2_ERR_UNCORRECTABLE_THEC:
            csResult = "UTHEC";
            break;
        case IDL_PACKET2_ERR_CORRECTABLE_EHEC:
            csResult = "EHEC";
            break;
        case IDL_PACKET2_ERR_UNCORRECTABLE_EHEC:
            csResult = "UEHEC";
            break;
        case IDL_PACKET2_ERR_INVALID_SUPER:
            csResult = "INVSUPER";
            break;
        case IDL_PACKET2_ERR_SUPER_FCS:
            csResult = "SFCS";
            break;
        case IDL_PACKET2_ERR_GFP_FCS:
            csResult = "PFCS";
            break;
        case IDL_PACKET2_ERR_RUNT:
            csResult = "RUNT";
            break;
        }
    }
    m_pScpiProxyServer->scpiResults(csResult);
}

//TX:FILLWORD?
void ScpiPacket::getFillword (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:FILLWORD?");
#endif

    CString csResult = "";

    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    // Is the current interface 8g or currently licensed
    if (Is8GValid() == false)
    {
        return;
    }

    // Get Current Settings
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    PacketAllSettings = *PacketAllSettingsPtr;

    // Determine setting for FillWord
    if (PacketAllSettings.disableFillWord == IDL_OFF_STATE)
    {
        csResult = "ARB-FF";
    }
    else
    {
        csResult = "IDLE";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}

//TX:FILLWORD
void ScpiPacket::setFillword (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:FILLWORD");
#endif

    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    // Is the current interface 8g or currently licensed
    if (Is8GValid() == false)
    {
        return;
    }

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    PacketAllSettings = *PacketAllSettingsPtr;

    // Parse the rest of the command line
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Check for next command arg
    if(csScpiCmd.IsEmpty() || (csScpiCmd == ""))
    {
        // Require command line args missing
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if(!csScpiCmd.CollateNoCase("ARB-FF"))
    {
        PacketAllSettings.disableFillWord = IDL_OFF_STATE;
    }
    else
    {
        if(!csScpiCmd.CollateNoCase("IDLE"))
        {
            PacketAllSettings.disableFillWord = IDL_ON_STATE;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
            return;
        }
    }

    PacketAllSettings.reference  = IDL_PACKET2_REF_DISABLE_FILL_WORD;
    PacketAllSettings.restartInhibit = TRUE;

    anyStructure<<=PacketAllSettings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//TX:LINKINIT?
void ScpiPacket::getLinkinit (CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:LINKINIT?");
#endif
    CString csResult = "";

    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    // Now allowing 4G and 8G for this command, checked below
    //
    //// Is the current interface 8g or currently licensed
    //if (Is8GValid() == false)
    //{
    //    return;
    //}

    // Get Current Settings
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    PacketAllSettings = *PacketAllSettingsPtr;

    if ((PacketAllSettings.portMapping != IDL_PACKET2_PORT_MAP_8G_FIBERCHAN) &&
        (PacketAllSettings.portMapping != IDL_PACKET2_PORT_MAP_4G_FIBERCHAN))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // Determine setting for Link Init
    if (PacketAllSettings.disablePsp == IDL_OFF_STATE)
    {
        // Enabled
        csResult = csEnableDisabled[0];
    }
    else
    {
        // Disabled
        csResult = csEnableDisabled[1];
    }

    m_pScpiProxyServer->scpiResults(csResult);
}

//TX:LINKINIT
void ScpiPacket::setLinkinit (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:LINKINIT");
#endif

    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    // Now allowing 4G and 8G for this command, checked below
    //
    //// Is the current interface 8g or currently licensed
    //if (Is8GValid() == false)
    //{
    //    return;
    //}

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    PacketAllSettings = *PacketAllSettingsPtr;

    if ((PacketAllSettings.portMapping != IDL_PACKET2_PORT_MAP_8G_FIBERCHAN) &&
        (PacketAllSettings.portMapping != IDL_PACKET2_PORT_MAP_4G_FIBERCHAN))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    // Parse the rest of the command line
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Check for next command arg
    if(csScpiCmd.IsEmpty() || (csScpiCmd == ""))
    {
        // Require command line args missing
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if(!csScpiCmd.CollateNoCase(csEnableDisabled[0]))
    {
        PacketAllSettings.disablePsp = IDL_OFF_STATE;
    }
    else
    {
        if(!csScpiCmd.CollateNoCase(csEnableDisabled[1]))
        {
            PacketAllSettings.disablePsp = IDL_ON_STATE;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
            return;
        }
    }

    PacketAllSettings.reference  = IDL_PACKET2_REF_DISABLE_PSP;
    PacketAllSettings.restartInhibit = TRUE;

    anyStructure<<=PacketAllSettings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//TX:SCRAMBLE?
void ScpiPacket::getScramble(CString&)
{
#ifdef _MYDEBUG
    printf("\nTX:SCRAMBLE?");
#endif
    CString csResult = "";

    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    // Is the current interface 8g or currently licensed
    if (Is8GValid() == false)
    {
        return;
    }

    // Get Current Settings
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    PacketAllSettings = *PacketAllSettingsPtr;

    // Determine setting for Scrambler
    if (PacketAllSettings.disableScrambler == IDL_OFF_STATE)
    {
        // Enabled
        csResult = csEnableDisabled[0];
    }
    else
    {
        // Disabled
        csResult = csEnableDisabled[1];
    }

    m_pScpiProxyServer->scpiResults(csResult);

}

//TX:SCRAMBLE
void ScpiPacket::setScramble (CString& csScpiCmd)
{
#ifdef _MYDEBUG
   printf("\nTX:SCRAMBLE?");
#endif

    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    // Is the current interface 8g or currently licensed
    if (Is8GValid() == false)
    {
        return;
    }

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    PacketAllSettings = *PacketAllSettingsPtr;

    // Parse the rest of the command line
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Check for next command arg
    if(csScpiCmd.IsEmpty() || (csScpiCmd == ""))
    {
        // Require command line args missing
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // Enabled
    if(!csScpiCmd.CollateNoCase(csEnableDisabled[0]))
    {
        PacketAllSettings.disableScrambler = IDL_OFF_STATE;
    }
    else
    {
        // Disabled
        if(!csScpiCmd.CollateNoCase(csEnableDisabled[1]))
        {
            PacketAllSettings.disableScrambler = IDL_ON_STATE;
        }
        else
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
            return;
        }
    }

    PacketAllSettings.reference  = IDL_PACKET2_REF_DISABLE_SCRAMBLER;
    PacketAllSettings.restartInhibit = TRUE;

    anyStructure<<=PacketAllSettings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//TX:SET?
void ScpiPacket::txGetSet(CString&)
{
#ifdef _MYDEBUG
   printf("\nTX:SET?");
#endif

    CString csTemp = "";
    CString csBuf = "";
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


    //TX:LASER?
    if(idlSettingsPacket.txLaserState == IDL_LASER_STATE_ON)
        csTemp = csOnOFF[IDL_ON_STATE];
    else
        csTemp = csOnOFF[IDL_OFF_STATE];
    csBuf += "\"" + csTemp + "\"" + ",";

    // TX:PAUSE?
    if(idlSettingsPacket.ppPauseState == IDL_ON_STATE)
        csTemp = csOnOFF[IDL_ON_STATE];
    else
        csTemp = csOnOFF[IDL_OFF_STATE];
    csBuf += "\"" + csTemp + "\"" + ",";

    // TX:ALARM?
    switch (idlSettingsPacket.alarmGen.alarmType)
    {
    case IDL_PACKET2_ALARM_OFF:
        csTemp = "OFF";
        break;
    case IDL_PACKET2_ALARM_CP_POWER_LOSS:
        csTemp = "CPP";
        break;
    case IDL_PACKET2_ALARM_LOS:
        csTemp = "LOS";
        break;
    case IDL_PACKET2_ALARM_LINK:
        csTemp = "LINK";
        break;
    case IDL_PACKET2_ALARM_LOCAL_LINK_FAULT:
        csTemp = "LF";
        break;
    case IDL_PACKET2_ALARM_REMOTE_LINK_FAULT:
        csTemp = "RF";
        break;
    case IDL_PACKET2_ALARM_JABBER:
        csTemp = "JABBER";
        break;
    case IDL_PACKET2_ALARM_GFP_LFD:
        csTemp = "LFD";
        break;
    case IDL_PACKET2_ALARM_GFP_LOCS:
        csTemp = "LOCS";
        break;
    case IDL_PACKET2_ALARM_GFP_LOCCS:
        csTemp = "LOCCS";
        break;
    case IDL_PACKET2_ALARM_GFP_HDR_MISMMATCH:
    case IDL_PACKET2_ALARM_GFP_HDR_MISMATCH:
        csTemp = "HDRMM";
        break;
    case IDL_PACKET2_ALARM_BLOCK_LOCK_LOSS:
        csTemp = "BLKLOC";
        break;
    case IDL_PACKET2_ALARM_HI_BER:
        csTemp = "HIBER";
        break;
    default:
        csTemp = "None";//TR 3564
        break;
    }
    csBuf += "\"" + csTemp + "\"" + ",";

    // TX:MODE?
    switch(idlSettingsPacket.portInterface)
    {
    case IDL_PACKET2_PORT_INTERFACE_10M_ENET_FULL://For Optical
        csTemp = "10M Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10T_ENET_FULL://For Electrical
        csTemp = "10M Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_100M_ENET_FULL:
        csTemp = "100M Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_100T_ENET_FULL:
        csTemp = "100M Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_1G_ENET_FULL:
        csTemp = "1G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_1000T_ENET_FULL:
        csTemp = "1G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_2_5G_ENET:
        csTemp = "2.5G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_2500T_ENET:
        csTemp = "2.5G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_5000T_ENET:
        csTemp = "5G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10000T_ENET:
        csTemp = "10G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10G_ENET_FULL:
        csTemp = "10G Full Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10M_ENET_HALF:
        csTemp = "10M Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10T_ENET_HALF:
        csTemp = "10M Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_100M_ENET_HALF:
        csTemp = "100M Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_100T_ENET_HALF:
        csTemp = "100M Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_1G_ENET_HALF:
        csTemp = "1G Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_1000T_ENET_HALF:
        csTemp = "1G Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10G_ENET_HALF:
        csTemp = "10 G Half Duplex";
        break;
    case IDL_PACKET2_PORT_INTERFACE_ADD_DROP:
        csTemp = "MultiRate add/drop";
        break;
    case IDL_PACKET2_PORT_INTERFACE_10G_ENET_WAN:
        csTemp = "9.953 Gbps WAN optical";
        break;
    case IDL_PACKET2_PORT_INTERFACE_AUTO_NEG:
        csTemp = "Auto negotiate";
        break;
    default:
        csTemp = "";
        break;
    }
    csBuf += "\"" + csTemp + "\"" + ",";

    // TX:IPREFLECTION?
    if(idlSettingsPacket.bounceModeEnable == IDL_ON_STATE)
        csTemp = csOnOFF[IDL_ON_STATE];
    else
        csTemp = csOnOFF[IDL_OFF_STATE];
    csBuf += "\"" + csTemp + "\"" + ",";

    // TX:AUTO?
    if(idlSettingsPacket.autoNegotiateEnable == IDL_ON_STATE)
        csTemp = csOnOFF[IDL_ON_STATE];
    else
        csTemp = csOnOFF[IDL_OFF_STATE];
    csBuf += "\"" + csTemp + "\"" + ",";

    // TX:ERRor:RATE?
    DOUBLE errRate = 0;
    if (idlSettingsPacket.errorGen.errorDen != 0)
    {
        DOUBLE ratNum  = (DOUBLE)(idlSettingsPacket.errorGen.errorNum);
        INT64 ratDen1 = (INT64)(idlSettingsPacket.errorGen.errorDen);
        DOUBLE ratDen  = (DOUBLE)ratDen1;
        errRate = ratNum/ratDen;
    }
    // convert in N.NNe-NN format
    csTemp.GetBufferSetLength(20);
    csTemp.Format("%.2e", errRate);
    m_pScpiProxyServer->formatRate(csTemp.GetBuffer(csTemp.GetLength()+1));
    csTemp.ReleaseBuffer();
    csBuf += "\"" + csTemp + "\"" + ",";

    if ((idlSettingsPacket.errorGen.errorType >= IDL_PACKET2_ERR_STREAM_1_BIT)&&
        (idlSettingsPacket.errorGen.errorType <= IDL_PACKET2_ERR_STREAM_32_BIT))
    {
        for (int i = IDL_PACKET2_ERR_STREAM_1_BIT; i <= IDL_PACKET2_ERR_STREAM_32_BIT; i++)
        {
            if (idlSettingsPacket.errorGen.errorType == i)
                csTemp.Format("BIT%d", i - IDL_PACKET2_ERR_STREAM_1_BIT + 1);
        }
    }
    else if ((idlSettingsPacket.errorGen.errorType >= IDL_PACKET2_ERR_STREAM_1_SEQUENCE)&&
        (idlSettingsPacket.errorGen.errorType <= IDL_PACKET2_ERR_STREAM_32_SEQUENCE))
    {
        for (int i = IDL_PACKET2_ERR_STREAM_1_SEQUENCE; i <= IDL_PACKET2_ERR_STREAM_32_SEQUENCE; i++)
        {
            if (idlSettingsPacket.errorGen.errorType == i)
                csTemp.Format("SEQ%d", i - IDL_PACKET2_ERR_STREAM_1_SEQUENCE + 1);
        }
    }
    // TX:ERRor:TYPE?
    else
    {
        switch (idlSettingsPacket.errorGen.errorType)
        {
        case IDL_PACKET2_ERR_NOOP:
            csTemp = "None";
            break;
        case IDL_PACKET2_ERR_FCS:
            csTemp = "FCS/CRC";
            break;
        case IDL_PACKET2_ERR_IP_CHECKSUM:
            csTemp = "IPCHECKSUM";
            break;
        case IDL_PACKET2_ERR_UDP_CHECKSUM:
            csTemp = "UDPCHECKSUM";
            break;
        case IDL_PACKET2_ERR_LINE_CODE:
            csTemp = "LINECODE";
            break;
        case IDL_PACKET2_ERR_INVALID_SYNC_HEADER:
            csTemp = "SYNCHDR";
            break;
        case IDL_PACKET2_ERR_DISPARITY:
            csTemp = "DISPARITY";
            break;
        case IDL_PACKET2_ERR_CORRECTABLE_CHEC:
            csTemp = "CHEC";
            break;
        case IDL_PACKET2_ERR_UNCORRECTABLE_CHEC:
            csTemp = "UCHEC";
            break;
        case IDL_PACKET2_ERR_CORRECTABLE_THEC:
            csTemp = "THEC";
            break;
        case IDL_PACKET2_ERR_UNCORRECTABLE_THEC:
            csTemp = "UTHEC";
            break;
        case IDL_PACKET2_ERR_CORRECTABLE_EHEC:
            csTemp = "EHEC";
            break;
        case IDL_PACKET2_ERR_UNCORRECTABLE_EHEC:
            csTemp = "UEHEC";
            break;
        case IDL_PACKET2_ERR_INVALID_SUPER:
            csTemp = "INVSUPER";
            break;
        case IDL_PACKET2_ERR_SUPER_FCS:
            csTemp = "SFCS";
            break;
        case IDL_PACKET2_ERR_GFP_FCS:
            csTemp = "PFCS";
            break;
        case IDL_PACKET2_ERR_RUNT:
            csTemp = "RUNT";
            break;
        }
    }
    csBuf += "\"" + csTemp + "\"" + ",";

    //Settings.settingsChangeCount
    csTemp.Format("%d", idlSettingsPacket.settingsChangeCount);
    csBuf += csTemp + ", |";

    m_pScpiProxyServer->m_queryFlag = true;
    m_pScpiProxyServer->scpiResults(csBuf);
}


///////////////////////////////////////////////////////////////////////////////
int ScpiPacket::callGetPacketAllStreamSettings (IdlPacket2AllStreamSettings& packetAllStreamSettings)
{
    int status;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllStreamSettings* packetAllStreamSettingsPtr;

    StartCatch()

    // Get Current Stream Settings
    status = callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs);
    if (status != IDL_SUCCESS)
        return status;
    if (anyStructure >>= packetAllStreamSettingsPtr)
        packetAllStreamSettings = *packetAllStreamSettingsPtr;
    else
        return ScpiProxyServer::INVALID_RESULTS;

    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketAllStreamSettings", pExp)
}


///////////////////////////////////////////////////////////////////////////////
int ScpiPacket::callGetPacketAllSettings (IdlPacket2AllSettings& packetAllSettings)
{
    int status;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings* packetAllSettingsPtr;

    StartCatch()

    // Get Current Settings
    status = callGetAllSettings(anyStructure, m_globs);
    if (status != IDL_SUCCESS)
        return status;
    if (anyStructure >>= packetAllSettingsPtr)
        packetAllSettings = *packetAllSettingsPtr;
    else
        return ScpiProxyServer::INVALID_RESULTS;

    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketAllSettings", pExp)
}


///////////////////////////////////////////////////////////////////////////////
int ScpiPacket::callGetPacketAllowed (IdlPacket2AllSettings&     packetAllSettings,
                                      IdlPacket2AllowedSettings& packetAllowedSettings)
{
    int status;
    IdlPacket2AllowedSettings*  packetAllowedSettingsPtr;
    IdlPacket2AllSettings* packetAllSettingsPtr;
    CORBA::Any_var anyStructureVar = new CORBA::Any;
    CORBA::Any_var anyStructure = new CORBA::Any;

    StartCatch()

    // Get Current Settings
    status = callGetAllSettings(anyStructure, m_globs);
    if (status != IDL_SUCCESS)
        return status;
    if (anyStructure >>= packetAllSettingsPtr)
        packetAllSettings = *packetAllSettingsPtr;
    else
        return ScpiProxyServer::INVALID_RESULTS;

    // Get Allowed settings
    anyStructureVar <<= packetAllSettings;
    status = callGetAllowedSettings(anyStructureVar, m_globs);
    if (status != IDL_SUCCESS)
        return status;
    if (anyStructureVar >>= packetAllowedSettingsPtr)
        packetAllowedSettings = *packetAllowedSettingsPtr;
    else
        return ScpiProxyServer::INVALID_SETTINGS;

    return(IDL_SUCCESS);

    EndCatchWithReturn("ScpiPacket::callGetPacketAllowed", pExp)
}




//*****************************************
// RF LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResRfLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resRfLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// LF LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResLfLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resLfLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// JABBER LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResJabberLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resJabberLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// BLKLOC LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResBlockLockLossLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resBlockLockLossLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//*****************************************
// HIBER LEVEL PROCESSING
//*****************************************
void ScpiPacket::doResHiBerLevel (CString& csScpiCmd)
{
   // Processing the command
    int iParseRet = TStartParse(this, resHiBerLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}


//***************************
// RES:RXB?
//***************************
void ScpiPacket::getRxbCast (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rxBroadcastPackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:RXM?
//***************************
void ScpiPacket::getRxmCast (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rxMulticastPackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RXU?
//***************************
void ScpiPacket::getRxuCast (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rxUnicastPackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:TXSUPERBLOCK?
//***************************
void ScpiPacket::getTxSuperBlock (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.txGfpSuperBlocks);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:RXSUPERBLOCK?
//***************************
void ScpiPacket::getRxSuperBlock (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rxGfpSuperBlocks);
    m_pScpiProxyServer->scpiResults(csBuf);
}



//***************************
// RES:FCRRDYPEND?
//***************************
void ScpiPacket::getFcRrdyPend (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.fcRrdyCredit);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:FCBBCREDIT?
//***************************
void ScpiPacket::getFcBbCredit (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.fcB2BCredit);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:FCTXRRDY?
//***************************
void ScpiPacket::getFcTxRrdy (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.fcTrdy);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:FCRXRRDY?
//***************************
void ScpiPacket::getFcRxRrdy (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.fcRrdy);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// RES:TXIDLE? or RES:TXPACKETS:IDLE?
//***************************
void ScpiPacket::getTxIdle (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.txGfpIdlePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RXIDLE? or RES:RXPACKETS:IDLE?
//***************************
void ScpiPacket::getRxIdle (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rxGfpIdlePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}



//***************************
// RES:RX64?
//***************************
void ScpiPacket::getRx64bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx64BytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RX65?
//***************************
void ScpiPacket::getRx65bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx65To127BytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RX128?
//***************************
void ScpiPacket::getRx128bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx128To255BytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RX256?
//***************************
void ScpiPacket::getRx256bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx256To511BytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RX512?
//***************************
void ScpiPacket::getRx512bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx512To1023BytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RX1024?
//***************************
void ScpiPacket::getRx1024bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx1024To1518BytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RX1519?
//***************************
void ScpiPacket::getRx1519bp (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%I64u", idlStatPacket.rx1519ToMaxBytePackets);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:RF:SECS?
//***************************
void ScpiPacket::getRfSecs (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.remoteLinkFault.alarmSecs);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:LF:SECS?
//***************************
void ScpiPacket::getLfSecs (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.localLinkFault.alarmSecs);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:JABBER:SECS?
//***************************
void ScpiPacket::getJabberSecs (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.jabber.alarmSecs);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:BLKLOC:SECS?
//***************************
void ScpiPacket::getBlockLockLossSecs (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.blockLockLoss.alarmSecs);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RES:HIBER:SECS?
//***************************
void ScpiPacket::getHiBerSecs (CString&)
{
    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    csBuf.Format("%d", idlStatPacket.hiBer.alarmSecs);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RFC:B2B:ACT
//***************************
void ScpiPacket::rfcSetActivate (CString& csScpiCmd)
{
    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlOp1Struct idlOp1Settings;
    IdlPacket2AllSettings idlSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

    if (idlSettingsPacket.rfcTrialDuration > 10)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    if (!csScpiCmd.CollateNoCase("ON"))
    {
        idlOp1Settings.value = IDL_PACKET2_RFC_BACK_TO_BACK_START;
    }
    else if (!csScpiCmd.CollateNoCase("OFF"))
    {
        idlOp1Settings.value = IDL_PACKET2_RFC_STOP;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Can't run RFC in ID337 mode.
    if (idlSettingsPacket.emixMode == IDL_PACKET2_EMIX_ID337)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // Set flag so GUI displays properly.
    if (idlSettingsPacket.ethSamOrRfc != IDL_RFC_VIEW)
    {
        CORBA::Any_var anyStructure2 = new CORBA::Any;
        idlSettingsPacket.reference  = IDL_PACKET2_REF_ETHSAM_OR_RFC;
        idlSettingsPacket.ethSamOrRfc = IDL_RFC_VIEW;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure2 <<= idlSettingsPacket;
        callSetAllSettings(anyStructure2, m_globs);
    }

    anyStructure<<=idlOp1Settings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_ARM_RFC_TEST, m_globs));
}

//***************************
// RFC:B2B:ACT?
//***************************
void ScpiPacket::rfcGetActivate (CString&)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    IdlPacket2Stats idlStatPacket;

   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));


    if(idlStatPacket.rfcState == IDL_PACKET2_RFC_THROUGHPUT_ACTIVE)
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_ON_STATE]);
    }
    else
    {
        m_pScpiProxyServer->scpiResults(csOnOFF[IDL_OFF_STATE]);
    }
    m_pScpiProxyServer->scpiResults(csResult);
}



//***************************
// RFC:THRU:LAT
//***************************
void ScpiPacket::rfcSetLatencyIterations (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int res = atoi(csScpiCmd);

    //if (res < currentPacketAllowedSettings->rfcB2BResolutionLo || res > currentPacketAllowedSettings->rfcB2BResolutionHi)//The max should be 812
    if(res < currentPacketAllowedSettings->rfcLatencyIterationsLo || res > currentPacketAllowedSettings->rfcLatencyIterationsHi)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcLatencyIterations = res;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_LATENCY_ITERATIONS;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:THRU:LAT?
//***************************
void ScpiPacket::rfcGetLatencyIterations (CString&)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   int res;

    res = idlSettingsPacket.rfcLatencyIterations;
    csResult.Format("%d", res);

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// RFC:B2B:RES
//***************************
void ScpiPacket::rfcSetResolution (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int res = atoi(csScpiCmd);

    //if (res < currentPacketAllowedSettings->rfcB2BResolutionLo || res > currentPacketAllowedSettings->rfcB2BResolutionHi)//The max should be 812
    if(res < 1 || res > 812)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcB2BResolution = res;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_B2B_RESOLUTION;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:B2B:RES?
//***************************
void ScpiPacket::rfcGetResolution (CString&)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   int res;

    if (idlSettingsPacket.rfcB2BResolution != 0)
    {
        res = idlSettingsPacket.rfcB2BResolution;
    }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    csResult.Format("%d", res);

    m_pScpiProxyServer->scpiResults(csResult);
}
//***************************
// RFC:B2B:REP
//***************************
void ScpiPacket::rfcSetRepititions (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllowedSettings(anyStructure, m_globs));
    if( !(anyStructure >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    int rep = atoi(csScpiCmd);

    //if (rep < currentPacketAllowedSettings->rfcTrialRepetitionsLo || rep > currentPacketAllowedSettings->rfcTrialRepetitionsHi)//The max should be 100
    if(rep < 1 || rep > 100)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcTrialRepetitions = rep;

    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_TRIAL_REPETITIONS;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RFC:B2B:REP?
//***************************
void ScpiPacket::rfcGetRepititions (CString&)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

   int res;

    if (idlSettingsPacket.rfcTrialRepetitions != 0)
    {
        res = idlSettingsPacket.rfcTrialRepetitions;
    }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    csResult.Format("%d", res);

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// RFC:B2B:MAXPOS?
//***************************
void ScpiPacket::rfcGetMaxPossible (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    int i = atoi(csScpiCmd);

    if (i < 1 || i > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csBuf.Format("%I64u", idlStatPacket.rfcB2BMaxPossible[i - 1]);
    m_pScpiProxyServer->scpiResults(csBuf);
}

//***************************
// RFC:B2B:AVGOBS?
//***************************
void ScpiPacket::rfcGetAvgObServed (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CString csBuf;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    int i = atoi(csScpiCmd);

    if (i < 1 || i > 8)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csBuf.Format("%I64u", idlStatPacket.rfcB2BAvgMeasured[i - 1]);
    m_pScpiProxyServer->scpiResults(csBuf);
}


//***************************
// TX:MODE?
//***************************
void ScpiPacket::getPortInterface (CString& csScpiCmd)
{


    CString m_csMapping;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    int iPortInterface = idlSettingsPacket.portInterface;
    int m_iMapping = idlSettingsPacket.portMapping;

    switch(iPortInterface)
    {
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    case   IDL_PACKET2_PORT_INTERFACE_OFF:
        m_csMapping = "Missing Module?";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10T_ENET_FULL:
        m_csMapping = "10M@FULL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_100T_ENET_FULL:
        m_csMapping = "100M@FULL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_1000T_ENET_FULL:
        m_csMapping = "1G@FULL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_2500T_ENET:
        m_csMapping = "2.5G@FULL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_5000T_ENET:
        m_csMapping = "5G@FULL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10000T_ENET:
        m_csMapping = "10G@FULL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10M_ENET_FULL:
        m_csMapping = "10M@OPTICAL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_100M_ENET_FULL:
        m_csMapping = "100M@OPTICAL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_1G_ENET_FULL:
        m_csMapping = "1G@OPTICAL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_2_5G_ENET:
        m_csMapping = "2.5G@OPTICAL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10G_ENET_FULL:
        //m_csMappingText.Format("Map");
        switch (m_iMapping)
        {
        default:
        case IDL_PACKET2_PORT_MAP_OMR_10G_LAN:
            m_csMapping.Format("10GLAN");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_10G_WAN:
            m_csMapping.Format("10GWAN");
            break;
        case IDL_PACKET2_PORT_MAP_SEED_AB:
            m_csMapping.Format("10GSEED_AB");
            break;
        }
        break;

    case   IDL_PACKET2_PORT_INTERFACE_10T_ENET_HALF:
        m_csMapping = "10M@HALF";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_100T_ENET_HALF:
        m_csMapping = "100M@HALF";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_1000T_ENET_HALF:
        m_csMapping = "1G@HALF";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10M_ENET_HALF:
        m_csMapping = "10M@OPTICAL";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_100M_ENET_HALF:
        m_csMapping = "100M@HALF";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_1G_ENET_HALF:
        m_csMapping = "1G@HALF";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10G_ENET_HALF:
        m_csMapping = "10G@HALF";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_10G_ENET_WAN:
        m_csMapping = "WAN";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_ADD_DROP:
        m_csMapping = "ADD/DROP";
        break;
    case   IDL_PACKET2_PORT_INTERFACE_AUTO_NEG:
        m_csMapping = "AUTO";
        break;
    case IDL_PACKET2_PORT_INTERFACE_GFP:
        //m_csMappingText.Format("Map");
        switch (m_iMapping)
        {
        case IDL_PACKET2_PORT_MAP_MLD_25G_SEED_AB:
            m_csMapping.Format("SEED_AB_25G");
            break;
        case IDL_PACKET2_PORT_MAP_SEED_AB:
            m_csMapping.Format("SEED_AB");
            break;
        //case IDL_PACKET2_PORT_MAP_OMR_10G_LAN:
        //    m_csMapping.Format("LAN");
        //    break;
        case IDL_PACKET2_PORT_MAP_OMR_10G_WAN:
            m_csMapping.Format("WAN");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_2_5G_LAN:
            m_csMapping.Format("2_5G_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_1G_LAN:
            m_csMapping.Format("1G_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_100M_ENET_FULL:
            m_csMapping.Format("100M_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_10M_ENET_FULL:
            m_csMapping.Format("10M_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_10000T_ENET:
            m_csMapping.Format("10000T_LAN_FULL");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_5000T_ENET:
            m_csMapping.Format("5000T_LAN_FULL");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_2500T_ENET:
            m_csMapping.Format("2500T_LAN_FULL");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_1000T_ENET_FULL:
            m_csMapping.Format("1000T_LAN_FULL");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_100T_ENET_FULL:
            m_csMapping.Format("100T_LAN_FULL");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_10T_ENET_FULL:
            m_csMapping.Format("10T_LAN_FULL");
            break;
        case IDL_PACKET2_PORT_MAP_GFP_FRAMED_ENET:
            m_csMapping.Format("FRAMED");
            break;
        case IDL_PACKET2_PORT_MAP_GFP_10G_LAN:
            m_csMapping.Format("GFP_10G_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_25G_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping.Format("25_781GE_25GAUI_SFP");
            else
                m_csMapping.Format("25G_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_QUAD_25G_LAN:
            m_csMapping = "4X_25_781GE_25GAUI_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_QUAD_25G_LAN:
            m_csMapping = "4X_25_781GE_25GAUI_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_QUAD_25G_LAN:
            m_csMapping = "4X_25_781GE_25GAUI_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP28_QUAD_25G_LAN:
            m_csMapping = "4X_25_781GE_25GAUI_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_25G_FEC_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping.Format("25_781GE_KR_25GAUI_SFP");
            else
                m_csMapping.Format("25G_LAN_FEC");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_QUAD_25G_FEC_LAN:
            m_csMapping = "4X_25_781GE_KR_25GAUI_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_QUAD_25G_FEC_LAN:
            m_csMapping = "4X_25_781GE_KR_25GAUI_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_QUAD_25G_FEC_LAN:
            m_csMapping = "4X_25_781GE_KR_25GAUI_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP28_QUAD_25G_FEC_LAN:
            m_csMapping = "4X_25_781GE_KR_25GAUI_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_50G_LAN:
            m_csMapping.Format("50G_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_50G_FEC_LAN:
            m_csMapping.Format("53_125GE_KP4_50GAUI1_SFP");//"50G_LAN_FEC"
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_50G_FEC_LAN:
            m_csMapping.Format("53_125GE_KP4_50GAUI2_QSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_50G_FEC_LAN:
            m_csMapping.Format("53_125GE_KP4_50GAUI2_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_50G_FEC_LAN:
            m_csMapping.Format("53_125GE_KP4_50GAUI2_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_50G_FEC_LAN:
            m_csMapping.Format("53_125GE_KP4_50GAUI2_CFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_50G_FEC_LAN:
            m_csMapping.Format("8X_53_125G_KP4_50GAUI1_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_OCTAL_50G_FEC_LAN:
            m_csMapping.Format("8X_53_125G_KP4_50GAUI1_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_106G_FEC_LAN:
            m_csMapping.Format("8X_106_25GE_KP4_100GAUI1_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_OCTAL_106G_FEC_LAN:
            m_csMapping.Format("8X_106_25GE_KP4_100GAUI1_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_106G_FEC_LAN_P1P2:
            m_csMapping.Format("8X_106_25GE_KP4_100GAUI1_P1P2_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_OCTAL_106G_FEC_LAN_P1P2:
            m_csMapping.Format("8X_106_25GE_KP4_100GAUI1_P1P2_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_41G_LAN:
            if (m_globs->g_ppType == IDL_PP_CSA_GFP)
                m_csMapping = "41G_LAN_CFP";
            else if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping = "41_25G_XLAUI_QSFP";
            else if ((m_globs->g_ppType == IDL_PP_MPM100_GFP) ||
                     (m_globs->g_ppType == IDL_PP_MPM600_GFP))
                m_csMapping = "41G_LAN_QSFP";
            else
                m_csMapping = "41G_LAN";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_103G_LAN:
            if ((m_globs->g_ppType == IDL_PP_MPM100_GFP) ||
                (m_globs->g_ppType == IDL_PP_MPM600_GFP))
                m_csMapping = "103G_LAN_CFP";
            else
                m_csMapping = "103_125GE_CAUI4_CFP";//"103G_LAN_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping = "103_125GE_CAUI4_QSFP";//"103G_LAN_QSFP";
            else
                m_csMapping = "103G_LAN_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_LAN:
            m_csMapping = "103_125GE_CAUI4_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_LAN:
            m_csMapping = "103_125GE_CAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_LAN_P1P2:
            m_csMapping = "103_125GE_CAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_LAN_P1P2:
            m_csMapping = "103_125GE_CAUI4_P1P2_OSFP";
            break;

        case IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_LAN:
            m_csMapping = "103G_LAN_QSFP56";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_LAN_FLEXE:
            m_csMapping = "103G_LAN_FLEXE_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_LAN_FLEXE:
            m_csMapping = "103G_LAN_FLEXE_QSFP56";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_103G_FEC_LAN:
            if ((m_globs->g_ppType == IDL_PP_MPM100_GFP) ||
                (m_globs->g_ppType == IDL_PP_MPM600_GFP))
                m_csMapping = "103G_LAN_FEC_CFP";
            else
                m_csMapping = "103_125GE_KR4_CAUI4_CFP";//"103G_LAN_FEC_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_103G_FEC_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping = "103_125GE_KR4_CAUI4_QSFP";//"103G_LAN_FEC_QSFP";
            else
                m_csMapping = "103G_LAN_FEC_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP56_103G_FEC_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping = "106_25GE_KP4_100GAUI2_QSFP";
            else
                m_csMapping = "103G_LAN_FEC_QSFP56";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_103G_FEC_LAN:
            if ((m_globs->g_ppType == IDL_PP_MPMP400_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD800_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD400_GFP))
                m_csMapping = "106_25GE_KP4_100GAUI2_QSFPDD";
            else
                m_csMapping = "103G_LAN_FEC_QSFP_DD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN:
            m_csMapping = "106_25GE_KP4_100GAUI2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_103G_FEC_LAN_P1P2:
            m_csMapping.Format("106_25GE_KP4_100GAUI2_P1P2_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_103G_FEC_LAN_P1P2:
            m_csMapping.Format("106_25GE_KP4_100GAUI2_P1P2_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_FEC_LAN:
            m_csMapping = "103_125GE_KR4_CAUI4_QSFPDD";//"103G_LAN_FEC_QSFP_DD28";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN:
            m_csMapping = "103_125GE_KR4_CAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_103G_FEC_LAN_P1P2:
            m_csMapping = "103_125GE_KR4_CAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_103G_FEC_LAN_P1P2:
            m_csMapping = "103_125GE_KR4_CAUI4_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_QUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI1_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI1_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_DQUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI1_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_DQUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI1_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_QUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_QUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DQUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI2_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_DQUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI2_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_DUAL_103G_FEC_LAN:
            m_csMapping = "2X_106_25GE_KP4_100GAUI4_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_DUAL_103G_FEC_LAN:
            m_csMapping = "2X_106_25GE_KP4_100GAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_103G_FEC_LAN:
            m_csMapping.Format("106_25GE_KP4_100GAUI1_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_103G_FEC_LAN:
            m_csMapping.Format("106_25GE_KP4_100GAUI1_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_103G_FEC_LAN_P1P2:
            m_csMapping.Format("106_25GE_KP4_100GAUI1_P1P2_QSFPDD");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_103G_FEC_LAN_P1P2:
            m_csMapping.Format("106_25GE_KP4_100GAUI1_P1P2_OSFP");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP56_103G_FEC_LAN:
            m_csMapping = "106_25GE_KP4_100GAUI2_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_FEC_LAN:
            m_csMapping = "103_125GE_KR4_CAUI4_CFP";
            //m_csMapping = "103G_LAN_FEC_CFP28";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_103G_LAN:
            m_csMapping = "103_125GE_CAUI4_CFP";
            //m_csMapping = "103G_LAN_CFP28";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP56_QUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI2_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP56_DQUAD_103G_FEC_LAN:
            m_csMapping = "4X_106_25GE_KP4_100GAUI2_P1P2_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_DUAL_103G_FEC_LAN:
            m_csMapping = "2X_106_25GE_KP4_100GAUI4_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_106G_FEC_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping = "106_25GE_KP4_100GAUI4_QSFP";
            else
                m_csMapping = "106G_LAN_FEC_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_106G_FEC_LAN:
            if ((m_globs->g_ppType == IDL_PP_MPMP400_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD800_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD400_GFP))
                m_csMapping = "106_25GE_KP4_100GAUI4_QSFPDD";
            else
                m_csMapping = "106G_LAN_FEC_QSFP_DD28";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_106G_FEC_LAN:
            m_csMapping = "106_25GE_KP4_100GAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_106G_FEC_LAN_P1P2:
            m_csMapping = "106_25GE_KP4_100GAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_106G_FEC_LAN_P1P2:
            m_csMapping = "106_25GE_KP4_100GAUI4_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_106G_FEC_LAN:
            m_csMapping = "106_25GE_KP4_100GAUI4_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_212G_FEC_LAN:
            m_csMapping = "212G_LAN_FEC_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_212G_FEC_LAN:
            m_csMapping = "212G_LAN_FEC_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_212G_FEC_LAN:
            if ((m_globs->g_ppType == IDL_PP_MPMP400_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD800_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD400_GFP))
                m_csMapping = "212_5GE_KP4_200GAUI4_QSFPDD";
            else
                m_csMapping = "212G_LAN_FEC_QSFP_DD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_212G_FEC_LAN_P1P2:
            m_csMapping = "212_5GE_KP4_200GAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_212G_FEC_LAN_P1P2:
            m_csMapping = "212_5GE_KP4_200GAUI4_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI8_QSFPDD";//"212G_LAN_FEC_CFP28";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI8_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_212G_FEC_LAN_P1P2:
            m_csMapping = "212_5GE_KP4_200GAUI8_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP28_212G_FEC_LAN_P1P2:
            m_csMapping = "212_5GE_KP4_200GAUI8_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP56_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI4_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP28_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI8_CFP";//"212G_LAN_FEC_CFP28";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_212G_FEC_LAN:
            m_csMapping = "212_5GE_KP4_200GAUI2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_212G_FEC_LAN_P1P2:
            m_csMapping = "212_5GE_KP4_200GAUI2_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_212G_FEC_LAN_P1P2:
            m_csMapping = "212_5GE_KP4_200GAUI2_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_DUAL_212G_FEC_LAN:
            m_csMapping = "2X_212_5GE_KP4_200GAUI2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_212G_FEC_LAN:
            m_csMapping = "2X_212_5GE_KP4_200GAUI2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_DUAL_212G_FEC_LAN_P1P2:
            m_csMapping = "2X_212_5GE_KP4_200GAUI2_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_212G_FEC_LAN_P1P2:
            m_csMapping = "2X_212_5GE_KP4_200GAUI2_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_DUAL_212G_FEC_LAN:
            m_csMapping = "2X_212_5GE_KP4_200GAUI4_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_DUAL_212G_FEC_LAN:
            m_csMapping = "2X_212_5GE_KP4_200GAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD56_DUAL_212G_FEC_LAN_P1P2:
            m_csMapping = "2X_212_5GE_KP4_200GAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_DUAL_212G_FEC_LAN_P1P2:
            m_csMapping = "2X_212_5GE_KP4_200GAUI4_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_QUAD_212G_FEC_LAN:
            m_csMapping = "4X_212_5GE_KP4_200GAUI2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_212G_FEC_LAN:
            m_csMapping = "4X_212_5GE_KP4_200GAUI2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_QUAD_212G_FEC_LAN_P1P2:
            m_csMapping = "4X_212_5GE_KP4_200GAUI2_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_212G_FEC_LAN_P1P2:
            m_csMapping = "4X_212_5GE_KP4_200GAUI2_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_425G_FEC_LAN:
            m_csMapping = "425GE_KP4_400GAUI16_CFP";//"425G_LAN_FEC_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN:
            if ((m_globs->g_ppType == IDL_PP_MPMP400_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD800_GFP) ||
                (m_globs->g_ppType == IDL_PP_HD400_GFP))
                m_csMapping = "425GE_KP4_400GAUI8_QSFPDD";
            else
                m_csMapping = "425G_LAN_FEC_QSFP_DD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN:
            m_csMapping = "425GE_KP4_400GAUI8_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_425G_FEC_LAN_P1P2:
            m_csMapping = "425GE_KP4_400GAUI8_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP56_425G_FEC_LAN_P1P2:
            m_csMapping = "425GE_KP4_400GAUI8_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN:
            m_csMapping = "425GE_KP4_400GAUI4_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN:
            m_csMapping = "425GE_KP4_400GAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD112_425G_FEC_LAN_P1P2:
            m_csMapping = "425GE_KP4_400GAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_425G_FEC_LAN_P1P2:
            m_csMapping = "425GE_KP4_400GAUI4_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DUAL_425G_FEC_LAN:
            m_csMapping = "2X_425GE_KP4_400GAUI4_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_425G_FEC_LAN:
            m_csMapping = "2X_425GE_KP4_400GAUI4_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DUAL_425G_FEC_LAN_P1P2:
            m_csMapping = "2X_425GE_KP4_400GAUI4_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_DUAL_425G_FEC_LAN_P1P2:
            m_csMapping = "2X_425GE_KP4_400GAUI4_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP56_425G_FEC_LAN:
            m_csMapping = "425GE_KP4_400GAUI8_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN:
            m_csMapping = "850GE_KP4_800GAUI8_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN:
            m_csMapping = "850GE_KP4_800GAUI8_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_P1P2:
            m_csMapping = "850GE_KP4_800GAUI8_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_P1P2:
            m_csMapping = "850GE_KP4_800GAUI8_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC:
            m_csMapping = "850GE_KP4_800GAUI8_ETC_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC:
            m_csMapping = "850GE_KP4_800GAUI8_ETC_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_850G_FEC_LAN_ETC_P1P2:
            m_csMapping = "850GE_KP4_800GAUI8_ETC_P1P2_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_OSFP112_850G_FEC_LAN_ETC_P1P2:
            m_csMapping = "850GE_KP4_800GAUI8_ETC_P1P2_OSFP";
            break;
        case IDL_PACKET2_PORT_MAP_OTN_41G_LAN:
            m_csMapping = "41G_LAN_IN_OTN";
            break;
        case IDL_PACKET2_PORT_MAP_OTN_103G_LAN:
            m_csMapping = "103G_LAN_IN_OTN";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_41G_SEED_AB:
            m_csMapping = "41G_SEED_AB";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_103G_SEED_AB:
            m_csMapping = "103G_SEED_AB";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD112_106G_FEC_LAN_P1P8:
            m_csMapping = "106_25GE_KP4_100GAUI1_P1P8_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD112_106G_FEC_LAN_P1P4:
            m_csMapping = "106_25GE_KP4_100GAUI1_P1P4_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_106G_FEC_LAN_P1P8:
            m_csMapping = "106_25GE_KP4_100GAUI2_P1P8_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_106G_FEC_LAN_P1P4:
            m_csMapping = "106_25GE_KP4_100GAUI2_P1P4_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_53G_FEC_LAN_P1P8:
            m_csMapping = "53_125GE_KP4_50GAUI1_P1P8_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_53G_FEC_LAN_P1P4:
            m_csMapping = "53_125GE_KP4_50GAUI1_P1P4_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD56_DUAL_53G_FEC_LAN_P1P8:
            m_csMapping = "2X_53_125GE_KP4_50GAUI1_P1P8_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD28_25G_LAN_P1P8:
            m_csMapping = "25_781GE_25GAUI_SFP_P1P8_SFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_SFP_DD28_25G_FEC_LAN_P1P8:
            m_csMapping = "25_781GE_KR_25GAUI_SFP_P1P8_SFPDD";
            break;
        default:
        case IDL_PACKET2_PORT_MAP_OFF:
            m_csMapping.Format("NOT_ASSIGNED");
            break;
        case IDL_PACKET2_PORT_MAP_GFP_PRBS:
            m_csMapping.Format("BULK");
            break;
        case IDL_PACKET2_PORT_MAP_GFP_TRANSPARENT_GBE:
            m_csMapping.Format("TRANSPARENT");
            break;
        case IDL_PACKET2_PORT_MAP_OMR_10G_LAN:
            if (m_globs->g_ppType == IDL_PP_MPMP400_GFP)
                m_csMapping.Format("10_312GE_XAUI_SFP");
            else
                m_csMapping.Format("10G_LAN");
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD10_QUAD_10G_LAN:
            m_csMapping = "4X_10_312GE_XAUI_QSFPDD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_CFP10_QUAD_10G_LAN:
            m_csMapping = "4X_10_312GE_XAUI_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP10_QUAD_10G_LAN:
            m_csMapping = "4X_10_312GE_XAUI_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_1G_FIBERCHAN:
            m_csMapping.Format("1G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_2G_FIBERCHAN:
            m_csMapping.Format("2G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_4G_FIBERCHAN:
            m_csMapping.Format("4G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_8G_FIBERCHAN:
            m_csMapping.Format("8G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_10G_FIBERCHAN:
            m_csMapping.Format("10G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_16G_FIBERCHAN:
            m_csMapping.Format("16G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_16G_FEC_FIBERCHAN:
            m_csMapping.Format("16G_FEC_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_32G_FIBERCHAN:
            m_csMapping.Format("32G_FIBRECHAN");
            break;
        case IDL_PACKET2_PORT_MAP_64G_FIBERCHAN:
            m_csMapping = "64G_FIBRECHAN";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_112G_FIBERCHAN:
            m_csMapping = "128G_FIBRECHAN_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_112G_FIBERCHAN:
            m_csMapping = "128G_FIBRECHAN_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP56_112G_FIBERCHAN:
            m_csMapping = "128G_FIBRECHAN_QSFP56";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_231G_FIBERCHAN:
            m_csMapping = "256G_FIBRECHAN_CFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_231G_FIBERCHAN:
            m_csMapping = "256G_FIBRECHAN_QSFP";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_231G_FIBERCHAN:
            m_csMapping = "256G_FIBRECHAN_QSFP_DD";
            break;
        case IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_231G_FIBERCHAN:
            m_csMapping = "256G_FIBRECHAN_QSFP_DD28";
            break;
        }
        break;
     case   IDL_PACKET2_PORT_INTERFACE_1G_FIBERCHAN:
        m_csMapping = "1G_FIBRECHAN";
        break;
     case   IDL_PACKET2_PORT_INTERFACE_2G_FIBERCHAN:
        m_csMapping = "2G_FIBRECHAN";
        break;
     case   IDL_PACKET2_PORT_INTERFACE_4G_FIBERCHAN:
        m_csMapping = "4G_FIBRECHAN";
        break;
     case   IDL_PACKET2_PORT_INTERFACE_8G_FIBERCHAN:
        m_csMapping = "8G_FIBRECHAN";
        break;
     case   IDL_PACKET2_PORT_INTERFACE_10G_FIBERCHAN:
        m_csMapping = "10G_FIBRECHAN";
        break;
     case   IDL_PACKET2_PORT_INTERFACE_41G_ENET:
        m_csMapping = "41G_LAN";
        break;
     case   IDL_PACKET2_PORT_INTERFACE_103G_ENET:
        m_csMapping = "103G_LAN";
        break;
    }
    m_pScpiProxyServer->scpiResults(m_csMapping);
}



//PING:GATEWAY
void ScpiPacket::setGatewayAddr (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;

    memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char *token = parms;
    int  index = 1;
    int  count = 0;
    int  addr;
    char period[] = ".";
    char *next_token;
    char *cpAddr = strtok_s(parms, period, &next_token);

    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // loop to get all 4 address elements - should be separated by '.'
        do
        {
                if (cpAddr == NULL)
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

            // convert the second parameter to integer
            addr = atoi(cpAddr);

            // check if value is in a valid range
            if (addr < STRMSETSRCIP_LOWERLIMIT || addr > STRMSETSRCIP_UPPERLIMIT)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.arpGatewayAddress[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 4);

        idlSettingsPacket.reference = IDL_PACKET2_REF_GATEWAY_ADDRESS;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure <<= idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:GATEWAY?
void ScpiPacket::getGatewayAddr (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 4; i++)
    {
        csVal.Format("%d", idlSettingsPacket.arpGatewayAddress[i]);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 3)
            csAddress += '.';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}



//PING:SUBNET
void ScpiPacket::setSubnetAddr (CString& csScpiCmd)
{
    if(csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

   CORBA::Any_var anyStructure=new CORBA::Any;

   IdlPacket2AllSettings idlSettingsPacket;

   memset((void*)&idlSettingsPacket, 0, sizeof(IdlPacket2AllSettings));

    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char *token = parms;
    int    index = 1;
    int    count = 0;
    int     addr;
    char    period[] = ".";
    char *next_token;
    char    *cpAddr = strtok_s(parms, period, &next_token);

    if (cpAddr == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // loop to get all 4 address elements - should be separated by '.'
        do
        {
                if (cpAddr == NULL)
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                    return;
                }

            // convert the second parameter to integer
            addr = atoi(cpAddr);

            // check if value is in a valid range
            if (addr < STRMSETSRCIP_LOWERLIMIT || addr > STRMSETSRCIP_UPPERLIMIT)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }

            // set the structure with the proper value and increment the count
            idlSettingsPacket.arpSubnetAddress[count++] = addr;

            //get the next byte
            cpAddr = strtok_s(NULL, period, &next_token);
        }
        while (count < 4);

        idlSettingsPacket.reference = IDL_PACKET2_REF_SUBNET_ADDRESS;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure <<= idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//PING:SUBNET?
void ScpiPacket::getSubnetAddr (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    int i;
    CString csAddress;
    CString csVal;
    csAddress.Empty();

    // get the next 5 bytes and concatenate into a string delimited by a '.'
    for (i = 0; i < 4; i++)
    {
        csVal.Format("%d", idlSettingsPacket.arpSubnetAddress[i]);
        csAddress += csVal;

        // add delimiter between bytes but not at the end.
        if (i < 3)
            csAddress += '.';
    }
    m_pScpiProxyServer->scpiResults(csAddress);
}

void ScpiPacket::setTxPti(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        if(!csScpiCmd.CollateNoCase("DATA"))
            idlSettingsPacket.gfpTxPti = 0;
        else if(!csScpiCmd.CollateNoCase("MGMT"))
            idlSettingsPacket.gfpTxPti = 4;
        else
        {


            LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

            int pti;
            char seps[]   = " ";
            int userFlag = 0;
            char *next_token;
            char *token = strtok_s( parms, seps , &next_token);
            //int len;
            //int i;

            if (token == NULL)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }

            // validate Stream Id and set the reference
            pti = atoi(token);
            if ((pti < 0) || (pti > 7))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                return;
            }
            idlSettingsPacket.gfpTxPti = pti;

        }


        idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_PTI;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

void ScpiPacket::getTxPti(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString pti;
    CString csVal;
    pti.Empty();

    if (idlSettingsPacket.gfpTxPti == 0)
        pti = "DATA";
    else if (idlSettingsPacket.gfpTxPti == 4)
        pti = "MGMT";
    else
        pti.Format("%d", idlSettingsPacket.gfpTxPti);
    m_pScpiProxyServer->scpiResults(pti);
}

void ScpiPacket::setTxSpare(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {

        LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

        int spare;
        char seps[]   = " ";
        int userFlag = 0;
        char *next_token;
        char *token = strtok_s( parms, seps , &next_token);
        //int len;
        //int i;

        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // validate Stream Id and set the reference
        spare = atoi(token);
        if ((spare < 0) || (spare > 255 ))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
        idlSettingsPacket.gfpTxSpare = spare;

        idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_TX_PTI;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

void ScpiPacket::getTxSpare(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString spare;
    CString csVal;
    spare.Empty();

    spare.Format("%d", idlSettingsPacket.gfpTxSpare);
    m_pScpiProxyServer->scpiResults(spare);
}


void ScpiPacket::setRxCidFilter(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {
        if (!csScpiCmd.CollateNoCase("ALL"))
             idlSettingsPacket.gfpRxCidFilter = 0xFFFF;

        else
        {
            LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

            int filter;
            char seps[]   = " ";
            int userFlag = 0;
            char *next_token;
            char *token = strtok_s( parms, seps , &next_token);
            //int len;
            //int i;

            if (token == NULL)
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
                return;
            }

            // validate Stream Id and set the reference
            filter = atoi(token);
            if ((filter < 0) || (filter > 255 ))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                return;
            }
            idlSettingsPacket.gfpRxCidFilter = filter;
        }
        idlSettingsPacket.reference = IDL_PACKET2_REF_GFP_RX_CDI;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

void ScpiPacket::getRxCidFilter(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    CString filter;
    CString csVal;
    filter.Empty();
    if (idlSettingsPacket.gfpRxCidFilter == 0xFFFF)
        filter.Format("ALL");
    else
        filter.Format("%d", idlSettingsPacket.gfpRxCidFilter);
    m_pScpiProxyServer->scpiResults(filter);
}






void ScpiPacket::setRxCid(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;


   if(!csScpiCmd.IsEmpty() && csScpiCmd != "")
   {

        LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

        int filter;
        char seps[]   = " ";
        int userFlag = 0;
        char *next_token;
        char *token = strtok_s( parms, seps , &next_token);
        //int len;
        //int i;

        if (token == NULL)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
            return;
        }

        // validate Stream Id and set the reference
        filter = atoi(token);
        if ((filter < 0) || (filter > 255 ))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }
        idlSettingsPacket.gfpRxCid = filter;

        idlSettingsPacket.reference = IDL_PACKET2_REF_RX_CID;
        idlSettingsPacket.restartInhibit = TRUE;

        anyStructure<<=idlSettingsPacket;
        m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
   }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_TYPE_ERR);
    }
}

void ScpiPacket::getRxCid(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    CString filter;
    CString csVal;
    filter.Empty();

    filter.Format("%d", idlSettingsPacket.gfpRxCid);
    m_pScpiProxyServer->scpiResults(filter);
}


void ScpiPacket::setDeficitIdle(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    if (!csScpiCmd.CollateNoCase("ON"))
    {
        idlSettingsPacket.deficitIdleEnable = 1;
    }
    else if (!csScpiCmd.CollateNoCase("OFF"))
    {
        idlSettingsPacket.deficitIdleEnable = 0;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }


    idlSettingsPacket.reference = IDL_PACKET2_REF_DEFICIT_IDLE;
    idlSettingsPacket.restartInhibit = TRUE;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

void ScpiPacket::getDeficitIdle(CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (idlSettingsPacket.deficitIdleEnable == 0)
        m_pScpiProxyServer->scpiResults("OFF");
    else if (idlSettingsPacket.deficitIdleEnable == 1)
        m_pScpiProxyServer->scpiResults("ON");
    else
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
}



///////////////////////////////////////////////////////////////////////////////
// RX:PAUSE?
void ScpiPacket::getPpPauseState (CString& csScpiCmd)
{
    CString csResults;
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;


    if (idlSettingsPacket.ppPauseState == 1)
        csResults = "ON";
    else
        csResults = "OFF";

    m_pScpiProxyServer->scpiResults(csResults);
}


///////////////////////////////////////////////////////////////////////////////
// RX:PAUSE
void ScpiPacket::setPpPauseState (CString& csScpiCmd)
{
    CString csParam;
    UCHAR pausedState;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
    }
    else
       idlSettingsPacket = *idlSettingsPacketPtr;

    // Get parameter
    TestAndGetParam(csScpiCmd, csParam);

    if (!csParam.CollateNoCase("ON"))
        pausedState = 1;
    else if (!csParam.CollateNoCase("OFF"))
        pausedState = 0;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::ILLEGAL_PARAM_VALUE);
        return;
    }

    idlSettingsPacket.reference      = IDL_PACKET2_REF_PAUSE_STATE;
    idlSettingsPacket.ppPauseState   = pausedState;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RX:CAPSIZE
//***************************
void ScpiPacket::setCaptureSize (CString& csScpiCmd)
{
    CString csParam;
    UCHAR captureSize;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    // Get parameter
    TestAndGetParam(csScpiCmd, csParam);

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (!csParam.CollateNoCase("FIRST64"))
        captureSize = IDL_PACKET2_CAPTURE_SIZE_64_BYTES;
    else if (!csParam.CollateNoCase("FIRST128"))
        captureSize = IDL_PACKET2_CAPTURE_SIZE_128_BYTES;
    else if (!csParam.CollateNoCase("FULLFRAME"))
        captureSize = IDL_PACKET2_CAPTURE_SIZE_FULL_FRAME;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::ILLEGAL_PARAM_VALUE);
        return;
    }

    idlSettingsPacket.reference   = IDL_PACKET2_REF_CAPTURE_SIZE;
    idlSettingsPacket.captureSize = captureSize;

    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}

//***************************
// RX:CAPSIZE?
//***************************
void ScpiPacket::getCaptureSize (CString&)
{
    CString csResults;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (idlSettingsPacket.captureSize == IDL_PACKET2_CAPTURE_SIZE_64_BYTES)
        csResults = "FIRST64";
    else if (idlSettingsPacket.captureSize == IDL_PACKET2_CAPTURE_SIZE_128_BYTES)
        csResults = "FIRST128";
    else if (idlSettingsPacket.captureSize == IDL_PACKET2_CAPTURE_SIZE_FULL_FRAME)
        csResults = "FULLFRAME";
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    m_pScpiProxyServer->scpiResults(csResults);

}

//***************************
// RX:CAPSTART
//***************************
void ScpiPacket::startCapture (CString&)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlOp1Struct   captureRequest;
    IdlReturnType  resultStatus;

    captureRequest.value = IDL_PACKET2_CAPTURE_ARM;
    anyStructure <<= captureRequest;

    StartCatch()
        resultStatus = (CorbaClient::m_ProtocolMgr)->setCommand(
                            m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
                            IDL_ARM_CAPTURE, anyStructure, m_globs->g_TestUnitId);
        if (resultStatus == IDL_FAIL)
        {
            IdlNakData* nak;
            if (anyStructure >>= nak)
            {
                if (nak->reason == IDL_REASON_OUT_OF_SERVICE)
                {
                    m_pScpiProxyServer->ReportCmdSetStatus(ScpiProxyServer::DLI_OUT_OF_SERVICE);
                    return;
                }
                else if (nak->reason == IDL_REASON_EXPIRED_CP_LICENSE)
                {
                    m_pScpiProxyServer->ReportCmdSetStatus(ScpiProxyServer::DLI_LICENSE_EXPIRED);
                    return;
                }
            }
            m_pScpiProxyServer->ReportCmdSetStatus(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }
        m_pScpiProxyServer->ReportCmdSetStatus(resultStatus);
    EndCatchWithoutReturn("ScpiProxyServer::getProtocols", pExp)
}

//***************************
// RX:CAPSTOP
//***************************
void ScpiPacket::stopCapture (CString&)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlOp1Struct   captureRequest;
    IdlReturnType  resultStatus;

    captureRequest.value = IDL_PACKET2_CAPTURE_STOP;
    anyStructure <<= captureRequest;
    StartCatch()
        resultStatus = (CorbaClient::m_ProtocolMgr)->setCommand(
                            m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
                            IDL_ARM_CAPTURE, anyStructure, m_globs->g_TestUnitId);
        if (resultStatus == IDL_FAIL)
        {
            IdlNakData* nak;
            if (anyStructure >>= nak)
            {
                if (nak->reason == IDL_REASON_OUT_OF_SERVICE)
                {
                    m_pScpiProxyServer->ReportCmdSetStatus(ScpiProxyServer::DLI_OUT_OF_SERVICE);
                    return;
                }
                else if (nak->reason == IDL_REASON_EXPIRED_CP_LICENSE)
                {
                    m_pScpiProxyServer->ReportCmdSetStatus(ScpiProxyServer::DLI_LICENSE_EXPIRED);
                    return;
                }
            }
            m_pScpiProxyServer->ReportCmdSetStatus(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }
        m_pScpiProxyServer->ReportCmdSetStatus(resultStatus);
    EndCatchWithoutReturn("ScpiProxyServer::getProtocols", pExp)
}

//***************************
// RES:CAPSTATUS?
//***************************
void ScpiPacket::getCaptureStatus  (CString&)
{
    CString csStatus;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    switch (idlStatPacket.captureState)
    {
    case IDL_PACKET2_CAPTURE_STOPPED:
        csStatus.Format("STOPPED");
        break;
    case IDL_PACKET2_CAPTURE_ARMED:
        csStatus.Format("ARMED");
        break;
    case IDL_PACKET2_CAPTURE_COMPLETE:
        csStatus.Format("DONE");
        break;
    case IDL_PACKET2_CAPTURE_OH_ARMED:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
        break;
    case IDL_PACKET2_CAPTURE_OH_COMPLETE:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
        break;
    }

    m_pScpiProxyServer->scpiResults(csStatus);
}

//***************************
// RES:CAPCOUNT?
//***************************
void ScpiPacket::getCaptureCount   (CString&)
{
    CString csStatus;
    IdlPacket2Stats idlStatPacket;
    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

    int capturePacketCount  = 0;

    if (idlStatPacket.firstCapturedFrame <= idlStatPacket.lastCapturedFrame)
        capturePacketCount = idlStatPacket.lastCapturedFrame - idlStatPacket.firstCapturedFrame + 1;

    switch (idlStatPacket.captureState)
    {
    case IDL_PACKET2_CAPTURE_STOPPED:
        csStatus.Format("0");
        break;
    case IDL_PACKET2_CAPTURE_ARMED:
        csStatus.Format("%d", capturePacketCount);
        break;
    case IDL_PACKET2_CAPTURE_COMPLETE:
        csStatus.Format("%d", capturePacketCount);
        break;
    case IDL_PACKET2_CAPTURE_OH_ARMED:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
        break;
    case IDL_PACKET2_CAPTURE_OH_COMPLETE:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
        break;
    }

    m_pScpiProxyServer->scpiResults(csStatus);
}

//***************************
// RX:CAPSAVE
//***************************
void  ScpiPacket::doCaptureSaveLevel  (CString& csScpiCmd)
{
    // Processing the command
    int iParseRet = TStartParse(this, rxCaptureSaveLevel, csScpiCmd, m_globs);

    if (iParseRet != ScpiProxyServer::DLI_NO_ERROR)
    {
        m_pScpiProxyServer->reportError(iParseRet);
    }
}

//***************************
// RX:CAPSAVE:PCAP
//***************************
void  ScpiPacket::saveCapturePcap     (CString& csScpiCmd)
{
    CString csFileName;
    CString csStatus;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2Stats        idlStatPacket;
    IdlPacket2AllSettings  idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;
    int     capturePacketCount  = 0;
    UINT32  snapLen;
    FILE*   fp;

    // Verify parameter is there.
    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    else
    {
        // If running on the MPA then save files into the default FTP folder.
        char szOtherTempBuf[512];
        if (GetEnvironmentVariable("SC_SERVICES_BASEDIR", szOtherTempBuf, sizeof(szOtherTempBuf)) != 0)
        {
            CString csTemp = szOtherTempBuf;
            csFileName = csTemp + "/" + csScpiCmd;
        }
        else
            csFileName = csScpiCmd;
    }

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    switch (idlSettingsPacket.captureSize)
    {
    case IDL_PACKET2_CAPTURE_SIZE_64_BYTES:
        snapLen = 64;
        break;
    case IDL_PACKET2_CAPTURE_SIZE_128_BYTES:
        snapLen = 128;
        break;
    case IDL_PACKET2_CAPTURE_SIZE_FULL_FRAME:
        snapLen = 16000;
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    if (idlStatPacket.firstCapturedFrame <= idlStatPacket.lastCapturedFrame)
        capturePacketCount = idlStatPacket.lastCapturedFrame - idlStatPacket.firstCapturedFrame + 1;

    // Empty any existing file so old setting don't get mixed in with the new.
    errno_t status = fopen_s(&fp, csFileName, "wb");
    if (!status)
    {
        bool isNanoSec = false;

        outputPcapHeader(fp, isNanoSec, snapLen);

        for (int i = 0; i < capturePacketCount; i++)
        {
            CapturedPacketStruct capturedPacket;
            BOOL status = downloadCapturedPacket(i, capturedPacket);

            if (status)
            {
                outputPcapPacket(fp, isNanoSec,
                                     idlStatPacket.captureTimestampOffset,
                                     capturedPacket.timestamp,
                                     capturedPacket.number,
                                     capturedPacket.packetSize,
                                     capturedPacket.captureSize,
                                     capturedPacket.data);
            }
        }
        fclose(fp);
    }
    else
    {
        #pragma warning(suppress:4996)
        printf("PCAP File opening error: %s\n", strerror(status));
        m_pScpiProxyServer->reportError(ScpiProxyServer::FILE_NOT_FOUND);
    }
}

//***************************
// RX:CAPSAVE:NANOPCAP
//***************************
void  ScpiPacket::saveCaptureNanoPcap (CString& csScpiCmd)
{
    CString csFileName;
    CString csStatus;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2Stats        idlStatPacket;
    IdlPacket2AllSettings  idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;
    int     capturePacketCount  = 0;
    UINT32  snapLen;
    FILE*   fp;

    // Verify parameter is there.
    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    else
    {
        // If running on the MPA then save files into the default FTP folder.
        char szOtherTempBuf[512];
        if (GetEnvironmentVariable("SC_SERVICES_BASEDIR", szOtherTempBuf, sizeof(szOtherTempBuf)) != 0)
        {
            CString csTemp = szOtherTempBuf;
            csFileName = csTemp + "/" + csScpiCmd;
        }
        else
            csFileName = csScpiCmd;
    }

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    switch (idlSettingsPacket.captureSize)
    {
    case IDL_PACKET2_CAPTURE_SIZE_64_BYTES:
        snapLen = 64;
        break;
    case IDL_PACKET2_CAPTURE_SIZE_128_BYTES:
        snapLen = 128;
        break;
    case IDL_PACKET2_CAPTURE_SIZE_FULL_FRAME:
        snapLen = 16000;
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    if (idlStatPacket.firstCapturedFrame <= idlStatPacket.lastCapturedFrame)
        capturePacketCount = idlStatPacket.lastCapturedFrame - idlStatPacket.firstCapturedFrame + 1;

    // Empty any existing file so old setting don't get mixed in with the new.
    errno_t status = fopen_s(&fp, csFileName, "wb");
    if (!status)
    {
        bool isNanoSec = true;

        outputPcapHeader(fp, isNanoSec, snapLen);

        for (int i = 0; i < capturePacketCount; i++)
        {
            CapturedPacketStruct capturedPacket;
            BOOL status = downloadCapturedPacket(i, capturedPacket);

            if (status)
            {
                outputPcapPacket(fp, isNanoSec,
                                     idlStatPacket.captureTimestampOffset,
                                     capturedPacket.timestamp,
                                     capturedPacket.number,
                                     capturedPacket.packetSize,
                                     capturedPacket.captureSize,
                                     capturedPacket.data);
            }
        }
        fclose(fp);
    }
    else
    {
        #pragma warning(suppress:4996)
        printf("NanoPCAP file opening error: %s\n", strerror(status));
        m_pScpiProxyServer->reportError(ScpiProxyServer::FILE_NOT_FOUND);
    }
}

//***************************
// RX:CAPSAVE:PCAPNG
//***************************
void  ScpiPacket::saveCapturePcapNg   (CString& csScpiCmd)
{
    CString csFileName;
    CString csStatus;
    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2Stats        idlStatPacket;
    IdlPacket2AllSettings  idlSettingsPacket;
    IdlPacket2AllSettings* idlSettingsPacketPtr;
    int     capturePacketCount  = 0;
    UINT32  snapLen;
    FILE*   fp;

    // Verify parameter is there.
    if (csScpiCmd.IsEmpty() || csScpiCmd == "")
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }
    else
    {
        // If running on the MPA then save files into the default FTP folder.
        char szOtherTempBuf[512];
        if (GetEnvironmentVariable("SC_SERVICES_BASEDIR", szOtherTempBuf, sizeof(szOtherTempBuf)) != 0)
        {
            CString csTemp = szOtherTempBuf;
            csFileName = csTemp + "/" + csScpiCmd;
        }
        else
            csFileName = csScpiCmd;
    }

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if (!(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    switch (idlSettingsPacket.captureSize)
    {
    case IDL_PACKET2_CAPTURE_SIZE_64_BYTES:
        snapLen = 64;
        break;
    case IDL_PACKET2_CAPTURE_SIZE_128_BYTES:
        snapLen = 128;
        break;
    case IDL_PACKET2_CAPTURE_SIZE_FULL_FRAME:
        snapLen = 16000;
        break;
    default:
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
    if (idlStatPacket.firstCapturedFrame <= idlStatPacket.lastCapturedFrame)
        capturePacketCount = idlStatPacket.lastCapturedFrame - idlStatPacket.firstCapturedFrame + 1;

    // Empty any existing file so old setting don't get mixed in with the new.
    errno_t status = fopen_s(&fp, csFileName, "wb");
    if (!status)
    {
        outputPcapNgHeader(fp, snapLen, idlStatPacket.captureTimestampOffset);

        for (int i = 0; i < capturePacketCount; i++)
        {
            CapturedPacketStruct capturedPacket;
            BOOL status = downloadCapturedPacket(i, capturedPacket);

            if (status)
            {
                outputPcapNgPacket(fp, idlStatPacket.captureTimestampOffset,
                                       capturedPacket.timestamp,
                                       capturedPacket.number,
                                       capturedPacket.packetSize,
                                       capturedPacket.captureSize,
                                       capturedPacket.data);
            }
        }
        fclose(fp);
    }
    else
    {
        #pragma warning(suppress:4996)
        printf("PCAPNG file opening error: %s\n", strerror(status));
        m_pScpiProxyServer->reportError(ScpiProxyServer::FILE_NOT_FOUND);
    }
}


//****************************************************************************
// Utility function to download a packet from Corba. Copied from GUI.
//****************************************************************************
BOOL ScpiPacket::readCaptureSlice(INT32 iFrame, UCHAR iSlice,
                                  IdlPacket2CaptureDataLarge& bResponse)
{
    // Init to invalid data for no response case.
    bResponse.timestamp   = 0;
    bResponse.frame       = -2000000000;
    bResponse.packetSize  = 0;
    bResponse.captureSize = 0;
    bResponse.sliceCount  = 0;
    bResponse.slice       = 0;
    memset(bResponse.packetSlice, 0, IDL_PACKET2_CAPTURE_SLICE_LARGE);

    StartCatch()

        // Fill in the request struct.
        IdlPacket2CaptureDataRequest_var bufferRequest;
        bufferRequest->frame  = iFrame;
        bufferRequest->slice  = iSlice;
        CORBA::Any_var anyStructVar = new CORBA::Any;
        anyStructVar <<= bufferRequest;

        // Read the requested slice.
        IdlReturnType idlReturn = (CorbaClient::m_ProtocolMgr)->getCommand(
                            m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
                            IDL_CAPTURED_DATA, anyStructVar);
        if (idlReturn == IDL_SUCCESS)
        {
            IdlPacket2CaptureDataLarge* captureDataLarge;
            IdlPacket2CaptureDataSmall* captureDataSmall;
            bool isSmall;

            isSmall = anyStructVar >>= captureDataSmall;
            if (isSmall)
            {
                // Convert small response into the large bResponse.
                bResponse.timestamp   = captureDataSmall->timestamp;
                bResponse.frame       = captureDataSmall->frame;
                bResponse.packetSize  = captureDataSmall->packetSize;
                bResponse.captureSize = captureDataSmall->captureSize;
                bResponse.sliceSize   = captureDataSmall->sliceSize;
                bResponse.sliceCount  = captureDataSmall->sliceCount;
                bResponse.slice       = captureDataSmall->slice;
                memcpy(bResponse.packetSlice, captureDataSmall->packetSlice, IDL_PACKET2_CAPTURE_SLICE_SMALL);
            }
            else
            {
                // Copy large response into the large bResponse.
                anyStructVar >>= captureDataLarge;
                bResponse = *captureDataLarge;
            }

            return TRUE;
        }

    EndCatchWithoutReturn("ScpiProxyServer::getProtocols", pExp)

    return FALSE;
}


//****************************************************************************
// Utility function to download a packet from Corba. Copied from GUI.
//****************************************************************************
BOOL ScpiPacket::downloadCapturedPacket(INT32 packetNumber,
                                        CapturedPacketStruct& result)
{
    BOOL   status = false;
    UCHAR  slice = 0;
    UINT16 size  = 0;
    IdlPacket2CaptureDataLarge sliceBuffer;


    // Read the first slice. Usually this is the only slice.
    status = readCaptureSlice(packetNumber, slice, sliceBuffer);

    if (status)
    {
        // Fill in global variables from the slice data.
        result.timestamp   = sliceBuffer.timestamp;
        result.number      = sliceBuffer.frame;
        result.packetSize  = sliceBuffer.packetSize;
        result.captureSize = sliceBuffer.captureSize;
        memcpy(result.data, sliceBuffer.packetSlice, sliceBuffer.sliceSize);
        size += sliceBuffer.sliceSize;

        // Read any additional slices that may exist.
        for (slice = 1; slice < sliceBuffer.sliceCount; slice++)
        {
            status = readCaptureSlice(packetNumber, slice, sliceBuffer);

            if (status)
            {
                memcpy(&(result.data[size]),
                       sliceBuffer.packetSlice, sliceBuffer.sliceSize);
                size += sliceBuffer.sliceSize;
            }
            else
            {
                // Exit loop at first failure.
                break;
            }
        }

        if (status && (result.captureSize == size))
        {
            // Every slice read was good.
            return TRUE;
        }
    }

    // Readinig of slices failed, return default invalid data.
    result.timestamp = 0;
    result.number = -2000000000;
    result.packetSize = 0;
    result.captureSize = 0;
    memset(result.data, 0, sizeof(result.data));

    return FALSE;
}


//***************************
// RES:CAPTURE:CID?
//***************************
void ScpiPacket::getCaptureCid (CString&)
{
   IdlPacket2Stats idlStatPacket;
   CString cid;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));

   cid.Format("%d",idlStatPacket.gfpRxCaptureCid);
   m_pScpiProxyServer->scpiResults(cid);
}


//************SPARE?
//***************************
void ScpiPacket::getCaptureSpare (CString&)
{
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CString spare;
   spare.Format("%d",idlStatPacket.gfpRxCaptureSpare);
   m_pScpiProxyServer->scpiResults(spare);
}


//***************************
// RES:CAPTURE:PLI?
//***************************
void ScpiPacket::getCapturePli (CString&)
{
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CString pli;
   pli.Format("0x%X", idlStatPacket.gfpRxCapturePli);
   m_pScpiProxyServer->scpiResults(pli);
}

//***************************
// RES:CAPTURE:PTI?
//***************************
void ScpiPacket::getCapturePti (CString&)
{
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CString csPti;
   if (idlStatPacket.gfpRxCapturePti == 0)
        csPti.Format("%s", "0-DATA");
    else  if (idlStatPacket.gfpRxCapturePti == 4)
        csPti.Format("%s", "4-MGMT");
    else
        csPti.Format("%d", idlStatPacket.gfpRxCapturePti);

   m_pScpiProxyServer->scpiResults(csPti);
}

//***************************
// RES:CAPTURE:PFI?
//***************************
void ScpiPacket::getCapturePfi (CString&)
{
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CString csPfi;
   if (idlStatPacket.gfpRxCapturePfi == 0)
        csPfi.Format("%s", "0-pFcs Off");
    else  if (idlStatPacket.gfpRxCapturePfi == 1)
        csPfi.Format("%s", "1-pFcs On");
    else
        csPfi.Format("%d", idlStatPacket.gfpRxCapturePfi);

   m_pScpiProxyServer->scpiResults(csPfi);
}


//***************************
// RES:CAPTURE:EXI?
//***************************
void ScpiPacket::getCaptureExi (CString&)
{
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CString csExi;
   if (idlStatPacket.gfpRxCaptureExi == 0)
        csExi.Format("%s", "0-NULL");
    else  if (idlStatPacket.gfpRxCaptureExi == 1)
        csExi.Format("%s", "1-Linear");
    else  if (idlStatPacket.gfpRxCaptureExi == 2)
        csExi.Format("%s", "2-Ring");
    else
        csExi.Format("%d", idlStatPacket.gfpRxCaptureExi);
   m_pScpiProxyServer->scpiResults(csExi);
}



//***************************
// RES:CAPTURE:UPI?
//***************************
void ScpiPacket::getCaptureUpi (CString&)
{
   IdlPacket2Stats idlStatPacket;
   TestCmdGetStatus(callGetPacketStatistics(idlStatPacket));
   CString csUpi;
   if (idlStatPacket.gfpRxCapturePti == 0)
   {
    if (idlStatPacket.gfpRxCaptureUpi == 1)
        csUpi.Format("%s", "0x01-Framed Eth");
    else  if (idlStatPacket.gfpRxCaptureUpi == 2)
        csUpi.Format("%s", "0x02-Framed PPP");
    else  if (idlStatPacket.gfpRxCaptureUpi == 3)
        csUpi.Format("%s", "0x03-Trans FC");
    else  if (idlStatPacket.gfpRxCaptureUpi == 4)
        csUpi.Format("%s", "0x04-Trans FICON");
    else  if (idlStatPacket.gfpRxCaptureUpi == 5)
        csUpi.Format("%s", "0x05-Trans ESCON");
    else  if (idlStatPacket.gfpRxCaptureUpi == 6)
        csUpi.Format("%s", "0x06-Trans GbE");
    else  if (idlStatPacket.gfpRxCaptureUpi == 8)
        csUpi.Format("%s", "0x08-MAPOS");
    else
        csUpi.Format("%d", idlStatPacket.gfpRxCaptureUpi);
   }

   else  if (idlStatPacket.gfpRxCapturePti == 4)
   {

    if (idlStatPacket.gfpRxCaptureUpi == 1)
        csUpi.Format("%s", "0x01-Client LOS");
    else  if (idlStatPacket.gfpRxCaptureUpi == 2)
        csUpi.Format("%s", "0x02-Client Loss-of-Sync");
    else
        csUpi.Format("%d", idlStatPacket.gfpRxCaptureUpi);
   }
    else
        csUpi.Format("%d", idlStatPacket.gfpRxCaptureUpi);

   m_pScpiProxyServer->scpiResults(csUpi);
}


void ScpiPacket::getCurrentErrors(CString& csScpiCmd)
{
    int i;
    CString csResult;
    csResult = "";

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;
    IdlPacket2Stats idlStat;
    IdlPacket2AllSettings  idlSettingsPacket2;
    IdlPacket2AllSettings* idlSettingsPacket2Ptr;
    IdlPacket2AllowedSettings* idlPacket2AllowedSettings;
    IdlPacket2AllowedSettings  idlAllow;
    IdlPacket2AllStreamStats idlStreamStatPacket;

    // Get the Stream Stats
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));


    // Get the Stats
    m_pScpiProxyServer->ReportCmdSetStatus(callGetPacketStatistics(idlStat));

    // Get settings so they can be passed in to get Allowed
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacket2Ptr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket2 = *idlSettingsPacket2Ptr;
    anyStructureVar <<= idlSettingsPacket2;

    // Get Allowed settings
    TestCmdGetStatus(callGetAllowedSettings(anyStructureVar, m_globs));
    if( !(anyStructureVar >>= idlPacket2AllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    idlAllow = *idlPacket2AllowedSettings;


    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[0],  0,  idlStat.seedAB,    idlAllow.seedABValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[1],  1,  idlStat.lineCode,    idlAllow.lineCodeValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[2],  2,  idlStat.collisions,   idlAllow.collisions);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[3],  3,  idlStat.fcs,   idlAllow.fcsValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[4],  4,  idlStat.ipChecksum,  idlAllow.ipChecksumValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[5],  5,  idlStat.udpChecksum,   idlAllow.udpChecksumValid);
//    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[6],  6,  idlStat.tcpChecksum,   idlAllow.tcpChecksumValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[6],  6,  idlStat.oversized,   idlAllow.fcEofAbortValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[7],  7,  idlStat.undersized,   idlAllow.undersizedValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[8],  8,  idlStat.runt,   idlAllow.runtValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[9],  9,  idlStat.correctableCHec,   idlAllow.correctableCHecValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[10], 10,  idlStat.uncorrectableCHec,   idlAllow.uncorrectableCHecValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[11], 11, idlStat.correctableTHec,   idlAllow.correctableTHecValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[12], 12, idlStat.uncorrectableTHec,   idlAllow.uncorrectableTHecValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[13], 13, idlStat.correctableEHec,   idlAllow.correctableEHecValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[14], 14, idlStat.uncorrectableEHec,   idlAllow.uncorrectableEHecValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[15], 15, idlStat.invalidSuper,   idlAllow.invalidSuperValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[16], 16, idlStat.superFcs,   idlAllow.superFcsValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[17], 17, idlStat.gfpFcs,   idlAllow.gfpFcsValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[18], 18, idlStat.fcAlignment,   idlAllow.fcEofAbortValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[19], 19, idlStat.fcEofAbort,   idlAllow.fcEofAbortValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[20], 20, idlStat.fcEofErr,   idlAllow.fcEofAbortValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[21], 21, idlStat.rxOsdErrCnt,   idlAllow.fcEofAbortValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[22], 22, idlStat.disparity,    idlAllow.disparityValid);
    csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[23], 23, idlStat.syncHdr,    idlAllow.syncHdrValid);
    char asciiText[80];

#pragma warning( push )
#pragma warning( disable : 4996 )
    for (i = 0; i < idlAllow.numStreams; i++)
        csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[24] + "-" + itoa(i + 1,asciiText,10), 24 + i,
            idlStreamStatPacket.streamStats[i].streamBit, idlAllow.streamAllowed[i].streamBitValid);
    for (i = 0; i < idlAllow.numStreams; i++)
        csResult += m_pScpiProxyServer->getErrorToken(csPacketErrorNames[25] + "-" + itoa(i + 1,asciiText,10), 56 + i,
            idlStreamStatPacket.streamStats[i].streamSequence, idlAllow.streamAllowed[i].streamSeqValid);
#pragma warning( pop )

    if (csResult == "")
        csResult = "+0";

    m_pScpiProxyServer->scpiResults(csResult);
}


void ScpiPacket::getCurrentAlarms(CString& csScpiCmd)
{
    CString csResult;
    csResult = "";


    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;
    IdlPacket2Stats idlStat;
    IdlPacket2AllSettings  idlSettingsPacket2;
    IdlPacket2AllSettings* idlSettingsPacket2Ptr;
    IdlPacket2AllowedSettings* idlPacket2AllowedSettings;
    IdlPacket2AllowedSettings  idlAllow;

    IdlPacket2AllStreamStats idlStreamStatPacket;

    // Get the Stream Stats
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));



    // Get the Stats
    m_pScpiProxyServer->ReportCmdSetStatus(callGetPacketStatistics(idlStat));

    // Get settings so they can be passed in to get Allowed
    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));
    if( !(anyStructure >>= idlSettingsPacket2Ptr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }
    idlSettingsPacket2 = *idlSettingsPacket2Ptr;
    anyStructureVar <<= idlSettingsPacket2;

    // Get Allowed settings
    TestCmdGetStatus(callGetAllowedSettings(anyStructureVar, m_globs));
    if( !(anyStructureVar >>= idlPacket2AllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }
    idlAllow = *idlPacket2AllowedSettings;



    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 0],  0,  idlStat.ppPaused,       idlAllow.ppPausedValid);
    //csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 1],  1,  idlStat.cpPowerLoss,    true);//idlAllow.cpPowerLossValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 1],  1,  idlStat.los,            idlAllow.losValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 2],  2,  idlStat.link,           idlAllow.linkValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 3],  3,  idlStat.localLinkFault, idlAllow.localLinkFaultValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 4],  4,  idlStat.remoteLinkFault,idlAllow.remoteLinkFaultValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 5],  5,  idlStat.jabber,         idlAllow.jabberValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 6],  6,  idlStat.gfpLfd,         idlAllow.gfpLfdValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 7],  7,  idlStat.gfpLocs,        idlAllow.gfpLocsValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 8],  8,  idlStat.gfpLoccs,       idlAllow.gfpLoccsValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[ 9],  9,  idlStat.gfpHdrMismatch, idlAllow.gfpHdrMismatchValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[10], 10,  idlStat.blockLockLoss,  idlAllow.blockLockLossValid);
    csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[11], 11,  idlStat.hiBer,          idlAllow.hiBerValid);

    char asciiText[80];

#pragma warning( push )
#pragma warning( disable : 4996 )
    for (int i = 0; i < idlAllow.numStreams; i++)
        csResult += m_pScpiProxyServer->getAlarmToken(csPacketAlarmNames[12] + "-" + itoa(i + 1,asciiText,10), 12 + i,
            idlStreamStatPacket.streamStats[i].streamPatternSync, idlAllow.streamAllowed[i].streamPatternSyncValid);
#pragma warning( pop )

    if (csResult == "")
        csResult = "+0";

    m_pScpiProxyServer->scpiResults(csResult);
}

// Check if Mpls is Licensed
bool ScpiPacket::IsMplsLicensed (void)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    CORBA::Any_var anyStructOnly=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs)) != IDL_SUCCESS)
        return false;
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return false;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs)) != IDL_SUCCESS )
        return false;
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return false;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs)) != IDL_SUCCESS)
        return false;
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return false;
    }

    // Tagging equal MLPS then verify MPLS is licensed
    if (currentPacketAllowedSettings->streamAllowed[0].taggingMask & IDL_PACKET2_TAGGING_MASK_MPLS)
    {
        return true;
    }
    else // MPLS Not Licensed
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return false;
    }
}

bool ScpiPacket::IsIpv6Licensed (void)
{
    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;
    CORBA::Any_var anyStructOnly=new CORBA::Any;

    IdlPacket2AllStreamSettings idlSettingsPacket;
    IdlPacket2AllStreamSettings *idlSettingsPacketPtr;
    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs)) != IDL_SUCCESS)
        return false;
    if( !(anyStructure >>= idlSettingsPacketPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return false;
    }
    else
        idlSettingsPacket = *idlSettingsPacketPtr;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs)) != IDL_SUCCESS)
        return false;
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return false;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs)) != IDL_SUCCESS)
        return false;
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return false;
    }

    // IPV6 then verify IPV6 is licensed
    if (currentPacketAllowedSettings->ipv6Valid)
    {
        return true;
    }
    else // IPV6 Not Licensed
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return false;
    }
}

bool ScpiPacket::Is8GValid (void)
{
    IdlPacket2AllSettings      PacketAllSettings;
    IdlPacket2AllSettings*     PacketAllSettingsPtr;
    memset(&PacketAllSettings, 0, sizeof(IdlPacket2AllSettings));

    IdlPacket2AllowedSettings  PacketAllowedSettings;
    //IdlPacket2AllowedSettings* PacketAllowedSettingsPtr;
    memset(&PacketAllowedSettings, 0, sizeof(IdlPacket2AllowedSettings));

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructureVar=new CORBA::Any;

    if (m_pScpiProxyServer->ReportCmdGetStatus(callGetAllSettings(anyStructure, m_globs)))
        return false;
    if( !(anyStructure >>= PacketAllSettingsPtr))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return (false);
    }

    PacketAllSettings = *PacketAllSettingsPtr;
    anyStructureVar <<= PacketAllSettings;

    // Get Allowed settings
    if (PacketAllSettings.portMapping != IDL_PACKET2_PORT_MAP_8G_FIBERCHAN)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return (false);
    }

    return (true);
}


//***************************
// TX:VLANFLOOD?
//***************************
void ScpiPacket::getVlanFlooding (CString&)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    //m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    // return;
   CString csVlanFlooding;
   if (idlSettingsPacket.vlanFlooding == IDL_PACKET2_VLAN_FLOODING_DECREMENT)
       csVlanFlooding = "DECR";
   else if (idlSettingsPacket.vlanFlooding == IDL_PACKET2_VLAN_FLOODING_INCREMENT)
       csVlanFlooding = "INCR";
   else if (idlSettingsPacket.vlanFlooding == IDL_PACKET2_VLAN_FLOODING_RANDOM)
       csVlanFlooding = "RAND";
   else // if (idlSettingsPacket.vlanFlooding == IDL_PACKET2_VLAN_FLOODING_OFF)
       csVlanFlooding = "OFF";

    csResult.Format("%s, %u, %u", csVlanFlooding, idlSettingsPacket.vlanFloodingMin, idlSettingsPacket.vlanFloodingMax);

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// TX:VLANFLOOD
//***************************
void ScpiPacket::setVlanFlooding (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:VLANFLOOD");
#endif
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }


    // check for 2 parameters
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Stream Id from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    int len;
    int i;
    UCHAR   vlanFlooding   = IDL_PACKET2_VLAN_FLOODING_OFF;
    UINT16  vlanFloodingMin     = 0x000;
    UINT16  vlanFloodingMax     = 0xFFF;
    UINT16  vlanFloodingMask = IDL_PACKET2_VLAN_FLOODING_OFF_MASK;
    CString csVlanFlooding;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csVlanFlooding.Format("%s", token);
    if (!csVlanFlooding.CollateNoCase("OFF"))
    {
        vlanFlooding     = IDL_PACKET2_VLAN_FLOODING_OFF;
        vlanFloodingMask = IDL_PACKET2_VLAN_FLOODING_OFF_MASK;
    }
    else if (!csVlanFlooding.CollateNoCase("DECR"))
    {
        vlanFlooding     = IDL_PACKET2_VLAN_FLOODING_DECREMENT;
        vlanFloodingMask = IDL_PACKET2_VLAN_FLOODING_DECREMENT_MASK;
    }
    else if (!csVlanFlooding.CollateNoCase("INCR"))
    {
        vlanFlooding     = IDL_PACKET2_VLAN_FLOODING_INCREMENT;
        vlanFloodingMask = IDL_PACKET2_VLAN_FLOODING_INCREMENT_MASK;
    }
    else if (!csVlanFlooding.CollateNoCase("RAND"))
    {
        vlanFlooding     = IDL_PACKET2_VLAN_FLOODING_RANDOM;
        vlanFloodingMask = IDL_PACKET2_VLAN_FLOODING_RANDOM_MASK;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::ILLEGAL_PARAM_VALUE);
        return;
    }
    if ((vlanFlooding == IDL_PACKET2_VLAN_FLOODING_DECREMENT) ||
        (vlanFlooding == IDL_PACKET2_VLAN_FLOODING_INCREMENT) ||
        (vlanFlooding == IDL_PACKET2_VLAN_FLOODING_RANDOM))
    {
        if ((currentPacketAllowedSettings->vlanFloodingMask & vlanFloodingMask) == 0)
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
            return;
        }
    }
    // get the second parameter
    token = strtok_s( NULL, seps , &next_token);
    if (token == NULL)
    {
        // if parameters are not included,
        // just send the lowest or highest settings allowed for min/max
        vlanFloodingMin = currentPacketAllowedSettings->vlanFloodingLo;
        vlanFloodingMax = currentPacketAllowedSettings->vlanFloodingHi;
    }
    else
    {
        // validate the string is digits only
        len = strlen(token);
        for (i = 0; i < len; i++)
        {
            if (!isdigit(token[i]))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                return;
            }
        }
        // convert and check the vlanFloodingMin value
        vlanFloodingMin = atoi(token);
        if ((vlanFlooding == IDL_PACKET2_VLAN_FLOODING_OFF) &&
            ((vlanFloodingMin < currentPacketAllowedSettings->vlanFloodingLo) ||
             (vlanFloodingMin > currentPacketAllowedSettings->vlanFloodingHi)))
        {
            m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
            return;
        }

        if ((vlanFlooding == IDL_PACKET2_VLAN_FLOODING_DECREMENT) ||
            (vlanFlooding == IDL_PACKET2_VLAN_FLOODING_INCREMENT) ||
            (vlanFlooding == IDL_PACKET2_VLAN_FLOODING_RANDOM))
        {
            // get the third parameter
            token = strtok_s( NULL, seps , &next_token);
            if (token == NULL)
            {
                // if parameters are not included,
                // just send the lowest or highest settings allowed for min/max
                vlanFloodingMax = currentPacketAllowedSettings->vlanFloodingHi;
            }
            else
            {
                // validate the string is digits only
                len = strlen(token);
                for (i = 0; i < len; i++)
                {
                    if (!isdigit(token[i]))
                    {
                        m_pScpiProxyServer->reportError(ScpiProxyServer::NUMERIC_DATA_ERR);
                        return;
                    }
                }

                // convert and check the vlanFloodingMax value
                vlanFloodingMax = atoi(token);
                if (((vlanFlooding == IDL_PACKET2_VLAN_FLOODING_DECREMENT) ||
                     (vlanFlooding == IDL_PACKET2_VLAN_FLOODING_INCREMENT) ||
                     (vlanFlooding == IDL_PACKET2_VLAN_FLOODING_RANDOM))      &&
                    ((vlanFloodingMax <= vlanFloodingMin) ||
                     (vlanFloodingMax > (currentPacketAllowedSettings->vlanFloodingHi))))
                {
                    m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                    return;
                }
            }
        }
    }

    idlSettingsPacketTmp.reference = IDL_PACKET2_REF_VLAN_FLOODING;
    // put the frame length into the structure
    idlSettingsPacketTmp.vlanFloodingMin     = vlanFloodingMin;
    // put the max frame length into the structure
    idlSettingsPacketTmp.vlanFloodingMax     = vlanFloodingMax;
    // put the frame size type into the structure
    idlSettingsPacketTmp.vlanFlooding = vlanFlooding;

    anyStructure<<=idlSettingsPacketTmp;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_SETTINGS, m_globs));

}


//***************************
// TX:LATENCYMODE?
//***************************
void ScpiPacket::getLatencyMode (CString&)
{
    CString csResult;

    CORBA::Any_var anyStructure=new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllSettings *idlSettingsPacketPtr;

    TestCmdGetStatus(callGetAllSettings(anyStructure, m_globs));

   if( !(anyStructure >>= idlSettingsPacketPtr))
   {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
       return;
   }
   else
       idlSettingsPacket = *idlSettingsPacketPtr;

    //m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    // return;
   CString csLatencyMode;
   if (idlSettingsPacket.latencyMode == IDL_PACKET2_LATENCY_MODE_ONE_WAY_DELAY)
       csLatencyMode = "OWD";
   else // if (idlSettingsPacket.latencyMode == IDL_PACKET2_LATENCY_MODE_ROUND_TRIP)
       csLatencyMode = "RTD";

    csResult.Format("%s", csLatencyMode);

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// TX:LATENCYMODE
//***************************
void ScpiPacket::setLatencyMode (CString& csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nTX:LATENCYMODE");
#endif
    int iStreamRef = 0;

    CORBA::Any_var anyStructure=new CORBA::Any;
    CORBA::Any_var anyStructVar=new CORBA::Any;

    IdlPacket2AllowedSettings* currentPacketAllowedSettings;
    CORBA::Any_var anyStructOnly=new CORBA::Any;
    IdlPacket2AllSettings *idlSettingsPacketOnly;
    IdlPacket2AllSettings idlSettingsPacketTmp;
    TestCmdGetStatus(callGetAllSettings(anyStructOnly, IDL_SETTINGS, m_globs));
    if( !(anyStructOnly >>= idlSettingsPacketOnly))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
        return;
    }

    idlSettingsPacketTmp = *idlSettingsPacketOnly;
    anyStructVar <<= idlSettingsPacketTmp;

    TestCmdGetStatus(callGetAllowedSettings(anyStructVar, m_globs));
    if( !(anyStructVar >>= currentPacketAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }


    // check for 1 parameter
    // remove spaces on ends of command string
    csScpiCmd.TrimLeft(" ");
    csScpiCmd.TrimRight(" ");

    // Get Latency Mode from the command string
    LPTSTR parms = csScpiCmd.GetBuffer(csScpiCmd.GetLength());

    char seps[]   = " ";
    char *next_token;
    char *token = strtok_s( parms, seps , &next_token);
    UCHAR   latencyMode   = IDL_PACKET2_LATENCY_MODE_ROUND_TRIP;
    UCHAR   latencyModeMask = IDL_PACKET2_LATENCY_MODE_MASK_ROUND_TRIP;
    CString csLatencyMode;

    if (token == NULL)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    csLatencyMode.Format("%s", token);
    if (!csLatencyMode.CollateNoCase("OWD"))
    {
        latencyMode     = IDL_PACKET2_LATENCY_MODE_ONE_WAY_DELAY;
        latencyModeMask = IDL_PACKET2_LATENCY_MODE_MASK_ONE_WAY_DELAY;
    }
    else if (!csLatencyMode.CollateNoCase("RTD"))
    {
        latencyMode     = IDL_PACKET2_LATENCY_MODE_ROUND_TRIP;
        latencyModeMask = IDL_PACKET2_LATENCY_MODE_MASK_ROUND_TRIP;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::ILLEGAL_PARAM_VALUE);
        return;
    }

    if ((currentPacketAllowedSettings->latencyModeMask & latencyModeMask) == 0)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    idlSettingsPacketTmp.reference = IDL_PACKET2_REF_LATENCY_MODE;
    idlSettingsPacketTmp.latencyMode = latencyMode;

    anyStructure<<=idlSettingsPacketTmp;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_SETTINGS, m_globs));
}


//***************************
// Y1564:TRIALDUR?
//***************************
void ScpiPacket::y1564GetTrialDur (CString& csScpiCmd)
{
    CString csResult;
    IdlPacket2AllSettings idlSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

    csResult.Format("%d", idlSettingsPacket.rfcTrialDuration);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:TRIALDUR
//***************************
void ScpiPacket::y1564SetTrialDur (CString& csScpiCmd)
{
    unsigned long trialDuration;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;

    // Get Current Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));

    if (csScpiCmd.IsEmpty())
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // Validate the parameter.
    trialDuration = atoi(csScpiCmd);
    if ((trialDuration < idlAllowedSettingsPacket.rfcTrialDurationLo) ||
        (trialDuration > idlAllowedSettingsPacket.rfcTrialDurationHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.rfcTrialDuration = trialDuration;
    idlSettingsPacket.reference = IDL_PACKET2_REF_RFC_TRIAL_DURATION;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// Y1564:PERFDUR?
//***************************
void ScpiPacket::y1564GetPerfDur (CString& csScpiCmd)
{
    CString csResult;
    IdlPacket2AllSettings idlSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

    csResult.Format("%d", idlSettingsPacket.servicePerfDuration);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:PERFDUR
//***************************
void ScpiPacket::y1564SetPerfDur (CString& csScpiCmd)
{
    unsigned long perfDuration;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;

    // Get Current Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));

    if (csScpiCmd.IsEmpty())
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    // Validate the parameter.
    perfDuration = atoi(csScpiCmd);
    if ((perfDuration < idlAllowedSettingsPacket.servicePerfDurationLo) ||
        (perfDuration > idlAllowedSettingsPacket.servicePerfDurationHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlSettingsPacket.servicePerfDuration = perfDuration;
    idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_PERF_DUR;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// Y1564:ENABLE?
//***************************
void ScpiPacket::y1564GetEnable (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    if (idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceEnable)
        csResult = "ON";
    else
        csResult = "OFF";
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:ENABLE
//***************************
void ScpiPacket::y1564SetEnable (CString& csScpiCmd)
{
    CString csParam;
    bool serviceChange[IDL_PACKET2_SERVICES];
    UCHAR serviceEnable;
    int i;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    for (i = 0; i < IDL_PACKET2_SERVICES; i++)
        serviceChange[i] = false;

    // Get first parameter.
    TestAndGetParam(csScpiCmd, csParam);

    if (csParam.CollateNoCase("ALL") == 0)
    {
        // Mark all the services as being set.
        for (i = 0; i < idlAllowedSettingsPacket.serviceCount; i++)
            serviceChange[i] = true;

        // Get on/off parameter.
        TestAndGetParam(csScpiCmd, csParam);
    }
    else
    {
        while (!csParam.IsEmpty())
        {
            int serviceNum;

            // on/off is the last parameter.
            if ((csParam.CollateNoCase("ON") == 0) ||
                (csParam.CollateNoCase("OFF") == 0))
                break;

            // Convert to integer and validate.
            serviceNum = atoi(csParam);
            if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                return;
            }

            // Mark the service as being set.
            serviceChange[serviceNum - 1] = true;

            // Get next parameter.
            TestAndGetParam(csScpiCmd, csParam);
        }
    }

    // Validate on/off parameter.
    if (csParam.CollateNoCase("ON") == 0)
        serviceEnable = 1;
    else if (csParam.CollateNoCase("OFF") == 0)
        serviceEnable = 0;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Set all the selected services to on or off.
    for (i = 0; i < IDL_PACKET2_SERVICES; i++)
    {
        if (serviceChange[i])
        {
            idlStreamSettingsPacket.streamSet[i].serviceEnable = serviceEnable;
            idlStreamSettingsPacket.streamSet[i].reference = IDL_PACKET2_STREAM_REF_SERVICE_ENABLE;
        }
    }

    idlStreamSettingsPacket.reference = 0xFF;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:MASKSTEP?
//***************************
void ScpiPacket::y1564GetMaskStep (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int step;
    unsigned short serviceStepMask;
    IdlPacket2AllSettings idlSettingsPacket;
    unsigned short steps[8] = {IDL_PACKET2_SERVICE_STEP1,
                               IDL_PACKET2_SERVICE_STEP2,
                               IDL_PACKET2_SERVICE_STEP3,
                               IDL_PACKET2_SERVICE_STEP4,
                               IDL_PACKET2_SERVICE_STEP5,
                               IDL_PACKET2_SERVICE_STEP6,
                               IDL_PACKET2_SERVICE_STEP7,
                               IDL_PACKET2_SERVICE_STEP8};

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

    // Get the step parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    step = atoi(csParam);
    if ((step < 1) || (step > 7))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Convert step number into a bit mask.
    serviceStepMask = steps[step - 1];

    if (idlSettingsPacket.serviceStepMask & serviceStepMask)
        csResult = "ON";
    else
        csResult = "OFF";
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:MASKSTEP
//***************************
void ScpiPacket::y1564SetMaskStep (CString& csScpiCmd)
{
    CString csParam;
    bool stepChange[7];
    UCHAR stepEnable;
    int i;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    unsigned short steps[8] = {IDL_PACKET2_SERVICE_STEP1,
                               IDL_PACKET2_SERVICE_STEP2,
                               IDL_PACKET2_SERVICE_STEP3,
                               IDL_PACKET2_SERVICE_STEP4,
                               IDL_PACKET2_SERVICE_STEP5,
                               IDL_PACKET2_SERVICE_STEP6,
                               IDL_PACKET2_SERVICE_STEP7,
                               IDL_PACKET2_SERVICE_STEP8};

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));

    for (i = 0; i < 7; i++)
        stepChange[i] = false;

    // Get first parameter.
    TestAndGetParam(csScpiCmd, csParam);

    if (csParam.CollateNoCase("ALL") == 0)
    {
        // Mark all the steps as being set.
        for (i = 0; i < 7; i++)
            stepChange[i] = true;

        // Get on/off parameter.
        TestAndGetParam(csScpiCmd, csParam);
    }
    else
    {
        while (!csParam.IsEmpty())
        {
            int stepNum;

            // on/off is the last parameter.
            if ((csParam.CollateNoCase("ON") == 0) ||
                (csParam.CollateNoCase("OFF") == 0))
                break;

            // Convert to integer and validate.
            stepNum = atoi(csParam);
            if ((stepNum < 1) || (stepNum > 7))
            {
                m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
                return;
            }

            // Mark the step as being set.
            stepChange[stepNum - 1] = true;

            // Get next parameter.
            TestAndGetParam(csScpiCmd, csParam);
        }
    }

    // Validate on/off parameter.
    if (csParam.CollateNoCase("ON") == 0)
        stepEnable = 1;
    else if (csParam.CollateNoCase("OFF") == 0)
        stepEnable = 0;
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Set all the selected steps to on or off.
    for (i = 0; i < 7; i++)
    {
        if (stepChange[i])
        {
            // set the structure with the proper value
            if (stepEnable)
                idlSettingsPacket.serviceStepMask |= steps[i];
            else
                idlSettingsPacket.serviceStepMask &= ~steps[i];

        }
    }

    idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_STEP_MASK;
    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure <<= idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// Y1564:RATESTEP?
//***************************
void ScpiPacket::y1564GetRateStep (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int step;
    unsigned long stepval;
    IdlPacket2AllSettings idlSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllSettings(idlSettingsPacket));

    // Get the step parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    step = atoi(csParam);
    if ((step < 1) || (step > 5))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(step)
    {
    case 1:  stepval = idlSettingsPacket.serviceStep1; break;
    case 2:  stepval = idlSettingsPacket.serviceStep2; break;
    case 3:  stepval = idlSettingsPacket.serviceStep3; break;
    case 4:  stepval = idlSettingsPacket.serviceStep4; break;
    case 5:  stepval = idlSettingsPacket.serviceStep5; break;
    }

    csResult.Format("%.2f %%", (double) stepval / 100);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:RATESTEP
//***************************
void ScpiPacket::y1564SetRateStep (CString& csScpiCmd)
{
    CString csParam;
    int step;
    unsigned long stepval;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;

    // Get Current Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));

    // Get the first parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    step = atoi(csParam);
    if ((step < 1) || (step > 5))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the second parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    stepval = (int) (atof(csParam) * 100);
    if ((stepval < 0) || (stepval > 10000))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    switch(step)
    {
    case 1:
        idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_STEP1;
        idlSettingsPacket.serviceStep1 = stepval;
        break;
    case 2:
        idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_STEP2;
        idlSettingsPacket.serviceStep2 = stepval;
        break;
    case 3:
        idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_STEP3;
        idlSettingsPacket.serviceStep3 = stepval;
        break;
    case 4:
        idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_STEP4;
        idlSettingsPacket.serviceStep4 = stepval;
        break;
    case 5:
        idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_STEP5;
        idlSettingsPacket.serviceStep5 = stepval;
        break;
    }

    idlSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetAllSettings(anyStructure, m_globs));
}


//***************************
// Y1564:CIREIR?
//***************************
void ScpiPacket::y1564GetCirEir (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%.2f %%", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceCirEir / 100);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:CIREIR
//***************************
void ScpiPacket::y1564SetCirEir (CString& csScpiCmd)
{
    CString csParam;
    int serviceNum;
    unsigned long cirEir;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the second parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    cirEir = (int) (atof(csParam) * 100);
    if ((cirEir < idlAllowedSettingsPacket.serviceCirEirLo) ||
        (cirEir > idlAllowedSettingsPacket.serviceCirEirHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceCirEir = cirEir;
    idlStreamSettingsPacket.streamSet[serviceNum - 1].reference = IDL_PACKET2_STREAM_REF_CIREIR;

    idlStreamSettingsPacket.reference = serviceNum - 1;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:CIR?
//***************************
void ScpiPacket::y1564GetCir (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%.2f %%", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceCir / 100);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:CIR
//***************************
void ScpiPacket::y1564SetCir (CString& csScpiCmd)
{
    CString csParam;
    int serviceNum;
    unsigned long cir;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the second parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    cir = (int) (atof(csParam) * 100);
    if ((cir < idlAllowedSettingsPacket.serviceCirLo) ||
        (cir > idlAllowedSettingsPacket.serviceCirHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceCir = cir;
    idlStreamSettingsPacket.streamSet[serviceNum - 1].reference = IDL_PACKET2_STREAM_REF_CIR;

    idlStreamSettingsPacket.reference = serviceNum - 1;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:MAXJIT?
//***************************
void ScpiPacket::y1564GetMaxJit (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    if (idlAllowedSettingsPacket.serviceJitterMaxValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxJitter / 1000.0);
    else if (idlAllowedSettingsPacket.serviceJitterMaxValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxJitter / 100.0);
    else if (idlAllowedSettingsPacket.serviceJitterMaxValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxJitter / 10.0);
    else
        csResult.Format("%d", idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxJitter);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:MAXJIT
//***************************
void ScpiPacket::y1564SetMaxJit (CString& csScpiCmd)
{
    CString csParam;
    int serviceNum;
    unsigned long maxJitter;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the second parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    if (idlAllowedSettingsPacket.serviceJitterMaxValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        maxJitter = (unsigned long) (atof(csParam) * 1000.0);
    else if (idlAllowedSettingsPacket.serviceJitterMaxValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        maxJitter = (unsigned long) (atof(csParam) * 100.0);
    else if (idlAllowedSettingsPacket.serviceJitterMaxValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        maxJitter = (unsigned long) (atof(csParam) * 10.0);
    else
        maxJitter = atoi(csParam);
    if ((maxJitter < idlAllowedSettingsPacket.serviceMaxJitterLo) ||
        (maxJitter > idlAllowedSettingsPacket.serviceMaxJitterHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxJitter = maxJitter;
    idlStreamSettingsPacket.streamSet[serviceNum - 1].reference = IDL_PACKET2_STREAM_REF_MAXJITTER;

    idlStreamSettingsPacket.reference = serviceNum - 1;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:MAXLOSS?
//***************************
void ScpiPacket::y1564GetMaxLoss (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    csResult.Format("%.2f %%", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxFrameloss / 100);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:MAXLOSS
//***************************
void ScpiPacket::y1564SetMaxLoss (CString& csScpiCmd)
{
    CString csParam;
    int serviceNum;
    unsigned long maxFrameloss;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the second parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    maxFrameloss = (int) (atof(csParam) * 100);
    if ((maxFrameloss < idlAllowedSettingsPacket.serviceMaxFramelossLo) ||
        (maxFrameloss > idlAllowedSettingsPacket.serviceMaxFramelossHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxFrameloss = maxFrameloss;
    idlStreamSettingsPacket.streamSet[serviceNum - 1].reference = IDL_PACKET2_STREAM_REF_MAXFRAMELOSS;

    idlStreamSettingsPacket.reference = serviceNum - 1;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:MAXLAT?
//***************************
void ScpiPacket::y1564GetMaxLat (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxLatency / 1000.0);
    else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxLatency / 100.0);
    else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxLatency / 10.0);
    else
        csResult.Format("%d", idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxLatency);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:MAXLAT
//***************************
void ScpiPacket::y1564SetMaxLat (CString& csScpiCmd)
{
    CString csParam;
    int serviceNum;
    unsigned long maxLatency;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the second parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        maxLatency = (unsigned long) (atof(csParam) * 1000.0);
    else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        maxLatency = (unsigned long) (atof(csParam) * 100.0);
    else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        maxLatency = (unsigned long) (atof(csParam) * 10.0);
    else
        maxLatency = atoi(csParam);
    if ((maxLatency < idlAllowedSettingsPacket.serviceMaxLatencyLo) ||
        (maxLatency > idlAllowedSettingsPacket.serviceMaxLatencyHi))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceMaxLatency = maxLatency;
    idlStreamSettingsPacket.streamSet[serviceNum - 1].reference = IDL_PACKET2_STREAM_REF_MAXLATENCY;

    idlStreamSettingsPacket.reference = serviceNum - 1;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:SERVICENAME?
//***************************
void ScpiPacket::y1564GetServiceName (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    if (strlen((char*)idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceName) > 19)
        idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceName[19] = 0;

    csResult.Format("%s", idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceName);
    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:SERVICENAME
//***************************
void ScpiPacket::y1564SetServiceName (CString& csScpiCmd)
{
    CString csParam;
    int serviceNum;
    int i;
    CORBA::Any_var anyStructure = new CORBA::Any;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllStreamSettings idlStreamSettingsPacket;

    // Get Current Stream Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketAllStreamSettings(idlStreamSettingsPacket));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // The rest of the command is the second parameter. This allows spaces in
    // the name. Need to validate for length.
    if (csScpiCmd.GetLength() > 19)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    for (i = 0; i < 20; i++)
        idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceName[i] = 0;
    for (i = 0; i < csScpiCmd.GetLength(); i++)
        idlStreamSettingsPacket.streamSet[serviceNum - 1].serviceName[i] = csScpiCmd[i];
    idlStreamSettingsPacket.streamSet[serviceNum - 1].reference = IDL_PACKET2_STREAM_REF_SERVICENAME;

    idlStreamSettingsPacket.reference = serviceNum - 1;
    idlStreamSettingsPacket.restartInhibit = TRUE;
    anyStructure<<=idlStreamSettingsPacket;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_STREAM_SETTINGS, m_globs));
}


//***************************
// Y1564:ACT?
//***************************
void ScpiPacket::y1564GetActivate (CString& csScpiCmd)
{
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;

    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    switch (idlPacket2AllServiceStats.serviceState)
    {
    case IDL_PACKET2_SERVICE_CONFIG_RAMP_ACTIVE:
        m_pScpiProxyServer->scpiResults("RAMP");
        break;
    case IDL_PACKET2_SERVICE_CONFIG_BURST_ACTIVE:
        m_pScpiProxyServer->scpiResults("BURST");
        break;
    case IDL_PACKET2_SERVICE_PERF_ACTIVE:
        m_pScpiProxyServer->scpiResults("PERF");
        break;
    case IDL_PACKET2_SERVICE_TEST_COMPLETE:
        m_pScpiProxyServer->scpiResults("COMPLETE");
        break;
    default:
        m_pScpiProxyServer->scpiResults("STOPPED");
        break;
    }
}


//***************************
// Y1564:ACT
//***************************
void ScpiPacket::y1564SetActivate (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure = new CORBA::Any;
    UCHAR multiServSelected;
    IdlOp1Struct idlOp1Settings;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;

    // Get Current Allowed Settings
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));

    if (csScpiCmd.IsEmpty())
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::MISSING_PARAM);
        return;
    }

    if (!csScpiCmd.CollateNoCase("STOP"))
    {
        idlOp1Settings.value = IDL_PACKET2_SERVICE_TEST_STOP;
        multiServSelected = idlSettingsPacket.multiServSelected;
    }
    else if (!csScpiCmd.CollateNoCase("RAMP"))
    {
        idlOp1Settings.value = IDL_PACKET2_SERVICE_CONFIG_RAMP_START;
        multiServSelected = IDL_PACKET2_SERVICE_CONFIG_RAMP_SELECTED;
    }
    else if (!csScpiCmd.CollateNoCase("PERF"))
    {
        idlOp1Settings.value = IDL_PACKET2_SERVICE_PERF_START;
        multiServSelected = IDL_PACKET2_SERVICE_PERF_SELECTED;
    }
    else if (!csScpiCmd.CollateNoCase("RAMP_PERF"))
    {
        idlOp1Settings.value = IDL_PACKET2_SERVICE_CONFIG_RAMP_PERF_START;
        multiServSelected = IDL_PACKET2_SERVICE_CONFIG_RAMP_SELECTED |
                            IDL_PACKET2_SERVICE_PERF_SELECTED;
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Can't run RFC in ID337 mode.
    if (idlSettingsPacket.emixMode == IDL_PACKET2_EMIX_ID337)
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_SETTINGS);
        return;
    }

    // Set flags so GUI displays properly.
    if (idlSettingsPacket.multiServSelected != multiServSelected)
    {
        CORBA::Any_var anyStructure2 = new CORBA::Any;
        idlSettingsPacket.reference = IDL_PACKET2_REF_SERVICE_MULTI;
        idlSettingsPacket.multiServSelected = multiServSelected;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure2 <<= idlSettingsPacket;
        callSetAllSettings(anyStructure2, m_globs);
    }
    if (idlSettingsPacket.ethSamOrRfc != IDL_ETHSAM_VIEW)
    {
        CORBA::Any_var anyStructure2 = new CORBA::Any;
        idlSettingsPacket.reference  = IDL_PACKET2_REF_ETHSAM_OR_RFC;
        idlSettingsPacket.ethSamOrRfc = IDL_ETHSAM_VIEW;
        idlSettingsPacket.restartInhibit = TRUE;
        anyStructure2 <<= idlSettingsPacket;
        callSetAllSettings(anyStructure2, m_globs);
    }

    // Actually start/stop the test.
    anyStructure<<=idlOp1Settings;
    m_pScpiProxyServer->ReportCmdSetStatus(callSetCmdTypeSettings(anyStructure, IDL_ARM_SERVICE_TEST, m_globs));
}


//***************************
// Y1564:RAMPSTATUS?
//***************************
void ScpiPacket::y1564GetRampStatus (CString& csScpiCmd)
{
    CString csResult;
    UCHAR   maxServiceStatus = IDL_PACKET2_SERVICE_TEST_OFF;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    if (idlPacket2AllServiceStats.serviceState == IDL_PACKET2_SERVICE_CONFIG_RAMP_ACTIVE)
        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_RUNNING;
    else
    {
        if (idlSettingsPacket.multiServSelected & IDL_PACKET2_SERVICE_CONFIG_RAMP_SELECTED)
        {
            for (int serviceNum = 1; serviceNum <= idlAllowedSettingsPacket.serviceCount; serviceNum++)
            {
                for (int iIndex = 0; iIndex < 7; iIndex++)
                {
                    switch(idlPacket2AllServiceStats.serviceStats[serviceNum - 1].serviceStatus[iIndex])
                    {
                    case IDL_PACKET2_SERVICE_TEST_PASS:
                        if ((maxServiceStatus != IDL_PACKET2_SERVICE_TEST_FAIL) &&
                            (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_RUNNING))
                            maxServiceStatus = IDL_PACKET2_SERVICE_TEST_PASS;
                        break;
                    case IDL_PACKET2_SERVICE_TEST_FAIL:
                        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_FAIL;
                        break;
                    case IDL_PACKET2_SERVICE_TEST_RUNNING:
                        if (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_FAIL)
                            maxServiceStatus = IDL_PACKET2_SERVICE_TEST_RUNNING;
                        break;
                    }
                }
            }
        }
        else
            maxServiceStatus = IDL_PACKET2_SERVICE_TEST_OFF;
    }

    switch (maxServiceStatus)
    {
    case IDL_PACKET2_SERVICE_TEST_PASS:
        csResult = "PASS";
        break;
    case IDL_PACKET2_SERVICE_TEST_FAIL:
        csResult = "FAIL";
        break;
    case IDL_PACKET2_SERVICE_TEST_RUNNING:
        csResult = "RUNNING";
        break;
    default:
    case IDL_PACKET2_SERVICE_TEST_OFF:
        csResult = "OFF";
        break;
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:PERFSTATUS?
//***************************
void ScpiPacket::y1564GetPerfStatus (CString& csScpiCmd)
{
    CString csResult;
    UCHAR   maxServiceStatus = IDL_PACKET2_SERVICE_TEST_OFF;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    if (idlPacket2AllServiceStats.serviceState == IDL_PACKET2_SERVICE_PERF_ACTIVE)
        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_RUNNING;
    else
    {
        if (idlSettingsPacket.multiServSelected & IDL_PACKET2_SERVICE_PERF_SELECTED)
        {
            for (int serviceNum = 1; serviceNum <= idlAllowedSettingsPacket.serviceCount; serviceNum++)
            {
                switch(idlPacket2AllServiceStats.serviceStats[serviceNum - 1].servicePerfStatus)
                {
                case IDL_PACKET2_SERVICE_TEST_PASS:
                    if ((maxServiceStatus != IDL_PACKET2_SERVICE_TEST_FAIL) &&
                        (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_RUNNING))
                        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_PASS;
                    break;
                case IDL_PACKET2_SERVICE_TEST_FAIL:
                    maxServiceStatus = IDL_PACKET2_SERVICE_TEST_FAIL;
                    break;
                case IDL_PACKET2_SERVICE_TEST_RUNNING:
                    if (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_FAIL)
                        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_RUNNING;
                    break;
                }
            }
        }
        else
            maxServiceStatus = IDL_PACKET2_SERVICE_TEST_OFF;
    }

    switch (maxServiceStatus)
    {
    case IDL_PACKET2_SERVICE_TEST_PASS:
        csResult = "PASS";
        break;
    case IDL_PACKET2_SERVICE_TEST_FAIL:
        csResult = "FAIL";
        break;
    case IDL_PACKET2_SERVICE_TEST_RUNNING:
        csResult = "RUNNING";
        break;
    default:
    case IDL_PACKET2_SERVICE_TEST_OFF:
        csResult = "OFF";
        break;
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:RAMP?
//***************************
void ScpiPacket::y1564GetRamp (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    double maxServicePctLoss = 0;
    UINT32 maxServiceJitterMax = 0;
    UINT32 maxServiceLatencyMax = 0;
    double maxServicePctBwAvg = 0;
    UCHAR  maxServiceStatus = IDL_PACKET2_SERVICE_TEST_OFF;
    CString csMaxServiceStatus;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);
    for (int iIndex = 0; iIndex < 7; iIndex++)
    {
        if (idlPacket2ServiceStats->serviceStatus[iIndex] != IDL_PACKET2_SERVICE_TEST_OFF)
        {
            if (maxServicePctLoss < (double) idlPacket2ServiceStats->servicePctLoss[iIndex] / 100.0)
                maxServicePctLoss = (double) idlPacket2ServiceStats->servicePctLoss[iIndex] / 100.0;
            if (maxServiceJitterMax < idlPacket2ServiceStats->serviceJitterMax[iIndex])
                maxServiceJitterMax = idlPacket2ServiceStats->serviceJitterMax[iIndex];
            if (maxServiceLatencyMax < idlPacket2ServiceStats->serviceLatencyMax[iIndex])
                maxServiceLatencyMax = idlPacket2ServiceStats->serviceLatencyMax[iIndex];
            if (iIndex != IDL_PACKET2_STEP_CIR_EIR)
            {
                switch(idlPacket2ServiceStats->serviceStatus[iIndex])
                {
                case IDL_PACKET2_SERVICE_TEST_PASS:
                    if ((maxServiceStatus != IDL_PACKET2_SERVICE_TEST_FAIL) &&
                        (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_RUNNING))
                        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_PASS;
                    break;
                case IDL_PACKET2_SERVICE_TEST_FAIL:
                    maxServiceStatus = IDL_PACKET2_SERVICE_TEST_FAIL;
                    break;
                case IDL_PACKET2_SERVICE_TEST_RUNNING:
                    if (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_FAIL)
                        maxServiceStatus = IDL_PACKET2_SERVICE_TEST_RUNNING;
                    break;
                }
            }
            if (maxServicePctBwAvg < (double) idlPacket2ServiceStats->servicePctBwAvg[iIndex] / 100.0)
                maxServicePctBwAvg = (double) idlPacket2ServiceStats->servicePctBwAvg[iIndex] / 100.0;
        }
    }

    switch (maxServiceStatus)
    {
    case IDL_PACKET2_SERVICE_TEST_PASS:
        csMaxServiceStatus = "PASS";
        break;
    case IDL_PACKET2_SERVICE_TEST_FAIL:
        csMaxServiceStatus = "FAIL";
        break;
    case IDL_PACKET2_SERVICE_TEST_RUNNING:
        csMaxServiceStatus = "RUNNING";
        break;
    default:
    case IDL_PACKET2_SERVICE_TEST_OFF:
        csMaxServiceStatus = "OFF";
        break;
    }

    if (maxServiceStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
            csResult.Format("%.2f %%, %.2f %%, %.3f, %.3f, %s",
                            maxServicePctBwAvg,
                            maxServicePctLoss,
                            (double) maxServiceJitterMax / 1000.0,
                            (double) maxServiceLatencyMax / 1000.0,
                            csMaxServiceStatus);
        else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
            csResult.Format("%.2f %%, %.2f %%, %.2f, %.2f, %s",
                            maxServicePctBwAvg,
                            maxServicePctLoss,
                            (double) maxServiceJitterMax / 100.0,
                            (double) maxServiceLatencyMax / 100.0,
                            csMaxServiceStatus);
        else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
            csResult.Format("%.2f %%, %.2f %%, %.1f, %.1f, %s",
                            maxServicePctBwAvg,
                            maxServicePctLoss,
                            (double) maxServiceJitterMax / 10.0,
                            (double) maxServiceLatencyMax / 10.0,
                            csMaxServiceStatus);
        else
            csResult.Format("%.2f %%, %.2f %%, %d, %d, %s",
                            maxServicePctBwAvg,
                            maxServicePctLoss,
                            maxServiceJitterMax,
                            maxServiceLatencyMax,
                            csMaxServiceStatus);
    }
    else
    {
        csResult = "---, ---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}

//***************************
// Y1564:STEP?
//***************************
void ScpiPacket::y1564GetStep (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    int stepNum;
    CString csServiceStatus;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get the step number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    stepNum = atoi(csParam);
    if ((stepNum < 1) || (stepNum > 7))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);

    switch (idlPacket2ServiceStats->serviceStatus[stepNum - 1])
    {
    case IDL_PACKET2_SERVICE_TEST_PASS:
        csServiceStatus = "PASS";
        break;
    case IDL_PACKET2_SERVICE_TEST_FAIL:
        csServiceStatus = "FAIL";
        break;
    case IDL_PACKET2_SERVICE_TEST_RUNNING:
        csServiceStatus = "RUNNING";
        break;
    default:
    case IDL_PACKET2_SERVICE_TEST_OFF:
        csServiceStatus = "OFF";
        break;
    }

    if (idlPacket2ServiceStats->serviceStatus[stepNum - 1] != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        {
            if (stepNum - 1 == IDL_PACKET2_STEP_CIR_EIR)
                csResult.Format("%.2f %%, %.2f %%, %.3f, %.3f",
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceJitterMax[stepNum - 1] / 1000.0,
                                (double) idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1] / 1000.0);
            else
                csResult.Format("%.2f %%, %.2f %%, %.2f %%, %.3f, %.3f, %s",
                                (double) idlPacket2ServiceStats->servicePctCir[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceJitterMax[stepNum - 1] / 1000.0,
                                (double) idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1] / 1000.0,
                                csServiceStatus);
        }
        else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        {
            if (stepNum - 1 == IDL_PACKET2_STEP_CIR_EIR)
                csResult.Format("%.2f %%, %.2f %%, %.2f, %.2f",
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceJitterMax[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1] / 100.0);
            else
                csResult.Format("%.2f %%, %.2f %%, %.2f %%, %.2f, %.2f, %s",
                                (double) idlPacket2ServiceStats->servicePctCir[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceJitterMax[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1] / 100.0,
                                csServiceStatus);
        }
        else if (idlAllowedSettingsPacket.serviceLatencyMaxValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        {
            if (stepNum - 1 == IDL_PACKET2_STEP_CIR_EIR)
                csResult.Format("%.2f %%, %.2f %%, %.1f, %.1f",
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceJitterMax[stepNum - 1] / 10.0,
                                (double) idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1] / 10.0);
            else
                csResult.Format("%.2f %%, %.2f %%, %.2f %%, %.1f, %.1f, %s",
                                (double) idlPacket2ServiceStats->servicePctCir[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->serviceJitterMax[stepNum - 1] / 10.0,
                                (double) idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1] / 10.0,
                                csServiceStatus);
        }
        else
        {
            if (stepNum - 1 == IDL_PACKET2_STEP_CIR_EIR)
                csResult.Format("%.2f %%, %.2f %%, %d, %d",
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                idlPacket2ServiceStats->serviceJitterMax[stepNum - 1],
                                idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1]);
            else
                csResult.Format("%.2f %%, %.2f %%, %.2f %%, %d, %d, %s",
                                (double) idlPacket2ServiceStats->servicePctCir[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctBwAvg[stepNum - 1] / 100.0,
                                (double) idlPacket2ServiceStats->servicePctLoss[stepNum - 1] / 100.0,
                                idlPacket2ServiceStats->serviceJitterMax[stepNum - 1],
                                idlPacket2ServiceStats->serviceLatencyMax[stepNum - 1],
                                csServiceStatus);
        }
    }
    else
    {
        if (stepNum - 1 == IDL_PACKET2_STEP_CIR_EIR)
            csResult = "---, ---, ---, ---";
        else
            csResult = "---, ---, ---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:PERF?
//***************************
void ScpiPacket::y1564GetPerf (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    CString csServiceStatus;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);
    switch (idlPacket2ServiceStats->servicePerfStatus)
    {
    case IDL_PACKET2_SERVICE_TEST_PASS:
        csServiceStatus = "PASS";
        break;
    case IDL_PACKET2_SERVICE_TEST_FAIL:
        csServiceStatus = "FAIL";
        break;
    case IDL_PACKET2_SERVICE_TEST_RUNNING:
        csServiceStatus = "RUNNING";
        break;
    default:
    case IDL_PACKET2_SERVICE_TEST_OFF:
        csServiceStatus = "OFF";
        break;
    }

    if (idlPacket2ServiceStats->servicePerfStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        if (idlAllowedSettingsPacket.servicePerfLatencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
            csResult.Format("%.2f %%, %.2f %%, %.3f, %.3f, %s",
                            (double) idlPacket2ServiceStats->servicePerfPctBwAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfPctLossAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterMax / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyMax / 1000.0,
                            csServiceStatus);
        else if (idlAllowedSettingsPacket.servicePerfLatencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
            csResult.Format("%.2f %%, %.2f %%, %.2f, %.2f, %s",
                            (double) idlPacket2ServiceStats->servicePerfPctBwAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfPctLossAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterMax / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyMax / 100.0,
                            csServiceStatus);
        else if (idlAllowedSettingsPacket.servicePerfLatencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
            csResult.Format("%.2f %%, %.2f %%, %.1f, %.1f, %s",
                            (double) idlPacket2ServiceStats->servicePerfPctBwAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfPctLossAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterMax / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyMax / 10.0,
                            csServiceStatus);
        else
            csResult.Format("%.2f %%, %.2f %%, %d, %d, %s",
                            (double) idlPacket2ServiceStats->servicePerfPctBwAvg / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfPctLossAvg / 100.0,
                            idlPacket2ServiceStats->servicePerfJitterMax,
                            idlPacket2ServiceStats->servicePerfLatencyMax,
                            csServiceStatus);
    }
    else
    {
        csResult = "---, ---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:*RST
//***************************
void ScpiPacket::y1564SetFactoryDeflt (CString& csScpiCmd)
{
    CORBA::Any_var anyStructure=new CORBA::Any;

    IdlOp1Struct    op1Struct;
    op1Struct.value = 1; // not really needed, dummy data

    anyStructure <<= op1Struct;
    ProtocolManager_var     g_ProtocolMgr;
    g_ProtocolMgr = CorbaClient::m_ProtocolMgr;
    int idlReturn = g_ProtocolMgr->setCommand(m_globs->g_UserHandle, m_globs->g_ppIndexStruct,
        IDL_Y1564_FACTORY_DEFAULT, anyStructure, m_globs->g_TestUnitId);

    if (idlReturn == IDL_SUCCESS)
        m_pScpiProxyServer->scpiResults("+0");
    else
        m_pScpiProxyServer->reportError(ScpiProxyServer::EXECUTION_ERR);
}


//***************************
// Y1564:LOSSPERF?
//***************************
void ScpiPacket::y1564GetLossPerf (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;
    IdlPpErrorsSimple* perfFrameLossError;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);
    perfFrameLossError = &(idlPacket2ServiceStats->servicePerfFrameLoss);

    if (idlPacket2ServiceStats->servicePerfStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        double averageRate = 0;
        double currentRate = 0;
        double availablePct;

        if (perfFrameLossError->avgErrRateDen != 0)
            averageRate = (double) perfFrameLossError->errCount / (double) perfFrameLossError->avgErrRateDen;
        if (perfFrameLossError->curErrRateDen != 0)
            currentRate = (double) perfFrameLossError->curErrRateNum / (double) perfFrameLossError->curErrRateDen;
        availablePct = 100.0 - ((double)perfFrameLossError->unavailableSecsPct / 100.0);

        csResult.Format("%I64u, %u, %#1.2e, %#1.2e, %.2f %%, %u",
                        perfFrameLossError->errCount,
                        perfFrameLossError->errSecs,
                        averageRate,
                        currentRate,
                        availablePct,
                        perfFrameLossError->unavailableSecs);
    }
    else
    {
        csResult = "---, ---, ---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:SEQPERF?
//***************************
void ScpiPacket::y1564GetSeqPerf (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;
    IdlPpErrorsSimple* perfSeqError;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);
    perfSeqError = &(idlPacket2ServiceStats->servicePerfSeqError);

    if (idlPacket2ServiceStats->servicePerfStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        double averageRate = 0;
        double currentRate = 0;

        if (perfSeqError->avgErrRateDen != 0)
            averageRate = (double) perfSeqError->errCount / (double) perfSeqError->avgErrRateDen;
        if (perfSeqError->curErrRateDen != 0)
            currentRate = (double) perfSeqError->curErrRateNum / (double) perfSeqError->curErrRateDen;

        csResult.Format("%I64u, %u, %#1.2e, %#1.2e",
                        perfSeqError->errCount,
                        perfSeqError->errSecs,
                        averageRate,
                        currentRate);
    }
    else
    {
        csResult = "---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:RXPERF?
//***************************
void ScpiPacket::y1564GetRxPerf (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);

    if (idlPacket2ServiceStats->servicePerfStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        csResult.Format("%.2f %%, %.2f %%, %.2f %%, %.2f %%",
                        (double) idlPacket2ServiceStats->servicePerfPctBwMax / 100,
                        (double) idlPacket2ServiceStats->servicePerfPctBwMin / 100,
                        (double) idlPacket2ServiceStats->servicePerfPctBwAvg / 100,
                        (double) idlPacket2ServiceStats->servicePerfPctBwCurr / 100);
    }
    else
    {
        csResult = "---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:JITPERF?
//***************************
void ScpiPacket::y1564GetJitPerf (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);

    if (idlPacket2ServiceStats->servicePerfStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        if (idlAllowedSettingsPacket.servicePerfJitterValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
            csResult.Format("%.3f, %.3f, %.3f, %.3f",
                            (double) idlPacket2ServiceStats->servicePerfJitterMax  / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterMin  / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterAvg  / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterCurr / 1000.0);
        else if (idlAllowedSettingsPacket.servicePerfJitterValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
            csResult.Format("%.2f, %.2f, %.2f, %.2f",
                            (double) idlPacket2ServiceStats->servicePerfJitterMax  / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterMin  / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterAvg  / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterCurr / 100.0);
        else if (idlAllowedSettingsPacket.servicePerfJitterValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
            csResult.Format("%.1f, %.1f, %.1f, %.1f",
                            (double) idlPacket2ServiceStats->servicePerfJitterMax  / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterMin  / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterAvg  / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfJitterCurr / 10.0);
        else
            csResult.Format("%u, %u, %u, %u",
                            idlPacket2ServiceStats->servicePerfJitterMax,
                            idlPacket2ServiceStats->servicePerfJitterMin,
                            idlPacket2ServiceStats->servicePerfJitterAvg,
                            idlPacket2ServiceStats->servicePerfJitterCurr);
    }
    else
    {
        csResult = "---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// Y1564:LATPERF?
//***************************
void ScpiPacket::y1564GetLatPerf (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int serviceNum;
    IdlPacket2AllSettings idlSettingsPacket;
    IdlPacket2AllowedSettings idlAllowedSettingsPacket;
    IdlPacket2AllServiceStats idlPacket2AllServiceStats;
    IdlPacket2ServiceStats* idlPacket2ServiceStats;

    // Get Current Allowed Settings and stats
    TestCmdGetStatus(callGetPacketAllowed(idlSettingsPacket, idlAllowedSettingsPacket));
    TestCmdGetStatus(callGetPacketServiceStatistics(idlPacket2AllServiceStats));

    // Get the service number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    serviceNum = atoi(csParam);
    if ((serviceNum < 1) || (serviceNum > idlAllowedSettingsPacket.serviceCount))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    idlPacket2ServiceStats = &(idlPacket2AllServiceStats.serviceStats[serviceNum - 1]);

    if (idlPacket2ServiceStats->servicePerfStatus != IDL_PACKET2_SERVICE_TEST_OFF)
    {
        if (idlAllowedSettingsPacket.servicePerfLatencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
            csResult.Format("%.3f, %.3f, %.3f, %.3f",
                            (double) idlPacket2ServiceStats->servicePerfLatencyMax  / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyMin  / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyAvg  / 1000.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyCurr / 1000.0);
        else if (idlAllowedSettingsPacket.servicePerfLatencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
            csResult.Format("%.2f, %.2f, %.2f, %.2f",
                            (double) idlPacket2ServiceStats->servicePerfLatencyMax  / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyMin  / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyAvg  / 100.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyCurr / 100.0);
        else if (idlAllowedSettingsPacket.servicePerfLatencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
            csResult.Format("%.1f, %.1f, %.1f, %.1f",
                            (double) idlPacket2ServiceStats->servicePerfLatencyMax  / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyMin  / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyAvg  / 10.0,
                            (double) idlPacket2ServiceStats->servicePerfLatencyCurr / 10.0);
        else
            csResult.Format("%u, %u, %u, %u",
                            idlPacket2ServiceStats->servicePerfLatencyMax ,
                            idlPacket2ServiceStats->servicePerfLatencyMin ,
                            idlPacket2ServiceStats->servicePerfLatencyAvg ,
                            idlPacket2ServiceStats->servicePerfLatencyCurr);
    }
    else
    {
        csResult = "---, ---, ---, ---";
    }

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// STRM:JIT:MIN?
//***************************
void ScpiPacket::getStreamJitMin (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int streamNum;
    IdlPacket2AllStreamStats idlStreamStatPacket;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get stream stats
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[streamNum].jitterMin == -2)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[streamNum].jitterMin / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[streamNum].jitterMin / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[streamNum].jitterMin / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[streamNum].jitterMin);

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// STRM:JIT:MAX?
//***************************
void ScpiPacket::getStreamJitMax (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int streamNum;
    IdlPacket2AllStreamStats idlStreamStatPacket;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get stream stats
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[streamNum].jitterMin == -2)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[streamNum].jitterMax / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[streamNum].jitterMax / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[streamNum].jitterMax / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[streamNum].jitterMax);

    m_pScpiProxyServer->scpiResults(csResult);
}


//***************************
// STRM:Jit:AVG?
//***************************
void ScpiPacket::getStreamJitAvg (CString& csScpiCmd)
{
    CString csResult;
    CString csParam;
    int streamNum;
    IdlPacket2AllStreamStats idlStreamStatPacket;

    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    // Get stream stats
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));

    if (idlStreamStatPacket.streamStats[streamNum].jitterMin == -2)
        csResult = "N/A";
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_1_NANOSEC)
        csResult.Format("%.3f", (double) idlStreamStatPacket.streamStats[streamNum].jitterAvg / 1000.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_10_NANOSEC)
        csResult.Format("%.2f", (double) idlStreamStatPacket.streamStats[streamNum].jitterAvg / 100.0);
    else if (packetAllowedSettings.streamAllowed[0].latencyValid == IDL_PACKET2_LATENCY_VALID_100_NANOSEC)
        csResult.Format("%.1f", (double) idlStreamStatPacket.streamStats[streamNum].jitterAvg / 10.0);
    else
        csResult.Format("%d", idlStreamStatPacket.streamStats[streamNum].jitterAvg);

    m_pScpiProxyServer->scpiResults(csResult);
}


/////////////
// CUR

//***************************
// STRM:L1:CUR:TXPCTBW?
// STRM:L2:CUR:TXPCTBW?
//***************************
void ScpiPacket::getStreamTxLinkPctBandwidth (CString& csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:CUR:TXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;

    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = idlStreamStat2Packet.streamStats[streamNum].txStreamL2PctBandwidth;
    else
        temp = idlStreamStatPacket.streamStats[streamNum].txStreamPctBandwidth;

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:CUR:RXPCTBW?
// STRM:L2:CUR:RXPCTBW?
//***************************
void ScpiPacket::getStreamRxLinkPctBandwidth (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:CUR:RXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = idlStreamStat2Packet.streamStats[streamNum].rxStreamL2PctBandwidth;
    else
        temp = idlStreamStatPacket.streamStats[streamNum].rxStreamPctBandwidth;

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
      m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:CUR:TXMBPS?
// STRM:L2:CUR:TXMBPS?
//***************************
void ScpiPacket::getStreamTxLinkKBPerSec (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:CUR:TXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamL2KBitPerSec);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamKBitPerSec);

    csResult.Format("%.3f", ((float)temp * 1.0e-3));

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:CUR:RXMBPS?
// STRM:L2:CUR:RXMBPS?
//***************************
void ScpiPacket::getStreamRxLinkKBPerSec (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:CUR:RXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamL2KBitPerSec);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamKBitPerSec);

    csResult.Format("%.3f", ((float)temp * 1.0e-3));

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L2:CUR:TXBYTEPS?
//***************************
void ScpiPacket::getStreamL2TxBytesPerSec (CString &csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:L2:CUR:TXBYTEPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%I64u", idlStreamStat2Packet.streamStats[streamNum].txStreamL2BytesPerSec);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L2:CUR:RXBYTEPS?
//***************************
void ScpiPacket::getStreamL2RxBytesPerSec (CString &csScpiCmd)
{
#ifdef _MYDEBUG
    printf("\nSTRM:L2:CUR:RXBYTEPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%I64u", idlStreamStat2Packet.streamStats[streamNum].rxStreamL2BytesPerSec);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

// END CUR
/////////////



////////////////////
//AVG

//***************************
// STRM:L1:AVG:TXPCTBW?
// STRM:L2:AVG:TXPCTBW?
//***************************
void ScpiPacket::getStreamTxLinkPctBandwidthAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:AVG:TXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = idlStreamStat2Packet.streamStats[streamNum].txStreamL2PctBandwidthAvg;
    else
        temp = idlStreamStat2Packet.streamStats[streamNum].txStreamPctBandwidthAvg;

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:AVG:RXPCTBW?
// STRM:L2:AVG:RXPCTBW?
//***************************
void ScpiPacket::getStreamRxLinkPctBandwidthAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:RXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = idlStreamStat2Packet.streamStats[streamNum].rxStreamL2PctBandwidthAvg;
    else
        temp = idlStreamStatPacket.streamStats[streamNum].rxStreamPctBandwidthAvg;

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:AVG:TXMBPS?
// STRM:L2:AVG:TXMBPS?
//***************************
void ScpiPacket::getStreamTxLinkKBPerSecAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:TXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamL2KBitPerSecAvg);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamKBitPerSecAvg);

    temp = temp / 1000;
    csResult.Format("%.3f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:AVG:RXMBPS?
// STRM:L2:AVG:RXMBPS?
//***************************
void ScpiPacket::getStreamRxLinkKBPerSecAvg (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:RXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamL2KBitPerSecAvg);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamKBitPerSecAvg);

    temp = temp / 1000;
    csResult.Format("%.3f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

// END AVG
/////////////



////////////////////
//MAX

//***************************
// STRM:L1:MAX:TXPCTBW?
// STRM:L2:MAX:TXPCTBW?
//***************************
void ScpiPacket::getStreamTxLinkPctBandwidthMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:TXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = idlStreamStat2Packet.streamStats[streamNum].txStreamL2PctBandwidthMax;
    else
        temp = idlStreamStat2Packet.streamStats[streamNum].txStreamPctBandwidthMax;

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:MAX:RXPCTBW?
// STRM:L2:MAX:RXPCTBW?
//***************************
void ScpiPacket::getStreamRxLinkPctBandwidthMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:RXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = idlStreamStat2Packet.streamStats[streamNum].rxStreamL2PctBandwidthMax;
    else
        temp = idlStreamStatPacket.streamStats[streamNum].rxStreamPctBandwidthMax;

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:MAX:TXMBPS?
// STRM:L2:MAX:TXMBPS?
//***************************
void ScpiPacket::getStreamTxLinkKBPerSecMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:TXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamL2KBitPerSecMax);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamKBitPerSecMax);

    temp = temp / 1000;
    csResult.Format("%.3f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:MAX:RXMBPS?
// STRM:L2:MAX:RXMBPS?
//***************************
void ScpiPacket::getStreamRxLinkKBPerSecMax (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:RXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamL2KBitPerSecMax);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamKBitPerSecMax);

    temp = temp / 1000;
    csResult.Format("%.3f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

// END MAX
/////////////



////////////////////
//MIN

//***************************
// STRM:L1:MIN:TXPCTBW?
// STRM:L2:MIN:TXPCTBW?
//***************************
void ScpiPacket::getStreamTxLinkPctBandwidthMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MIN:TXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamL2PctBandwidthMin);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamPctBandwidthMin);

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:MIN:RXPCTBW?
// STRM:L2:MIN:RXPCTBW?
//***************************
void ScpiPacket::getStreamRxLinkPctBandwidthMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MIN:RXPCTBW?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats idlStreamStatPacket;
    TestCmdGetStatus(callGetPacketStreamStatistics(idlStreamStatPacket));
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamL2PctBandwidthMin);
    else
        temp = static_cast<float>(idlStreamStatPacket.streamStats[streamNum].rxStreamPctBandwidthMin);

    temp = temp / 100;
    csResult.Format("%.2f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:MIN:TXMBPS?
// STRM:L2:MIN:TXMBPS?
//***************************
void ScpiPacket::getStreamTxLinkKBPerSecMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MIN:TXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamL2KBitPerSecMin);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].txStreamKBitPerSecMin);

    temp = temp / 1000;
    csResult.Format("%.3f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:L1:MIN:RXMBPS?
// STRM:L2:MIN:RXMBPS?
//***************************
void ScpiPacket::getStreamRxLinkKBPerSecMin (CString &csScpiCmd, int tagging, boolean isL2/* = false*/)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MIN:RXMBPS?");
#endif
    CString csParam;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    float temp;
    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));
    CString csResult;

    if (isL2)
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamL2KBitPerSecMin);
    else
        temp = static_cast<float>(idlStreamStat2Packet.streamStats[streamNum].rxStreamKBitPerSecMin);

    temp = temp / 1000;
    csResult.Format("%.3f", temp);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

// END MIN
/////////////



//***************************
// STRM:CUR:TXPPS?
//***************************
void ScpiPacket::getStreamTxLinkPacketPerSec (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
      printf("\nSTRM:CUR:TXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].txStreamPacketPerSec);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:CUR:RXPPS?
//***************************
void ScpiPacket::getStreamRxLinkPacketPerSec (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:CUR:RXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].rxStreamPacketPerSec);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// STRM:AVG:TXPPS?
//***************************
void ScpiPacket::getStreamTxLinkPacketPerSecAvg (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:TXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].txStreamPacketPerSecAvg);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:AVG:RXPPS?
//***************************
void ScpiPacket::getStreamRxLinkPacketPerSecAvg (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:AVG:RXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].rxStreamPacketPerSecAvg);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// STRM:MAX:TXPPS?
//***************************
void ScpiPacket::getStreamTxLinkPacketPerSecMax (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MAX:TXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].txStreamPacketPerSecMax);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:MAX:RXPPS?
//***************************
void ScpiPacket::getStreamRxLinkPacketPerSecMax (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MAX:RXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].rxStreamPacketPerSecMax);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}


//***************************
// STRM:MIN:TXPPS?
//***************************
void ScpiPacket::getStreamTxLinkPacketPerSecMin (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MIN:TXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].txStreamPacketPerSecMin);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}

//***************************
// STRM:MIN:RXPPS?
//***************************
void ScpiPacket::getStreamRxLinkPacketPerSecMin (CString &csScpiCmd, int tagging)
{
#ifdef _MYDEBUG
    printf("\nSTRM:MIN:RXPPS?");
#endif
    CString csParam;
    CString csResult;
    int streamNum;
    IdlPacket2AllowedSettings packetAllowedSettings;
    IdlPacket2AllSettings     packetAllSettings;
    // Get Current Settings
    TestCmdGetStatus(getPacket2AllowedSettings (packetAllSettings, packetAllowedSettings));

    // Get the stream number parameter and validate.
    TestAndGetParam(csScpiCmd, csParam);
    streamNum = atoi(csParam) - 1;
    if (IsStreamNumberInvalid(streamNum, packetAllSettings, packetAllowedSettings))
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::DATA_OUT_OF_RANGE);
        return;
    }

    IdlPacket2AllStreamStats2 idlStreamStat2Packet;
    TestCmdGetStatus(callGetPacketStreamStatistics2(idlStreamStat2Packet));

    csResult.Format("%u",idlStreamStat2Packet.streamStats[streamNum].rxStreamPacketPerSecMin);

    if(!csResult.IsEmpty())
    {
        m_pScpiProxyServer->m_queryFlag = true;
        m_pScpiProxyServer->scpiResults(csResult);
    }
    else
    {
        m_pScpiProxyServer->reportError(ScpiProxyServer::INVALID_RESULTS);
    }
}



//******************************************************
//
// Helper function to determine if stream is not valid
// according to the allowed settings / interface
// it will also update streamNum in the case of a
// subPort supported interface needing it to change
// 
//******************************************************
bool ScpiPacket::IsStreamNumberInvalid(int& streamNum,
                                       IdlPacket2AllSettings& packetAllSettings,
                                       IdlPacket2AllowedSettings& packetAllowedSettings)
{
    bool notAllowed = true;

    if ((packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_QUAD_103G_FEC_LAN)           ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_DQUAD_103G_FEC_LAN)          ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP28_DUAL_103G_FEC_LAN)           ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_QUAD_103G_FEC_LAN)         ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_DQUAD_103G_FEC_LAN)        ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD28_DUAL_103G_FEC_LAN)       ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_106G_FEC_LAN)        ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_106G_FEC_LAN_P1P2)   ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_QSFP_DD_OCTAL_50G_FEC_LAN)         ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_CFP56_OCTAL_50G_FEC_LAN)           ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_QUAD_103G_FEC_LAN)         ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_DQUAD_103G_FEC_LAN)         ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP28_DUAL_103G_FEC_LAN)          ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_OCTAL_106G_FEC_LAN)        ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP112_OCTAL_106G_FEC_LAN_P1P2)   ||
        (packetAllSettings.portMapping == IDL_PACKET2_PORT_MAP_MLD_OSFP56_OCTAL_50G_FEC_LAN))
    {
        // subPort supported interfaces with multiple streams
        if ((m_globs->g_ppIndexStruct.ppPhyId - 1) != streamNum)
            notAllowed = true;
        else // allowed
        {
            // set the streamNum internally to be zero,
            // this is to fake out stream numbers matching what the webUI displays
            streamNum  = 0;
            notAllowed = false;
        }
    }
    else if ((streamNum < 0) || (streamNum > (packetAllowedSettings.numStreams - 1)))
    {
        notAllowed = true;
    }
    else // allowed
        notAllowed = false;

    return notAllowed;
}
